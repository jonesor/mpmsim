---
title: "Exploring PCA space"
author: "Owen Jones"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Exploring PCA space}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)

```

1. Simulate 100 matrices with random life histories
2. calculate key life history parameters

Load the required packages
```{r}
library(mpmsim)
library(Rcompadre)
```


```{r}
mpm_set <- generate_mpm_set(
  n = 1000, lower_lambda = 0.9, upper_lambda = 1.1,
  n_stages = 3, fecundity = c(0, 6, 6), archetype = 4, split = TRUE
)

mpm_set[[1]]
A_list <- lapply(mpm_set, function(x) x$mat_A)
U_list <- lapply(mpm_set, function(x) x$mat_U)
F_list <- lapply(mpm_set, function(x) x$mat_F)


my_compadre <- cdb_build_cdb(mat_u = U_list, mat_f = F_list, version = "testrun", metadata = data.frame(ID = 1:length(U_list)))



my_compadre$matA <- Rcompadre::matA(my_compadre)
my_compadre$matU <- Rcompadre::matU(my_compadre)
my_compadre$matF <- Rcompadre::matF(my_compadre)


library(Rage)

# derive trajectories of lx and mx, starting from stage 2
lx <- mpm_to_lx(mpm1$matU, start = 2)
mx <- mpm_to_mx(mpm1$matU, mpm1$matF, start = 2)

# calculate Demetrius' entropy direct from matrix
entropy_d_mat <- function(matU, matF, start = 1){
  lx <- mpm_to_lx(matU, start = start)
  mx <- mpm_to_mx(matU, matF, start = start)
  return(entropy_d(lx, mx))
}

entropy_k_mat <- function(matU, start = 1, ...){
  lx <- mpm_to_lx(matU, start = start)
  return(entropy_k(lx, ...))
}

# calculate generation time from the life table
gt_lt <- function(matU, matF, start = 1, ...){
  tempLT <- mpm_to_table(matU,matF,start = start, ...)
  return(sum(tempLT$x * tempLT$lxmx)/sum(tempLT$lxmx))
}

my_compadre <- cdb_flag(my_compadre,checks = "check_irreducible")
my_compadre <- filter(my_compadre,check_irreducible == TRUE)
#Use a combination of sapply and mapply to calcualte the life history traits for each matrix.
my_compadre$gt <- sapply(my_compadre$matA, popbio::generation.time)
my_compadre$gt_lt <- mapply(gt_lt, my_compadre$matU,my_compadre$matF)
my_compadre$longevity <- sapply(my_compadre$matU, Rage::longevity, x_max = 1000, lx_crit = 0.01)
my_compadre$lifeExpect <- sapply(my_compadre$matU, Rage::life_expect_mean)
my_compadre$entropy_d <- mapply(entropy_d_mat, my_compadre$matU,my_compadre$matF)
my_compadre$entropy_k <- mapply(entropy_k_mat, my_compadre$matU)
my_compadre$nrr_R0 <- mapply(net_repro_rate, my_compadre$matU,my_compadre$matF)
my_compadre$gt_Rage <- mapply(gen_time, my_compadre$matU,my_compadre$matF)
my_compadre$reac <- sapply(my_compadre$matA, popdemo::reac, bound="upper")
my_compadre$dr <- sapply(my_compadre$matA, popdemo::dr)



head(cdb_metadata(my_compadre))

my_compadre_unconstrained <- my_compadre

plot(my_compadre$gt_lt,my_compadre$longevity, log = "xy", xlim = c(2,2100),ylim = c(2,1100))
abline(a = 0, b =1)


plot(my_compadre$gt,my_compadre$gt_lt, log = "xy", xlim = c(2,2100),ylim = c(2,1100))

abline(a = 0, b =1)

#pcData <- data.frame(gt=rep(NA,nmat),dent=NA,kentRage=NA,
#                     doakMax = NA,doakEta=NA,R0=NA,react=NA, dr =NA)

library(dplyr)
temp <- my_compadre_unconstrained %>% 
  filter(gt>2000)
tempMat <- temp$mat[1]
matA(tempMat[[1]])

popbio::generation.time(matA(tempMat[[1]]))

tempLT <- Rage::mpm_to_table(matU = matU(tempMat[[1]]),matF = matF(tempMat[[1]]))

plot(tempLT$x,tempLT$lx)
plot(tempLT$x,tempLT$mx)



gt_lt(matU(tempMat[[1]]),matF = matF(tempMat[[1]]))

popbio::generation.time(matA(tempMat[[1]]))


sum(tempLT$x * tempLT$lxmx)/sum(tempLT$lxmx)


ss <- my_compadre %>% 
  filter(gt>20) %>% 
  filter(gt_lt<10)

matA(ss)



```

