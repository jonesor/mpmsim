---
title: "Sampling error and its propagation"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Sampling error and its propagation}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)

library(mpmsim)
set.seed(42)
```


## Introduction

Uncertainty in the individual elements of a matrix population model (MPM) can propagate, affecting the accuracy of metrics derived from the model, such as population growth rate, generation time, etc.

One approach to estimate this uncertainty is parametric bootstrapping, which generates a sampling distribution for the matrix model based on assumptions about the underlying demographic processes and uncertainties in individual matrix elements. For example, fertility can be modeled as a Poisson-distributed process, suitable for count-based data, while survival can be represented by a binomial distribution, reflecting the probability of individual survival.

The `compute_ci()` function estimates a 95% confidence interval (95% CI) for any MPM-derived metric by generating a sampling distribution through resampling based on the given assumptions. The confidence interval is derived from the 2.5th and 97.5th percentiles of this distribution, where a narrower interval indicates greater precision.

The width and shape of the sampling distribution are influenced by several factors, including the sample size used for estimating matrix elements, the matrix model's structure, the assumptions underlying the `compute_ci()` function, and the distribution of uncertainties across matrix elements. To accurately assess the precision of MPM estimates, it is necessary to consider these factors when interpreting the results.

For derived quantities that require only the U matrix, such as life expectancy (e.g. calculated using using `Rage::life_expect_mean()`), the function `compute_ci_U()` should be used.

The following examples show how to use these functions.

## Estimate 95% Confidence Intervals

We can estimate the 95% CI for any metric derived from a matrix population model. In this example, we focus on the population growth rate, $\lambda$. 

Consider a matrix model **A**, which is composed of submatrices **U** (survival/growth) and **F** (fertility), such that **A** = **U** + **F**. 

The methods require that the matrix model be split into its component submatrices because the underlying processes are governed by distributions with different statistical properties: individual survival is treated as a binary process (0 = dies, 1 = survives), whereas individual reproduction follows a Poisson distribution.

In this example, the matrix is simple, with only the top-right element representing reproduction, while all other elements represent survival or growth.


$$
\mathbf{A} = \begin{bmatrix}
0.1 & 5.0 \\
0.2 & 0.4 \
\end{bmatrix}
, 

\mathbf{U} = \begin{bmatrix}
0.1 & 0.0 \\
0.2 & 0.4 \
\end{bmatrix}
,

\mathbf{F} = \begin{bmatrix}
0.0 & 5.0 \\
0.0 & 0.0 \
\end{bmatrix}
$$

We an enter these matrices into R as follows:

```{r}
matU <- matrix(c(
  0.1, 0.0,
  0.2, 0.4
), byrow = TRUE, nrow = 2)

matF <- matrix(c(
  0.0, 5.0,
  0.0, 0.0
), byrow = TRUE, nrow = 2)
```

If the sample size used to estimate each element of the matrix is `20` individuals, we can estimate the 95% CI for $\lambda$ using the `compute_ci()` function. This function requires several arguments: `mat_U` and `mat_F` represent the survival/growth matrix and fertility matrix respectively, and `sample_size` specifies the number of individuals used to estimate each element (in this case, `20`). The argument `FUN` defines the function to be applied to the resulting **A** matrix to calculate the desired metric. In this example, we use the `eigs` function from the `popdemo` package to compute $\lambda$. The `what` argument is passed to `eigs`, telling the function that we want to calculate `lambda`.

```{r}
compute_ci(
  mat_U = matU, mat_F = matF, sample_size = 20,
  FUN = popdemo::eigs, what = "lambda"
)
```


We can examine the sampling distribution of these $\lambda$ estimates estimates by using the argument `dist.out = TRUE`.

```{r, fig.height = 4, fig.width = 6, fig.align = "center"}
distLambda_20 <- compute_ci(
  mat_U = matU, mat_F = matF,
  sample_size = 20, FUN = popdemo::eigs, what = "lambda",
  dist.out = TRUE
)
hist(distLambda_20$estimates)
```
## Sample sizes that vary across the MPM

In the above example, it is assumed that the sample size used to make the parameter estimates (i.e. each element of the matrix model) was the same throughout the model. However, sample size might vary across different parts of the matrix or submatrices due to variations in data availability or biological processes. For example, data on survival and growth (represented in the **U** matrix) might be more abundant because these processes can often be tracked more easily in field studies. In contrast, fertility data (represented in the **F** matrix) may be harder to collect, especially for species with complex reproductive cycles, leading to smaller sample sizes. Additionally, environmental factors or study limitations can result in unequal sampling efforts across different life stages, contributing to varying sample sizes in the matrix elements. 

To account for this, the `compute_ci` function allows flexibility in specifying sample size, which can be added in several ways to control how variability is modeled across different parts of the matrix. As an alternative to providing a single value to apply uniformly to all elements (as done above) you can provide a matrix specifying sample sizes for each element, or a list of matrices for distinct components (e.g., **U** and **F** matrices). This flexibility helps tailor the modeling of uncertainty to reflect different data availability across biological processes.

For instance, in the following code, we use the same MPM as above, split into **U** and **F** submatrices (`matU` and `matF`, respectively), but now assume that sample size varies between these components, with `40` individuals for **U** and `15 for **F**. Here, the sample size is consistent across all elements within the **U** matrix, but you could also assign different sample sizes to individual elements of the matrix, allowing for different sample sizes for different transitions.

```{r}
# Define the sample sizes for U
mat_U_ss <- matrix(c(
  40, 40,
  40, 40
), byrow = TRUE, nrow = 2)

# Define sample sizes for F
mat_F_ss <- matrix(c(
  0.0, 15,  
  0.0, 0.0  
), byrow = TRUE, nrow = 2)

# Combine sample sizes into list
sampleSizes <- list(mat_U_ss = mat_U_ss, mat_F_ss = mat_F_ss)

# Calculate CI for lambda
compute_ci(
  mat_U = matU, mat_F = matF, sample_size = sampleSizes,
  FUN = popdemo::eigs, what = "lambda"
)
```



## Exploring the impact of sample size

What if the sample size was considerably larger, at 100?

```{r, fig.height = 4, fig.width = 6, fig.align = "center"}
distLambda_100 <- compute_ci(
  mat_U = matU, mat_F = matF,
  sample_size = 100, FUN = popdemo::eigs, what = "lambda",
  dist.out = TRUE
)
```

Comparing those two distributions, it is unsurprising that the posterior distribution with a large sample size is narrower than that of a small sample size.

```{r compareDist2, fig.height = 6, fig.width = 6, fig.align = "center"}
par(mfrow = c(2, 1))
hist(distLambda_20$estimates, xlim = c(0, 1.75))
hist(distLambda_100$estimates, xlim = c(0, 1.75))
```

One could use this approach to conduct a power analysis by simulation. For example one could ask, "What sample size would I require in order to detect a 20% change in population growth rate?" 

```{r}
observedLambda <- popdemo::eigs(matU + matF, what = "lambda")
reducedLambda <- observedLambda * 0.8


simDist <- compute_ci(
  mat_U = matU, mat_F = matF,
  sample_size = 50, FUN = popdemo::eigs, what = "lambda",
  dist.out = TRUE
)$estimates
hist(simDist)
abline(v = observedLambda, lty = 2, lwd = 2)
abline(v = reducedLambda, lty = 2, lwd = 2, col = "red")
sum(simDist < observedLambda) / length(simDist)
```

## When sample size varies across the MPM

If the sample size varies among elements of the MPM, for example, with a sample size of 15 for fertility and 40 for survival/growth processes, we first define the sample sizes in two separate matrices: one representing fertility and the other representing survival/growth. These matrices are then combined into a list for subsequent use.

Following this setup, we can proceed to calculate the confidence intervals in the same manner as before, passing the list of sample size matrices as an argument to `compute_ci`.

```{r}
# Define sample sizes for F
mat_F_ss <- matrix(c(
  0.0, 15,  
  0.0, 0.0  
), byrow = TRUE, nrow = 2)

# Define the sample sizes for U
mat_U_ss <- matrix(c(
  40, 40,
  40, 40
), byrow = TRUE, nrow = 2)

# Combine sample sizes into list
sampleSizes <- list(mat_U_ss = mat_U_ss, mat_F_ss = mat_F_ss)

# Calculate CI for lambda
compute_ci(
  mat_U = matU, mat_F = matF, sample_size = sampleSizes,
  FUN = popdemo::eigs, what = "lambda"
)
```


What if the sample size was higher for some elements than others? No problem, the `sample_size` argument accepts a matrix of sample sizes (or a list of matrices labelled as `mat_U_ss` and `mat_F_ss`).

```{r}
sample_size_mat <- matrix(c(
  20, 100,
  20, 20
), byrow = TRUE, nrow = 2)

distLambda_variable <- compute_ci(
  mat_U = matU, mat_F = matF,
  sample_size = sample_size_mat,
  FUN = popdemo::eigs, what = "lambda",
  dist.out = TRUE
)
hist(distLambda_variable$estimates)
```

```{r compareDist3, fig.height = 9, fig.width = 6, fig.align = "center"}
par(mfrow = c(3, 1))
hist(distLambda_20$estimates, xlim = c(0, 1.75))
hist(distLambda_100$estimates, xlim = c(0, 1.75))
hist(distLambda_variable$estimates, xlim = c(0, 1.75))
```

