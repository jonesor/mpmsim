[{"path":"https://jonesor.github.io/mpmsim/articles/error_propagation.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"Sampling error and its propagation","text":"Uncertainty individual elements matrix population model (MPM) can propagate, affecting accuracy metrics derived model, population growth rate, generation time, etc. One approach estimate uncertainty parametric bootstrapping, generates sampling distribution matrix model based assumptions underlying demographic processes uncertainties individual matrix elements. example, reproductive output can modelled Poisson-distributed process, suitable count-based data, survival can represented binomial distribution, reflecting probability individual survival. compute_ci function estimates 95% confidence interval (95% CI) MPM-derived metric generating sampling distribution resampling based given assumptions. 95% CI derived 2.5th 97.5th percentiles distribution, narrower interval indicates greater precision. width shape sampling distribution influenced several factors, including sample size used estimating matrix elements, matrix model’s structure, assumptions underlying compute_ci function, distribution uncertainties across matrix elements. accurately assess precision MPM estimates, necessary consider factors interpreting results. derived quantities require U matrix, life expectancy (e.g. calculated using using Rage::life_expect_mean), function compute_ci_U used. following examples show use functions.","code":""},{"path":"https://jonesor.github.io/mpmsim/articles/error_propagation.html","id":"aims","dir":"Articles","previous_headings":"","what":"Aims","title":"Sampling error and its propagation","text":"purpose vignette illustrate use mpmsim assess estimate sampling error MPMs uncertainty propagates derived metrics. approach useful several reasons, including: Estimating confidence intervals (CIs) key demographic metrics, population growth rate using parametric bootstrapping methods. Exploring impact sample size precision estimates population growth rate metrics derived MPMs. Evaluating propagation uncertainty across different matrix elements submatrices (survival/growth vs. reproduction) MPMs.","code":""},{"path":"https://jonesor.github.io/mpmsim/articles/error_propagation.html","id":"estimate-95-confidence-intervals","dir":"Articles","previous_headings":"","what":"Estimate 95% Confidence Intervals","title":"Sampling error and its propagation","text":"can estimate 95% CI metric derived matrix population model. example, focus population growth rate, λ\\lambda. Consider matrix model , composed submatrices U (survival/growth) F (sexual reproduction), = U + F. methods require matrix model split component submatrices underlying processes governed distributions different statistical properties: individual survival treated binary process (0 = dies, 1 = survives), whereas individual reproduction follows Poisson distribution. example, matrix simple, top-right element representing reproduction, elements represent survival growth. 𝐀=[0.15.00.20.4] \\mathbf{} = \\begin{bmatrix} 0.1 & 5.0 \\\\ 0.2 & 0.4 \\ \\end{bmatrix} 𝐔=[0.10.00.20.4] \\mathbf{U} = \\begin{bmatrix} 0.1 & 0.0 \\\\ 0.2 & 0.4 \\ \\end{bmatrix} 𝐅=[0.05.00.00.0] \\mathbf{F} = \\begin{bmatrix} 0.0 & 5.0 \\\\ 0.0 & 0.0 \\ \\end{bmatrix} can enter matrices R follows, first entering U F matrices, summing get matrix. estimated population growth rate (λ\\lambda) can calculated using eigs function popdemo package like : can now estimate 95% CI estimate, based knowledge sample size(s) used parameterise MPM. sample size used estimate element matrix 20 individuals, can estimate 95% CI λ\\lambda using compute_ci function. function requires several arguments: mat_U mat_F represent survival/growth matrix reproductive output matrix respectively, sample_size specifies number individuals used estimate element (case, 20). argument FUN defines function applied resulting matrix calculate desired metric. can examine sampling distribution λ\\lambda estimates estimates using argument dist.= TRUE.","code":"matU <- matrix(c(   0.1, 0.0,   0.2, 0.4 ), byrow = TRUE, nrow = 2)  matF <- matrix(c(   0.0, 5.0,   0.0, 0.0 ), byrow = TRUE, nrow = 2)  matA <- matU + matF popdemo::eigs(matA, what = \"lambda\") #> [1] 1.261187 compute_ci(   mat_U = matU, mat_F = matF, sample_size = 20,   FUN = popdemo::eigs, what = \"lambda\" ) #>      2.5%     97.5%  #> 0.7097788 1.7020301 distLambda_20 <- compute_ci(   mat_U = matU, mat_F = matF,   sample_size = 20, FUN = popdemo::eigs, what = \"lambda\",   dist.out = TRUE ) hist(distLambda_20$estimates)"},{"path":"https://jonesor.github.io/mpmsim/articles/error_propagation.html","id":"sample-sizes-that-vary-across-the-mpm","dir":"Articles","previous_headings":"","what":"Sample sizes that vary across the MPM","title":"Sampling error and its propagation","text":"example, assumed sample size used make parameter estimates (.e. element matrix model) throughout model. However, sample size might vary across different parts matrix submatrices due variations data availability biological processes. example, data survival growth (represented U matrix) might abundant processes can often tracked easily field studies. contrast, reproductive output data (represented F matrix) may harder collect, especially species complex reproductive cycles, leading smaller sample sizes. Additionally, environmental factors study limitations can result unequal sampling efforts across different life stages, contributing varying sample sizes matrix elements. account , compute_ci function allows flexibility specifying sample size, can added several ways control variability modeled across different parts matrix. alternative providing single value apply uniformly elements (done ) can provide matrix specifying sample sizes element, list matrices distinct components (e.g., U F matrices). flexibility helps tailor modeling uncertainty reflect different data availability across biological processes. instance, following code, use MPM , split U F submatrices (matU matF, respectively), now assume sample size varies components, 40 individuals U 15 F. , sample size consistent across elements within U matrix, also assign different sample sizes individual elements matrix, allowing different sample sizes different transitions.","code":"# Define the sample sizes for U mat_U_ss <- matrix(c(   40, 40,   40, 40 ), byrow = TRUE, nrow = 2)  # Define sample sizes for F mat_F_ss <- matrix(c(   0.0, 15,     0.0, 0.0   ), byrow = TRUE, nrow = 2)  # Combine sample sizes into list sampleSizes <- list(mat_U_ss = mat_U_ss, mat_F_ss = mat_F_ss)  # Calculate CI for lambda compute_ci(   mat_U = matU, mat_F = matF, sample_size = sampleSizes,   FUN = popdemo::eigs, what = \"lambda\" ) #>     2.5%    97.5%  #> 0.895995 1.579860"},{"path":"https://jonesor.github.io/mpmsim/articles/error_propagation.html","id":"exploring-the-impact-of-sample-size","dir":"Articles","previous_headings":"","what":"Exploring the impact of sample size","title":"Sampling error and its propagation","text":"Sample size critical determining precision statistical estimates. demographic studies, small sample sizes can lead high uncertainty estimates derived measures like λ\\lambda, making difficult make strong inferences. Larger sample sizes reduce uncertainty, seen narrower confidence intervals around λ\\lambda increase sample size 20 (calculated ) 100 ().  approach can used perform form power analysis simulation, technique determining sample size required detect effect specified statistical power significance level. instance, one might ask, ’sample size needed confidently conclude population growth rate 1.0? following code creates plot visualize precision λ\\lambda estimates improves sample size increases. first defines set sample sizes iterate , uses compute_ci calculate confidence intervals (CIs) λ\\lambda estimated MPMs based sample sizes. plots λ\\lambda estimates CIs, along reference line λ=1\\lambda = 1. goal show sample size increases, width CIs shrinks, increasing confidence value λ\\lambda. case, sample size approximately 70 appears sufficient. However, sample size likely greater importance elastic elements MPM. Therefore, focusing elements help users better understand specific sample size requirements system. targeted approach lead nuanced study design, allowing optimized sampling efforts areas precision matters .","code":"distLambda_100 <- compute_ci(   mat_U = matU, mat_F = matF,   sample_size = 100, FUN = popdemo::eigs, what = \"lambda\",   dist.out = TRUE )  par(mfrow = c(2, 1)) hist(distLambda_20$estimates, xlim = c(0, 1.75)) hist(distLambda_100$estimates, xlim = c(0, 1.75)) # Define sample sizes to iterate over sample_sizes <- seq(10,100,10)  # Lambda value for reference matA <- matF + matU true_lambda <- popdemo::eigs(matA, what = \"lambda\")  # Initialize an empty data frame with predefined columns ci_results <- data.frame(   sample_size = sample_sizes,   ci_lower = numeric(length(sample_sizes)),   ci_upper = numeric(length(sample_sizes)),   estimate_mean = numeric(length(sample_sizes)) )  # Loop through each sample size and calculate the CI for lambda for (i in seq_along(sample_sizes)) {   n <- sample_sizes[i]      # Compute CI for the current sample size   dist_lambda <- compute_ci(     mat_U = matU, mat_F = matF,     sample_size = n, FUN = popdemo::eigs, what = \"lambda\",     dist.out = TRUE   )      # Calculate 95% CI from the distribution   ci_results$ci_lower[i] <- quantile(dist_lambda$estimates, 0.025)   ci_results$ci_upper[i] <- quantile(dist_lambda$estimates, 0.975)   ci_results$estimate_mean[i] <- mean(dist_lambda$estimates) }  # Calculate error bars ci_lower_error <- ci_results$estimate_mean - ci_results$ci_lower ci_upper_error <- ci_results$ci_upper - ci_results$estimate_mean  # Create the plot plot(ci_results$sample_size, ci_results$estimate_mean,      ylim = range(ci_results$ci_lower, ci_results$ci_upper),      pch = 19, xlab = \"Sample Size\", ylab = \"Lambda Estimate\",      main = \"Effect of Sample Size on Lambda Estimate Precision\")  # Add error bars and reference line arrows(ci_results$sample_size, ci_results$ci_lower,         ci_results$sample_size, ci_results$ci_upper,        angle = 90, code = 3, length = 0.05, col = \"blue\") abline(h = 1, lty = 2)"},{"path":"https://jonesor.github.io/mpmsim/articles/error_propagation.html","id":"conclusion","dir":"Articles","previous_headings":"","what":"Conclusion","title":"Sampling error and its propagation","text":"vignette demonstrates sampling error propagates MPMs, influencing metrics like population growth rate, provides practical method estimating confidence intervals metrics using compute_ci. applying tools like compute_ci, users can also evaluate effect sample size estimate precision, using information optimize data collection efforts improve reliability demographic estimates.","code":""},{"path":"https://jonesor.github.io/mpmsim/articles/error_propagation.html","id":"addendum","dir":"Articles","previous_headings":"","what":"Addendum","title":"Sampling error and its propagation","text":"compute_ci function intended metrics rely full matrix. However, metrics, like life_expect_mean Rage package, require U matrix. metrics, users use compute_ci_U function, works similarly compute_ci, specifically designed metrics focus survival growth processes within U matrix.","code":""},{"path":"https://jonesor.github.io/mpmsim/articles/generate_lefkovitch_models.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"Generating Lefkovitch matrices","text":"Lefkovitch matrix population models (MPMs) introduced Leonard Lefkovitch 1965 paper, “Study Population Growth Organisms Grouped Stages”, published Biometrics.. paper extended concept Leslie MPMs, structured age, stage-structured populations, providing framework widely used ecology, evolution conservation studies. Lefkovitch MPM, square matrix used model population growth across discrete projection intervals, typically representing years. matrix element represents either transition probability different stages reproductive output stage across projection interval. MPM can divided submatrices: one survival/growth (U matrix), one sexual reproduction (F matrix) one asexual reproduction (C matrix), = U + F + C. Occasionally, reproduction matrices lumped together reproduction matrix, R (.e. R = F + C). Reproduction often termed fecundity population biology literature. elements U matrix represent survival growth stage--stage time steps. Therefore column sums U submatrix exceed 1. reproductive output elements F C (R) submatrices upper bound indicate number new individuals stage can produce time interval. Zero entries matrices indicate transitions occur. project population size structure time, MPM multiplied vector representing current population structure (number individuals stage). results new vector shows predicted population structure next time step. process can repeated project population dynamics multiple time steps. Lefkovitch models useful studying population dynamics different scenarios, changes survival reproductive rates, different management strategies. broad applications theoretical applied ecology.","code":""},{"path":"https://jonesor.github.io/mpmsim/articles/generate_lefkovitch_models.html","id":"aims","dir":"Articles","previous_headings":"","what":"Aims","title":"Generating Lefkovitch matrices","text":"purpose vignette illustrate simulate stage-based (Lefkovitch) MPMs based defined life history archetypes. several reasons one want , including, limited : Exploring life history life cycle structure influences population dynamics. Generating MPMs defined life cycle properties teaching purposes. following sections, vignette : Explain life cycles can categorised Archetypes. Show generate random Lefkovitch MPM based archetype. Show rapidly produce sets many random MPMs. Show constrain MPMs matrix properties.","code":""},{"path":"https://jonesor.github.io/mpmsim/articles/generate_lefkovitch_models.html","id":"preparation","dir":"Articles","previous_headings":"","what":"Preparation","title":"Generating Lefkovitch matrices","text":"beginning, users need load required packages.","code":"library(mpmsim) library(dplyr) library(Rage) library(ggplot2) library(Rcompadre)"},{"path":"https://jonesor.github.io/mpmsim/articles/generate_lefkovitch_models.html","id":"life-cycle-archetypes-and-generating-an-mpm","dir":"Articles","previous_headings":"","what":"1. Life cycle archetypes and generating an MPM","title":"Generating Lefkovitch matrices","text":"stage-based (Lefkovitch) matrix population models (MPMs), different life cycle types can represented various structural forms matrices. life cycle types can captured using different life history archetypes, define transitions stages survival probabilities population. life history archetypes, based Takada et al. (2018), follows: Archetype 1: elements positive, meaning transitions /stage possible. model represents life history individuals can progress retrogress rapidly. Archetype 2: Similar Archetype 1, survival probability increasing monotonically individuals advance later stages. model also allows rapid progression retrogression realistic stage-specific survival probabilities. Archetype 3: Positive non-zero elements survival allowed diagonal lower sub-diagonal matrix. model represents life cycle retrogression allowed, progression can happen immediately larger/developed stage (slow progression, e.g., trees). Archetype 4: Similar Archetype 3 additional assumption stage-specific survival increases individuals increase size/developmental stage. archetypes, fecundity placed top row matrix. Takada et al.’s paper, fecundity always placed top right MPM, meaning “last” stage life cycle reproduced. approach can relaxed allow reproduction stage.","code":""},{"path":"https://jonesor.github.io/mpmsim/articles/generate_lefkovitch_models.html","id":"generate-a-random-lefkovitch-mpm-based-on-an-archetype","dir":"Articles","previous_headings":"","what":"2. Generate a random Lefkovitch MPM based on an archetype","title":"Generating Lefkovitch matrices","text":"mpmsim function rand_lefko_mpm can used generate random MPM conforms one four life cycle archetypes. function allows generation random MPMs based archetypes, survival growth (U matrix) based draws Dirichlet distribution ensure biological plausibility. Dirichlet distribution used draw survival growth values ensures sum probabilities stage equal 1, necessary biologically realistic models. function allows users specify wide range reproductive output scenarios , offering flexibility fecundity modelled across stages. function straightforward. following example, create three-stage MPM based Archetype 2. set fecundity, arbitrarily, 5. default, single value given, placed top-right hand corner F matrix. Also, default, fecundity assumed sexual. introduce variability fecundity, users can provide reproductive output list two matrices, numeric values dimensions n_stages, representing lower upper limits mean fecundity entire matrix model. Reproductive output values drawn uniform distribution two values. Users use 0 lower upper limits cases fecundity. following code provides example:","code":"rand_lefko_mpm(n_stages = 3, fecundity = 5, archetype = 2) #> $mat_A #>             [,1]       [,2]       [,3] #> [1,] 0.005877166 0.10766181 5.72412770 #> [2,] 0.509913175 0.03602856 0.06736799 #> [3,] 0.287840153 0.74138349 0.19955576 #>  #> $mat_U #>             [,1]       [,2]       [,3] #> [1,] 0.005877166 0.10766181 0.72412770 #> [2,] 0.509913175 0.03602856 0.06736799 #> [3,] 0.287840153 0.74138349 0.19955576 #>  #> $mat_F #>      [,1] [,2] [,3] #> [1,]    0    0    5 #> [2,]    0    0    0 #> [3,]    0    0    0 lower_reprod <- matrix(c(   0, 0, 0,   0, 0, 0,   0, 0, 0 ), nrow = 3, ncol = 3, byrow = TRUE) upper_reprod <- matrix(c(   0, 4, 20,   0, 0, 0,   0, 0, 0 ), nrow = 3, ncol = 3, byrow = TRUE)  rand_lefko_mpm(   n_stages = 3, fecundity = list(lower_reprod, upper_reprod),   archetype = 2 ) #> $mat_A #>           [,1]      [,2]       [,3] #> [1,] 0.0873477 2.6402006 15.2043937 #> [2,] 0.4082913 0.1851252  0.5516964 #> [3,] 0.3924441 0.1736190  0.1107596 #>  #> $mat_U #>           [,1]      [,2]      [,3] #> [1,] 0.0873477 0.5799473 0.3249008 #> [2,] 0.4082913 0.1851252 0.5516964 #> [3,] 0.3924441 0.1736190 0.1107596 #>  #> $mat_F #>      [,1]     [,2]     [,3] #> [1,]    0 2.060253 14.87949 #> [2,]    0 0.000000  0.00000 #> [3,]    0 0.000000  0.00000"},{"path":"https://jonesor.github.io/mpmsim/articles/generate_lefkovitch_models.html","id":"generate-sets-of-lefkovitch-matrices","dir":"Articles","previous_headings":"","what":"3. Generate sets of Lefkovitch matrices","title":"Generating Lefkovitch matrices","text":"sometimes desirable create large numbers MPMs particular properties order test hypotheses. stage-based (Lefkovitch) MPMs, can implemented using rand_lefko_set function. function acts wrapper previously described function generates set Lefkovitch MPMs based defined life cycle archetype specified reproductive output. example, users may wish generate MPMs different life history archetypes explore life cycle structure may influence population dynamics. specifying number stages, fecundity values, archetypes, users can produce MPMs tailored specific research needs. capability useful exploring effects life history traits population dynamics, testing ecological evolutionary hypotheses, teaching purposes. function returns either list CompadreDB object depending output argument. output set CompadreDB object, archetype MPM included column metadata. following code shows users can generate 100 matrices CompadreDB object. producing output CompadreDB object, matrices can accessed using functions RCompadre R package. example, get matrix, U/F submatrices users can use matA, matU matF functions. following code illustrates rapidly calculate population growth rate matrices. Users can examine vignettes Rcompadre Rage packages additional insight potential operations compadreDB object.","code":"myMatrices <- rand_lefko_set(   n = 100, n_stages = 3, fecundity = 12,   archetype = 4, output = \"Type1\" ) # Obtain the matrices x <- matA(myMatrices)  # Calculate lambda for each matrix lambdaVals <- sapply(x, popdemo::eigs, what = \"lambda\") summary(lambdaVals) #>    Min. 1st Qu.  Median    Mean 3rd Qu.    Max.  #>  0.7378  1.1395  1.4965  1.4653  1.7106  2.1926"},{"path":"https://jonesor.github.io/mpmsim/articles/generate_lefkovitch_models.html","id":"constraining-the-output-matrices","dir":"Articles","previous_headings":"","what":"4. Constraining the output matrices","title":"Generating Lefkovitch matrices","text":"Critically, users can impose constraints “acceptable” properties randomly generated MPMs. example, analyses, may desirable generate MPMs population growth rate constrained values near 1. handled constraint argument, takes data frame specifying criteria acceptable MPMs. data frame must four columns: fun, arg, lower, upper. fun column contains name function calculates metric constrained (e.g., eigs, popdemo package). arg column specifies additional argument function requires (e.g., = \"lambda\" eigs function), using NA additional argument needed. lower upper columns set bounds acceptable range metric. ’s example use constraint argument ensure generated MPMs population growth rate (lambda) 0.9 1.1. can check worked examining matrices.","code":"library(popdemo)  constrain_df <- data.frame(   fun = \"eigs\", arg = \"lambda\", lower = 0.9, upper = 1.1 )  myMatrices <- rand_lefko_set(   n = 100, n_stages = 3, fecundity = 12, constraint = constrain_df,   archetype = 4, output = \"Type1\" ) # Obtain the matrices x <- matA(myMatrices)  # Calculate lambda for each matrix lambdaVals <- sapply(x, popdemo::eigs, what = \"lambda\") summary(lambdaVals) #>    Min. 1st Qu.  Median    Mean 3rd Qu.    Max.  #>  0.9019  0.9612  1.0148  1.0115  1.0635  1.0984"},{"path":"https://jonesor.github.io/mpmsim/articles/generate_lefkovitch_models.html","id":"conclusion","dir":"Articles","previous_headings":"","what":"Conclusion","title":"Generating Lefkovitch matrices","text":"vignette provided comprehensive guide generating Lefkovitch matrix population models (MPMs) based life history archetypes. using rand_lefko_mpm rand_lefko_set functions, users can create individual MPMs large sets MPMs tailored specific research needs. ability impose constraints models allows precise control properties, ensuring generated MPMs meet defined criteria, specific population growth rates. flexibility power functions facilitate exploration population dynamics various scenarios, aiding hypothesis testing studies population biology life history theory. Additionally, tight integration RCompadre package facilitates use generated models, enhancing utility theoretical applied ecological research.","code":""},{"path":"https://jonesor.github.io/mpmsim/articles/generate_leslie_models.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"Generating Leslie matrices","text":"Leslie matrix models, named Patrick Leslie introduced 1940s, type matrix population model (MPM) used describe demography age-structured populations. commonly used studies wildlife, conservation evolutionary biology. Leslie MPM, square matrix used model discrete, age-structured population growth projection interval, often representing years, time step. element matrix represents transition probability different age classes indicates average reproductive output (often referred fecundity population biology fertility human demography) age class. information MPM () can split two submatrices (U F), representing survival/growth reproduction, respectively. = F + C. Survival Probabilities: subdiagonal (immediately main diagonal) MPM consists survival probabilities. entry shows probability individual one age class survive next age class. probabilities can understood age trajectory survival can modelled using mathematical model describing age-specific mortality changes age. Reproductive Output: first row MPM contains reproductive output age class, representing number new individuals produced projection interval. often referred fecundity ecological contexts. entries MPM typically zero, indicating transitions impossible. project population size structure time, MPM multiplied vector represents current population structure (number individuals age class). process results new vector shows predicted structure population next time step. calculation can iterated repeatedly project population structure time. Leslie matrices useful studying population dynamics different scenarios, changes survival rates, fecundity rates, management strategies. widely applied theoretical applied ecology.","code":""},{"path":"https://jonesor.github.io/mpmsim/articles/generate_leslie_models.html","id":"aims","dir":"Articles","previous_headings":"","what":"Aims","title":"Generating Leslie matrices","text":"aim vignette demonstrate simulate Leslie matrix population models (MPMs) using functional forms mortality reproduction. simulation useful various purposes, including: Investigating influence senescence parameters population dynamics. Generating MPMs based empirical parameter estimates mortality reproduction literature. Creating MPMs specific properties educational research purposes. following sections, document : Explain basics mortality reproduction trajectories. Show produce life tables reflecting trajectories mortality reproduction. Show produce MPMs life tables. Show generate sets many MPMs based defined mortality reproduction characteristics.","code":""},{"path":"https://jonesor.github.io/mpmsim/articles/generate_leslie_models.html","id":"preparation","dir":"Articles","previous_headings":"","what":"Preparation","title":"Generating Leslie matrices","text":"beginning, users need load required packages.","code":"library(mpmsim) library(dplyr) library(Rage) library(ggplot2) library(Rcompadre)"},{"path":"https://jonesor.github.io/mpmsim/articles/generate_leslie_models.html","id":"functional-forms-of-mortality-and-reproduction","dir":"Articles","previous_headings":"","what":"1. Functional forms of mortality and reproduction","title":"Generating Leslie matrices","text":"numerous published well-used functional forms used describe mortality risk (hazard) changes age. model_mortality function (synonym model_survival) handles 6 models: Gompertz, Gompertz-Makeham, Weibull, Weibull-Makeham, Siler Exponential. nutshell: Gompertz: mortality rate increases exponentially age. hx=b0eb1xh_x = b_0 \\mathrm{e}^{b_1  x} Gompertz-Makeham: mortality rate increases exponentially age, additional age-independent constant mortality. hx=b0eb1x+ch_x = b_0 \\mathrm{e}^{b_1  x} + c Weibull: mortality rate scales age, increasing rate can either accelerate decelerate, depending parameters model. hx=b0b1(b1x)(b0−1)h_x = b_0  b_1  (b_1  x)^{(b_0 - 1)} Weibull-Makeham: basic Weibull, additional age-independent constant mortality. hx=b0b1(b1x)(b0−1)+ch_x = b_0  b_1  (b_1  x)^{(b_0 - 1)} + c Siler: mortality model separates mortality rates two age-related components — juvenile mortality, declines exponentially age adult mortality, increases exponentially. hx=a0e−a1x+c+b0eb1xh_x = a_0 \\mathrm{e}^{-a_1  x} + c + b_0 \\mathrm{e}^{b_1 x} Exponential: Constant mortality unchanging age. hx=ch_x = c illustrated .  addition functional forms mortality, , course, functional forms used model reproductive output. model_fecundity function (synonyms model_fedundity model_reproduction) handles five types: logistic, step, von Bertalanffy, normal Hadwiger. models originate human demography, fertility used realised reproductive output fecundity refers reproductive potential. ecology population biology, however, fecundity typically describes actual reproductive output. Since mpmsim designed population biologists, use terms fecundity, simply reproduction/reproductive output. Logistic: Reproductive output initially increases rapidly age slows plateau approaches maximum value. fx=/(1+exp(−k(x−xm)))f_x = / (1 + exp(-k  (x - x_m))) Step: Reproductive output initially zero, jumps particular level specified age, remains constant. fx={,x≥mA,x<mf_x= \\begin{cases} , x \\geq m \\\\ , x <  m \\end{cases} von Bertalanffy: model often used growth dynamics adapted reproduction describe changes age time following logistic growth form limited strict upper asymptote. shows reproductive output might increase decrease, following sigmoid curve. fx=(1−exp(−k(x−x0)))f_x =  (1 - exp(-k  (x - x_0))) Normal : Reproductive output modelled normal distribution describe reproductive output increases, peaks, decreases bell curve around mean age reproductive capacity. fx=×exp(−12(x−μσ)2)f_x = \\times \\exp\\left(-\\frac{1}{2}\\left(\\frac{x-\\mu}{\\sigma}\\right)^{2}\\,\\right) Hadwiger: outcomes model qualitatively similar normal distribution. fx=abC(Cx)32exp{−b2(Cx+xC−2)}f_x = \\frac{ab}{C} \\left (\\frac{C}{x}  \\right )^\\frac{3}{2} \\exp \\left \\{ -b^2  \\left ( \\frac{C}{x}+\\frac{x}{C}-2 \\right ) \\right \\}  Collectively, mortality fecundity functions offer large scope modelling variety demographic trajectories apparent across tree life.","code":""},{"path":"https://jonesor.github.io/mpmsim/articles/generate_leslie_models.html","id":"trajectories-of-mortality-and-reproductive-output-and-production-of-life-tables","dir":"Articles","previous_headings":"","what":"2. Trajectories of mortality and reproductive output, and production of life tables","title":"Generating Leslie matrices","text":"obtain trajectory mortality, users can use model_mortality function, takes input parameters specified mortality model. output function standard life table data.frame including columns age (x), age-specific hazard (hx), survivorship (lx), age-specific probability death survival (qx px). default, life table truncated age survivorship function declines 0.01 (.e. 1% individuals cohort remain alive). can useful explore impact parameters mortality hazard (hx) graphically, especially users unfamiliar chosen models.  model_fecundity function similar model_mortality function, arguments type fecundity model, parameters. However, output model_fecundity function vector reproductive output values rather data.frame. allows us add fecundity column (fecundity) directly life table produced earlier, follows: , can useful plot relevant data visualise .","code":"(lt1 <- model_mortality(params = c(b_0 = 0.1, b_1 = 0.2), model = \"Gompertz\")) #>     x        hx         lx        qx        px #> 1   0 0.1000000 1.00000000 0.1051240 0.8948760 #> 2   1 0.1221403 0.89487598 0.1268617 0.8731383 #> 3   2 0.1491825 0.78135045 0.1526972 0.8473028 #> 4   3 0.1822119 0.66204041 0.1832179 0.8167821 #> 5   4 0.2225541 0.54074272 0.2190086 0.7809914 #> 6   5 0.2718282 0.42231542 0.2606027 0.7393973 #> 7   6 0.3320117 0.31225886 0.3084127 0.6915873 #> 8   7 0.4055200 0.21595427 0.3626343 0.6373657 #> 9   8 0.4953032 0.13764186 0.4231275 0.5768725 #> 10  9 0.6049647 0.07940180 0.4892807 0.5107193 #> 11 10 0.7389056 0.04055203 0.5598781 0.4401219 #> 12 11 0.9025013 0.01784784 0.6330059 0.3669941 ggplot(lt1, aes(x = x, y = hx)) +   geom_line() +   ggtitle(\"Gompertz mortality (b_0 = 0.1, b_1 = 0.2)\") (lt1 <- lt1 |>   mutate(fecundity = model_fecundity(     age = x, params = c(A = 3),     maturity = 3,     model = \"step\"   ))) #>     x        hx         lx        qx        px fecundity #> 1   0 0.1000000 1.00000000 0.1051240 0.8948760         0 #> 2   1 0.1221403 0.89487598 0.1268617 0.8731383         0 #> 3   2 0.1491825 0.78135045 0.1526972 0.8473028         0 #> 4   3 0.1822119 0.66204041 0.1832179 0.8167821         3 #> 5   4 0.2225541 0.54074272 0.2190086 0.7809914         3 #> 6   5 0.2718282 0.42231542 0.2606027 0.7393973         3 #> 7   6 0.3320117 0.31225886 0.3084127 0.6915873         3 #> 8   7 0.4055200 0.21595427 0.3626343 0.6373657         3 #> 9   8 0.4953032 0.13764186 0.4231275 0.5768725         3 #> 10  9 0.6049647 0.07940180 0.4892807 0.5107193         3 #> 11 10 0.7389056 0.04055203 0.5598781 0.4401219         3 #> 12 11 0.9025013 0.01784784 0.6330059 0.3669941         3 ggplot(lt1, aes(x = x, y = fecundity)) +   geom_line() +   ggtitle(\"Step fecundity, maturity at age 3\")"},{"path":"https://jonesor.github.io/mpmsim/articles/generate_leslie_models.html","id":"from-life-table-to-mpm","dir":"Articles","previous_headings":"","what":"3. From life table to MPM","title":"Generating Leslie matrices","text":"Users can now turn life tables, containing age-specific survival reproductive trajectories, Leslie matrices using make_leslie_mpm function. MPMs can large small depending maximum life span population: mentioned , population modelled less 1% cohort remains alive.","code":"make_leslie_mpm(lifetable = lt1) #>           [,1]      [,2]      [,3]      [,4]      [,5]      [,6]      [,7] #>  [1,] 0.000000 0.0000000 0.0000000 3.0000000 3.0000000 3.0000000 3.0000000 #>  [2,] 0.894876 0.0000000 0.0000000 0.0000000 0.0000000 0.0000000 0.0000000 #>  [3,] 0.000000 0.8731383 0.0000000 0.0000000 0.0000000 0.0000000 0.0000000 #>  [4,] 0.000000 0.0000000 0.8473028 0.0000000 0.0000000 0.0000000 0.0000000 #>  [5,] 0.000000 0.0000000 0.0000000 0.8167821 0.0000000 0.0000000 0.0000000 #>  [6,] 0.000000 0.0000000 0.0000000 0.0000000 0.7809914 0.0000000 0.0000000 #>  [7,] 0.000000 0.0000000 0.0000000 0.0000000 0.0000000 0.7393973 0.0000000 #>  [8,] 0.000000 0.0000000 0.0000000 0.0000000 0.0000000 0.0000000 0.6915873 #>  [9,] 0.000000 0.0000000 0.0000000 0.0000000 0.0000000 0.0000000 0.0000000 #> [10,] 0.000000 0.0000000 0.0000000 0.0000000 0.0000000 0.0000000 0.0000000 #> [11,] 0.000000 0.0000000 0.0000000 0.0000000 0.0000000 0.0000000 0.0000000 #> [12,] 0.000000 0.0000000 0.0000000 0.0000000 0.0000000 0.0000000 0.0000000 #>            [,8]      [,9]     [,10]     [,11]     [,12] #>  [1,] 3.0000000 3.0000000 3.0000000 3.0000000 3.0000000 #>  [2,] 0.0000000 0.0000000 0.0000000 0.0000000 0.0000000 #>  [3,] 0.0000000 0.0000000 0.0000000 0.0000000 0.0000000 #>  [4,] 0.0000000 0.0000000 0.0000000 0.0000000 0.0000000 #>  [5,] 0.0000000 0.0000000 0.0000000 0.0000000 0.0000000 #>  [6,] 0.0000000 0.0000000 0.0000000 0.0000000 0.0000000 #>  [7,] 0.0000000 0.0000000 0.0000000 0.0000000 0.0000000 #>  [8,] 0.0000000 0.0000000 0.0000000 0.0000000 0.0000000 #>  [9,] 0.6373657 0.0000000 0.0000000 0.0000000 0.0000000 #> [10,] 0.0000000 0.5768725 0.0000000 0.0000000 0.0000000 #> [11,] 0.0000000 0.0000000 0.5107193 0.0000000 0.0000000 #> [12,] 0.0000000 0.0000000 0.0000000 0.4401219 0.3669941"},{"path":"https://jonesor.github.io/mpmsim/articles/generate_leslie_models.html","id":"producing-sets-of-mpms-based-on-defined-model-characteristics","dir":"Articles","previous_headings":"","what":"4. Producing sets of MPMs based on defined model characteristics","title":"Generating Leslie matrices","text":"sometimes desirable create large numbers MPMs particular properties order test hypotheses. Leslie MPMs, can implemented straightforward way using function rand_leslie_set. function generates set Leslie MPMs based defined mortality fecundity models, using model parameters randomly drawn specified distributions. example, users may wish generate MPMs Gompertz models explore rate senescence influences population dynamics. Users must first set data frame describing distribution parameters drawn random. data frame number rows equal number parameters model, two values describe distribution. case uniform distribution, minimum maximum parameter values, respectively normal distribution represent mean standard deviation. parameters entered order appear model equations (see ?model_mortality), exact order depending chosen mortality model. Gompertz-Makeham model: hx=b0eb1x+ch_x = b_0 \\mathrm{e}^{b_1  x} + c output argument defines output one six types (Type1 Type6). outputs include CompadreDB objects list objects, MPMs can split component submatrices (U F, MPM, = U + F). special case Type6 outputs provided list life tables rather MPMs. output set CompadreDB object, mortality fecundity model parameters used generate MPM included metadata. following example illustrates production 50 Leslie MPMs output CompadreDB object based Gompertz-Makeham mortality model step fecundity model maturity beginning age 0. optional argument, scale_output = TRUE scale fecundity output MPMs ensure population growth rate lambda. scaling algorithm multiplies fecundity part MPM (F submatrix) simple scaling factor ensure population growth rate 1 maintaining shape (magnitude) fecundity trajectory. used care: desirability manipulation strongly depends use MPMs put . function operates quite fast. example, older MacBook (3.10GHz Intel 4 cores), takes 17 seconds generate 5000 MPMs parameters mentioned . aid assessing simulation, users can produce simple summary MPMs using summarise_mpms function. Note, though, works CompadreDB outputs. case, working Leslie MPMs, dimension MPMs indicative maximum age reached individuals population. producing output CompadreDB object, matrices can accessed using functions RCompadre R package. example, get matrix, U/F submatrices users can use matA, matU matF functions. following code illustrates rapidly calculate population growth rate matrices. Users can examine vignettes Rcompadre Rage packages additional insight potential operations compadreDB object.","code":"mortParams <- data.frame(   minVal = c(0, 0.01, 0.1),   maxVal = c(0.05, 0.15, 0.2) )  fecundityParams <- data.frame(   minVal = 2,   maxVal = 10 )  maturityParam <- c(0, 0)  (myMatrices <- rand_leslie_set(   n_models = 50,   mortality_model = \"GompertzMakeham\",   fecundity_model = \"step\",   mortality_params = mortParams,   fecundity_params = fecundityParams,   fecundity_maturity_params = maturityParam,   dist_type = \"uniform\",   output = \"Type1\" )) #> A COM(P)ADRE database ('CompadreDB') object with ?? SPECIES and 50 MATRICES. #>  #> # A tibble: 50 × 8 #>    mat        mortality_model      b_0    b_1     C fecundity_model     A #>    <list>     <chr>              <dbl>  <dbl> <dbl> <chr>           <dbl> #>  1 <CompdrMt> gompertzmakeham 0.0457   0.141  0.129 step             8.64 #>  2 <CompdrMt> gompertzmakeham 0.0321   0.0827 0.174 step             3.08 #>  3 <CompdrMt> gompertzmakeham 0.0328   0.109  0.146 step             7.75 #>  4 <CompdrMt> gompertzmakeham 0.0467   0.0458 0.146 step             9.52 #>  5 <CompdrMt> gompertzmakeham 0.0489   0.0264 0.147 step             6.48 #>  6 <CompdrMt> gompertzmakeham 0.0452   0.0294 0.199 step             9.57 #>  7 <CompdrMt> gompertzmakeham 0.00412  0.0820 0.139 step             9.25 #>  8 <CompdrMt> gompertzmakeham 0.0223   0.127  0.174 step             8.49 #>  9 <CompdrMt> gompertzmakeham 0.0194   0.106  0.100 step             8.66 #> 10 <CompdrMt> gompertzmakeham 0.000367 0.0391 0.191 step             6.89 #> # ℹ 40 more rows #> # ℹ 1 more variable: fecundity_scaling <dbl> summarise_mpms(myMatrices) #> Summary of matrix dimension: #>    Min. 1st Qu.  Median    Mean 3rd Qu.    Max.  #>   15.00   18.25   22.00   22.98   26.00   39.00  #> Summary of lambda values: #>    Min. 1st Qu.  Median    Mean 3rd Qu.    Max.  #>   2.845   6.010   7.970   7.557   9.150  10.672  #>  #> Summary of maximum F values: #>    Min. 1st Qu.  Median    Mean 3rd Qu.    Max.  #>   2.002   5.157   7.142   6.720   8.327   9.788  #>  #> Summary of maximum U values: #>    Min. 1st Qu.  Median    Mean 3rd Qu.    Max.  #>  0.7829  0.8159  0.8347  0.8365  0.8545  0.8925  #>  #> Summary of minimum non-zero U values: #>    Min. 1st Qu.  Median    Mean 3rd Qu.    Max.  #>  0.5715  0.6881  0.7650  0.7514  0.8160  0.8814 # Obtain the matrices x <- matA(myMatrices)  # Calculate lambda for each matrix sapply(x, popdemo::eigs, what = \"lambda\") #>  [1]  9.480062  3.889616  8.587381 10.343567  7.303660 10.356146 10.112353 #>  [8]  9.308862  9.549256  7.720332 10.672096  7.928430  5.604869  8.872518 #> [15]  6.966830  7.339943  9.468459  3.993036  8.631979  2.871674  8.012464 #> [22]  3.567593  2.844529  8.688251  7.778629  5.968972  8.664013  9.523154 #> [29]  7.123514  9.482587  7.556071 10.495633  7.644149  7.441366  7.792883 #> [36]  9.092281 10.412818  5.422186  9.018497  8.325535  4.386485  5.377892 #> [43]  6.131147  3.940014  8.952296  4.907484  9.138780  9.154187  3.317446 #> [50]  8.668165"},{"path":"https://jonesor.github.io/mpmsim/articles/generate_leslie_models.html","id":"conclusion","dir":"Articles","previous_headings":"","what":"Conclusion","title":"Generating Leslie matrices","text":"vignette demonstrated generate Leslie matrices using functional forms mortality fecundity, allowing users simulate virtual species varied life histories. matrices can used explore life history parameter differences affect population dynamics, supporting various research educational applications.","code":""},{"path":"https://jonesor.github.io/mpmsim/articles/generating_lefkovitch_models.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"Generating Lefkovitch models","text":"Lefkovitch matrix population models (MPMs) introduced Leonard Lefkovitch 1965 paper, “Study Population Growth Organisms Grouped Stages”, published Biometrics.. paper extended concept Leslie MPMs, structured age, stage-structured populations, providing framework widely used ecology, evolution conservation studies. Lefkovitch MPM, square matrix used model population growth across discrete projection intervals, typically representing years. matrix element represents either transition probability different stages reproductive output stage across projection interval. MPM can divided submatrices: one survival/growth (U matrix), one sexual reproduction (F matrix) one asexual reproduction (C matrix), = U + F + C. Occasionally, reproduction matrices lumped together reproduction matrix, R (.e. R = F + C). Reproduction often termed fecundity population biology literature. elements U matrix represent survival growth stage--stage time steps. Therefore column sums U submatrix exceed 1. reproductive output elements F C (R) submatrices upper bound indicate number new individuals stage can produce time interval. Zero entries matrices indicate transitions occur. project population size structure time, MPM multiplied vector representing current population structure (number individuals stage). results new vector shows predicted population structure next time step. process can repeated project population dynamics multiple time steps. Lefkovitch models useful studying population dynamics different scenarios, changes survival reproductive rates, different management strategies. broad applications theoretical applied ecology.","code":""},{"path":"https://jonesor.github.io/mpmsim/articles/generating_lefkovitch_models.html","id":"aims","dir":"Articles","previous_headings":"","what":"Aims","title":"Generating Lefkovitch models","text":"purpose vignette illustrate simulate stage-based (Lefkovitch) MPMs based defined life history archetypes. several reasons one want , including, limited : Exploring life history life cycle structure influences population dynamics. Generating MPMs defined life cycle properties teaching purposes. following sections, vignette : Explain life cycles can categorised Archetypes. Show generate random Lefkovitch MPM based archetype. Show rapidly produce sets many random MPMs. Show constrain MPMs matrix properties.","code":""},{"path":"https://jonesor.github.io/mpmsim/articles/generating_lefkovitch_models.html","id":"preparation","dir":"Articles","previous_headings":"","what":"Preparation","title":"Generating Lefkovitch models","text":"beginning, users need load required packages.","code":"library(mpmsim) library(dplyr) library(Rage) library(ggplot2) library(Rcompadre)"},{"path":"https://jonesor.github.io/mpmsim/articles/generating_lefkovitch_models.html","id":"life-cycle-archetypes-and-generating-an-mpm","dir":"Articles","previous_headings":"","what":"1. Life cycle archetypes and generating an MPM","title":"Generating Lefkovitch models","text":"stage-based (Lefkovitch) matrix population models (MPMs), different life cycle types can represented various structural forms matrices. life cycle types can captured using different life history archetypes, define transitions stages survival probabilities population. life history archetypes, based Takada et al. (2018), follows: Archetype 1: elements positive, meaning transitions /stage possible. model represents life history individuals can progress retrogress rapidly. Archetype 2: Similar Archetype 1, survival probability increasing monotonically individuals advance later stages. model also allows rapid progression retrogression realistic stage-specific survival probabilities. Archetype 3: Positive non-zero elements survival allowed diagonal lower sub-diagonal matrix. model represents life cycle retrogression allowed, progression can happen immediately larger/developed stage (slow progression, e.g., trees). Archetype 4: Similar Archetype 3 additional assumption stage-specific survival increases individuals increase size/developmental stage. archetypes, fecundity placed top row matrix. Takada et al.’s paper, fecundity always placed top right MPM, meaning “last” stage life cycle reproduced. approach can relaxed allow reproduction stage.","code":""},{"path":"https://jonesor.github.io/mpmsim/articles/generating_lefkovitch_models.html","id":"generate-a-random-lefkovitch-mpm-based-on-an-archetype","dir":"Articles","previous_headings":"","what":"2. Generate a random Lefkovitch MPM based on an archetype","title":"Generating Lefkovitch models","text":"mpmsim function rand_lefko_mpm can used generate random MPM conforms one four life cycle archetypes. function allows generation random MPMs based archetypes, survival growth (U matrix) based draws Dirichlet distribution ensure biological plausibility. Dirichlet distribution used draw survival growth values ensures sum probabilities stage equal 1, necessary biologically realistic models. function allows users specify wide range reproductive output scenarios , offering flexibility fecundity modelled across stages. function straightforward. following example, create three-stage MPM based Archetype 2. set fecundity, arbitrarily, 5. default, single value given, placed top-right hand corner F matrix. Also, default, fecundity assumed sexual. introduce variability fecundity, users can provide reproductive output list two matrices, numeric values dimensions n_stages, representing lower upper limits mean fecundity entire matrix model. Reproductive output values drawn uniform distribution two values. Users use 0 lower upper limits cases fecundity. following code provides example:","code":"rand_lefko_mpm(n_stages = 3, fecundity = 5, archetype = 2) #> $mat_A #>             [,1]       [,2]       [,3] #> [1,] 0.005877166 0.10766181 5.72412770 #> [2,] 0.509913175 0.03602856 0.06736799 #> [3,] 0.287840153 0.74138349 0.19955576 #>  #> $mat_U #>             [,1]       [,2]       [,3] #> [1,] 0.005877166 0.10766181 0.72412770 #> [2,] 0.509913175 0.03602856 0.06736799 #> [3,] 0.287840153 0.74138349 0.19955576 #>  #> $mat_F #>      [,1] [,2] [,3] #> [1,]    0    0    5 #> [2,]    0    0    0 #> [3,]    0    0    0 lower_reprod <- matrix(c(   0, 0, 0,   0, 0, 0,   0, 0, 0 ), nrow = 3, ncol = 3, byrow = TRUE) upper_reprod <- matrix(c(   0, 4, 20,   0, 0, 0,   0, 0, 0 ), nrow = 3, ncol = 3, byrow = TRUE)  rand_lefko_mpm(   n_stages = 3, fecundity = list(lower_reprod, upper_reprod),   archetype = 2 ) #> $mat_A #>           [,1]      [,2]       [,3] #> [1,] 0.0873477 2.6402006 15.2043937 #> [2,] 0.4082913 0.1851252  0.5516964 #> [3,] 0.3924441 0.1736190  0.1107596 #>  #> $mat_U #>           [,1]      [,2]      [,3] #> [1,] 0.0873477 0.5799473 0.3249008 #> [2,] 0.4082913 0.1851252 0.5516964 #> [3,] 0.3924441 0.1736190 0.1107596 #>  #> $mat_F #>      [,1]     [,2]     [,3] #> [1,]    0 2.060253 14.87949 #> [2,]    0 0.000000  0.00000 #> [3,]    0 0.000000  0.00000"},{"path":"https://jonesor.github.io/mpmsim/articles/generating_lefkovitch_models.html","id":"generate-sets-of-lefkovitch-matrices","dir":"Articles","previous_headings":"","what":"3. Generate sets of Lefkovitch matrices","title":"Generating Lefkovitch models","text":"sometimes desirable create large numbers MPMs particular properties order test hypotheses. stage-based (Lefkovitch) MPMs, can implemented using rand_lefko_set function. function acts wrapper previously described function generates set Lefkovitch MPMs based defined life cycle archetype specified reproductive output. example, users may wish generate MPMs different life history archetypes explore life cycle structure may influence population dynamics. specifying number stages, fecundity values, archetypes, users can produce MPMs tailored specific research needs. capability useful exploring effects life history traits population dynamics, testing ecological evolutionary hypotheses, teaching purposes. function returns either list CompadreDB object depending output argument. output set CompadreDB object, archetype MPM included column metadata. following code shows users can generate 100 matrices CompadreDB object. producing output CompadreDB object, matrices can accessed using functions RCompadre R package. example, get matrix, U/F submatrices users can use matA, matU matF functions. following code illustrates rapidly calculate population growth rate matrices. Users can examine vignettes Rcompadre Rage packages additional insight potential operations compadreDB object.","code":"myMatrices <- rand_lefko_set(   n = 100, n_stages = 3, fecundity = 12,   archetype = 4, output = \"Type1\" ) # Obtain the matrices x <- matA(myMatrices)  # Calculate lambda for each matrix lambdaVals <- sapply(x, popdemo::eigs, what = \"lambda\") summary(lambdaVals) #>    Min. 1st Qu.  Median    Mean 3rd Qu.    Max.  #>  0.7378  1.1395  1.4965  1.4653  1.7106  2.1926"},{"path":"https://jonesor.github.io/mpmsim/articles/generating_lefkovitch_models.html","id":"constraining-the-output-matrices","dir":"Articles","previous_headings":"","what":"4. Constraining the output matrices","title":"Generating Lefkovitch models","text":"Critically, users can impose constraints “acceptable” properties randomly generated MPMs. example, analyses, may desirable generate MPMs population growth rate constrained values near 1. handled constraint argument, takes data frame specifying criteria acceptable MPMs. data frame must four columns: fun, arg, lower, upper. fun column contains name function calculates metric constrained (e.g., eigs, popdemo package). arg column specifies additional argument function requires (e.g., = \"lambda\" eigs function), using NA additional argument needed. lower upper columns set bounds acceptable range metric. ’s example use constraint argument ensure generated MPMs population growth rate (lambda) 0.9 1.1. can check worked examining matrices.","code":"library(popdemo)  constrain_df <- data.frame(   fun = \"eigs\", arg = \"lambda\", lower = 0.9, upper = 1.1 )  myMatrices <- rand_lefko_set(   n = 100, n_stages = 3, fecundity = 12, constraint = constrain_df,   archetype = 4, output = \"Type1\" ) # Obtain the matrices x <- matA(myMatrices)  # Calculate lambda for each matrix lambdaVals <- sapply(x, popdemo::eigs, what = \"lambda\") summary(lambdaVals) #>    Min. 1st Qu.  Median    Mean 3rd Qu.    Max.  #>  0.9019  0.9612  1.0148  1.0115  1.0635  1.0984"},{"path":"https://jonesor.github.io/mpmsim/articles/generating_lefkovitch_models.html","id":"conclusion","dir":"Articles","previous_headings":"","what":"Conclusion","title":"Generating Lefkovitch models","text":"vignette provided comprehensive guide generating Lefkovitch matrix population models (MPMs) based life history archetypes. using rand_lefko_mpm rand_lefko_set functions, users can create individual MPMs large sets MPMs tailored specific research needs. ability impose constraints models allows precise control properties, ensuring generated MPMs meet defined criteria, specific population growth rates. flexibility power functions facilitate exploration population dynamics various scenarios, aiding hypothesis testing studies population biology life history theory. Additionally, tight integration RCompadre package facilitates use generated models, enhancing utility theoretical applied ecological research.","code":""},{"path":"https://jonesor.github.io/mpmsim/articles/generating_leslie_models.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"Generating Leslie models","text":"Leslie matrix models, named Patrick Leslie introduced 1940s, type matrix population model (MPM) used describe demography age-structured populations. commonly used studies wildlife, conservation evolutionary biology. Leslie MPM, square matrix used model discrete, age-structured population growth projection interval, often representing years, time step. element matrix represents transition probability different age classes indicates average reproductive output (often referred fecundity population biology fertility human demography) age class. information MPM () can split two submatrices (U F), representing survival/growth reproduction, respectively. = F + C. Survival Probabilities: subdiagonal (immediately main diagonal) MPM consists survival probabilities. entry shows probability individual one age class survive next age class. probabilities can understood age trajectory survival can modelled using mathematical model describing age-specific mortality changes age. Reproductive Output: first row MPM contains reproductive output age class, representing number new individuals produced projection interval. often referred fecundity ecological contexts. entries MPM typically zero, indicating transitions impossible. project population size structure time, MPM multiplied vector represents current population structure (number individuals age class). process results new vector shows predicted structure population next time step. calculation can iterated repeatedly project population structure time. Leslie matrices useful studying population dynamics different scenarios, changes survival rates, fecundity rates, management strategies. widely applied theoretical applied ecology.","code":""},{"path":"https://jonesor.github.io/mpmsim/articles/generating_leslie_models.html","id":"aims","dir":"Articles","previous_headings":"","what":"Aims","title":"Generating Leslie models","text":"aim vignette demonstrate simulate Leslie matrix population models (MPMs) using functional forms mortality reproduction. simulation useful various purposes, including: Investigating influence senescence parameters population dynamics. Generating MPMs based empirical parameter estimates mortality reproduction literature. Creating MPMs specific properties educational research purposes. following sections, document : Explain basics mortality reproduction trajectories. Show produce life tables reflecting trajectories mortality reproduction. Show produce MPMs life tables. Show generate sets many MPMs based defined mortality reproduction characteristics.","code":""},{"path":"https://jonesor.github.io/mpmsim/articles/generating_leslie_models.html","id":"preparation","dir":"Articles","previous_headings":"","what":"Preparation","title":"Generating Leslie models","text":"beginning, users need load required packages.","code":"library(mpmsim) library(dplyr) library(Rage) library(ggplot2) library(Rcompadre)"},{"path":"https://jonesor.github.io/mpmsim/articles/generating_leslie_models.html","id":"functional-forms-of-mortality-and-reproduction","dir":"Articles","previous_headings":"","what":"1. Functional forms of mortality and reproduction","title":"Generating Leslie models","text":"numerous published well-used functional forms used describe mortality risk (hazard) changes age. model_mortality function (synonym model_survival) handles 6 models: Gompertz, Gompertz-Makeham, Weibull, Weibull-Makeham, Siler Exponential. nutshell: Gompertz: mortality rate increases exponentially age. hx=b0eb1xh_x = b_0 \\mathrm{e}^{b_1  x} Gompertz-Makeham: mortality rate increases exponentially age, additional age-independent constant mortality. hx=b0eb1x+ch_x = b_0 \\mathrm{e}^{b_1  x} + c Weibull: mortality rate scales age, increasing rate can either accelerate decelerate, depending parameters model. hx=b0b1(b1x)(b0−1)h_x = b_0  b_1  (b_1  x)^{(b_0 - 1)} Weibull-Makeham: basic Weibull, additional age-independent constant mortality. hx=b0b1(b1x)(b0−1)+ch_x = b_0  b_1  (b_1  x)^{(b_0 - 1)} + c Siler: mortality model separates mortality rates two age-related components — juvenile mortality, declines exponentially age adult mortality, increases exponentially. hx=a0e−a1x+c+b0eb1xh_x = a_0 \\mathrm{e}^{-a_1  x} + c + b_0 \\mathrm{e}^{b_1 x} Exponential: Constant mortality unchanging age. hx=ch_x = c illustrated .  addition functional forms mortality, , course, functional forms used model reproductive output. model_fecundity function (synonyms model_fedundity model_reproduction) handles five types: logistic, step, von Bertalanffy, normal Hadwiger. models originate human demography, fertility used realised reproductive output fecundity refers reproductive potential. ecology population biology, however, fecundity typically describes actual reproductive output. Since mpmsim designed population biologists, use terms fecundity, simply reproduction/reproductive output. Step: Reproductive output initially zero, jumps particular level specified age, remains constant. fx={,x≥mA,x<mf_x= \\begin{cases} , x \\geq m \\\\ , x <  m \\end{cases} Logistic: Reproductive output initially increases rapidly age slows plateau approaches maximum value. fx=/(1+exp(−k(x−xm)))f_x = / (1 + exp(-k  (x - x_m))) von Bertalanffy: model often used growth dynamics adapted reproduction describe changes age time following logistic growth form limited strict upper asymptote. shows reproductive output might increase decrease, following sigmoid curve. fx=(1−exp(−k(x−x0)))f_x =  (1 - exp(-k  (x - x_0))) Normal : Reproductive output modelled normal distribution describe reproductive output increases, peaks, decreases bell curve around mean age reproductive capacity. fx=×exp(−12(x−μσ)2)f_x = \\times \\exp\\left(-\\frac{1}{2}\\left(\\frac{x-\\mu}{\\sigma}\\right)^{2}\\,\\right) Hadwiger: outcomes model qualitatively similar normal distribution. fx=abC(Cx)32exp{−b2(Cx+xC−2)}f_x = \\frac{ab}{C} \\left (\\frac{C}{x}  \\right )^\\frac{3}{2} \\exp \\left \\{ -b^2  \\left ( \\frac{C}{x}+\\frac{x}{C}-2 \\right ) \\right \\}  Collectively, mortality fecundity functions offer large scope options modelling variety demographic trajectories apparent across tree life.","code":""},{"path":"https://jonesor.github.io/mpmsim/articles/generating_leslie_models.html","id":"trajectories-of-mortality-and-reproductive-output-and-production-of-life-tables","dir":"Articles","previous_headings":"","what":"2. Trajectories of mortality and reproductive output, and production of life tables","title":"Generating Leslie models","text":"obtain trajectory mortality, users can use model_mortality function, takes input parameters specified mortality model. output function standard life table data.frame including columns age (x), age-specific hazard (hx), survivorship (lx, probability surviving birth (age 0) age x), age-specific probability death survival (qx px). default, life table truncated age survivorship function declines 0.01 (.e. 1% individuals cohort remain alive). can useful explore impact parameters mortality hazard (hx) graphically, especially users unfamiliar chosen models.  model_fecundity function similar model_mortality function, arguments type fecundity model, parameters. However, output model_fecundity function vector reproductive output values rather data.frame. allows us add fecundity column (fecundity) directly life table produced earlier, follows: , can useful plot relevant data visualise .","code":"(lt1 <- model_mortality(params = c(b_0 = 0.1, b_1 = 0.2), model = \"Gompertz\")) #>     x        hx         lx        qx        px #> 1   0 0.1000000 1.00000000 0.1051240 0.8948760 #> 2   1 0.1221403 0.89487598 0.1268617 0.8731383 #> 3   2 0.1491825 0.78135045 0.1526972 0.8473028 #> 4   3 0.1822119 0.66204041 0.1832179 0.8167821 #> 5   4 0.2225541 0.54074272 0.2190086 0.7809914 #> 6   5 0.2718282 0.42231542 0.2606027 0.7393973 #> 7   6 0.3320117 0.31225886 0.3084127 0.6915873 #> 8   7 0.4055200 0.21595427 0.3626343 0.6373657 #> 9   8 0.4953032 0.13764186 0.4231275 0.5768725 #> 10  9 0.6049647 0.07940180 0.4892807 0.5107193 #> 11 10 0.7389056 0.04055203 0.5598781 0.4401219 #> 12 11 0.9025013 0.01784784 0.6330059 0.3669941 ggplot(lt1, aes(x = x, y = hx)) +   geom_line() +   ggtitle(\"Gompertz mortality (b_0 = 0.1, b_1 = 0.2)\") (lt1 <- lt1 |>   mutate(fecundity = model_fecundity(     age = x, params = c(A = 3),     maturity = 3,     model = \"step\"   ))) #>     x        hx         lx        qx        px fecundity #> 1   0 0.1000000 1.00000000 0.1051240 0.8948760         0 #> 2   1 0.1221403 0.89487598 0.1268617 0.8731383         0 #> 3   2 0.1491825 0.78135045 0.1526972 0.8473028         0 #> 4   3 0.1822119 0.66204041 0.1832179 0.8167821         3 #> 5   4 0.2225541 0.54074272 0.2190086 0.7809914         3 #> 6   5 0.2718282 0.42231542 0.2606027 0.7393973         3 #> 7   6 0.3320117 0.31225886 0.3084127 0.6915873         3 #> 8   7 0.4055200 0.21595427 0.3626343 0.6373657         3 #> 9   8 0.4953032 0.13764186 0.4231275 0.5768725         3 #> 10  9 0.6049647 0.07940180 0.4892807 0.5107193         3 #> 11 10 0.7389056 0.04055203 0.5598781 0.4401219         3 #> 12 11 0.9025013 0.01784784 0.6330059 0.3669941         3 ggplot(lt1, aes(x = x, y = fecundity)) +   geom_line() +   ggtitle(\"Step fecundity, maturity at age 3\")"},{"path":"https://jonesor.github.io/mpmsim/articles/generating_leslie_models.html","id":"from-life-table-to-mpm","dir":"Articles","previous_headings":"","what":"3. From life table to MPM","title":"Generating Leslie models","text":"Users can now turn life tables, containing age-specific survival reproductive trajectories, Leslie matrices using make_leslie_mpm function. MPMs can large small depending maximum life span population: mentioned , population modelled less 1% cohort remains alive.","code":"make_leslie_mpm(lifetable = lt1) #>           [,1]      [,2]      [,3]      [,4]      [,5]      [,6]      [,7] #>  [1,] 0.000000 0.0000000 0.0000000 3.0000000 3.0000000 3.0000000 3.0000000 #>  [2,] 0.894876 0.0000000 0.0000000 0.0000000 0.0000000 0.0000000 0.0000000 #>  [3,] 0.000000 0.8731383 0.0000000 0.0000000 0.0000000 0.0000000 0.0000000 #>  [4,] 0.000000 0.0000000 0.8473028 0.0000000 0.0000000 0.0000000 0.0000000 #>  [5,] 0.000000 0.0000000 0.0000000 0.8167821 0.0000000 0.0000000 0.0000000 #>  [6,] 0.000000 0.0000000 0.0000000 0.0000000 0.7809914 0.0000000 0.0000000 #>  [7,] 0.000000 0.0000000 0.0000000 0.0000000 0.0000000 0.7393973 0.0000000 #>  [8,] 0.000000 0.0000000 0.0000000 0.0000000 0.0000000 0.0000000 0.6915873 #>  [9,] 0.000000 0.0000000 0.0000000 0.0000000 0.0000000 0.0000000 0.0000000 #> [10,] 0.000000 0.0000000 0.0000000 0.0000000 0.0000000 0.0000000 0.0000000 #> [11,] 0.000000 0.0000000 0.0000000 0.0000000 0.0000000 0.0000000 0.0000000 #> [12,] 0.000000 0.0000000 0.0000000 0.0000000 0.0000000 0.0000000 0.0000000 #>            [,8]      [,9]     [,10]     [,11]     [,12] #>  [1,] 3.0000000 3.0000000 3.0000000 3.0000000 3.0000000 #>  [2,] 0.0000000 0.0000000 0.0000000 0.0000000 0.0000000 #>  [3,] 0.0000000 0.0000000 0.0000000 0.0000000 0.0000000 #>  [4,] 0.0000000 0.0000000 0.0000000 0.0000000 0.0000000 #>  [5,] 0.0000000 0.0000000 0.0000000 0.0000000 0.0000000 #>  [6,] 0.0000000 0.0000000 0.0000000 0.0000000 0.0000000 #>  [7,] 0.0000000 0.0000000 0.0000000 0.0000000 0.0000000 #>  [8,] 0.0000000 0.0000000 0.0000000 0.0000000 0.0000000 #>  [9,] 0.6373657 0.0000000 0.0000000 0.0000000 0.0000000 #> [10,] 0.0000000 0.5768725 0.0000000 0.0000000 0.0000000 #> [11,] 0.0000000 0.0000000 0.5107193 0.0000000 0.0000000 #> [12,] 0.0000000 0.0000000 0.0000000 0.4401219 0.3669941"},{"path":"https://jonesor.github.io/mpmsim/articles/generating_leslie_models.html","id":"producing-sets-of-mpms-based-on-defined-model-characteristics","dir":"Articles","previous_headings":"","what":"4. Producing sets of MPMs based on defined model characteristics","title":"Generating Leslie models","text":"sometimes desirable create large numbers MPMs particular properties order test hypotheses. Leslie MPMs, can implemented straightforward way using function rand_leslie_set. function generates set Leslie MPMs based defined mortality fecundity models, using model parameters randomly drawn specified distributions. example, users may wish generate MPMs Gompertz models explore rate senescence influences population dynamics. Users must first set data frame describing distribution parameters drawn random. data frame number rows equal number parameters model, two values describe distribution. case uniform distribution, minimum maximum parameter values, respectively normal distribution represent mean standard deviation. parameters entered order appear model equations (see ?model_mortality), exact order depending chosen mortality model. Gompertz-Makeham model: hx=b0eb1x+ch_x = b_0 \\mathrm{e}^{b_1  x} + c output argument defines output one six types (Type1 Type6). outputs include CompadreDB objects list objects, MPMs can split component submatrices (U F, MPM, = U + F). special case Type6 outputs provided list life tables rather MPMs. output set CompadreDB object, mortality fecundity model parameters used generate MPM included metadata. following example illustrates production 50 Leslie MPMs output CompadreDB object based Gompertz-Makeham mortality model step fecundity model maturity beginning age 0. optional argument, scale_output = TRUE scale fecundity output MPMs ensure population growth rate lambda. scaling algorithm multiplies fecundity part MPM (F submatrix) simple scaling factor ensure population growth rate 1 maintaining shape (magnitude) fecundity trajectory. used care: desirability manipulation strongly depends use MPMs put . function operates quite fast. example, older MacBook (3.10GHz Intel 4 cores), takes 17 seconds generate 5000 MPMs parameters mentioned . aid assessing simulation, users can produce simple summary MPMs using summarise_mpms function. Note, though, works CompadreDB outputs. case, working Leslie MPMs, dimension MPMs indicative maximum age reached individuals population. producing output CompadreDB object, matrices can accessed using functions RCompadre R package. example, get matrix, U/F submatrices users can use matA, matU matF functions. following code illustrates rapidly calculate population growth rate matrices. Users can examine vignettes Rcompadre Rage packages additional insight potential operations compadreDB object.","code":"mortParams <- data.frame(   minVal = c(0, 0.01, 0.1),   maxVal = c(0.05, 0.15, 0.2) )  fecundityParams <- data.frame(   minVal = 2,   maxVal = 10 )  maturityParam <- c(0, 0)  (myMatrices <- rand_leslie_set(   n_models = 50,   mortality_model = \"GompertzMakeham\",   fecundity_model = \"step\",   mortality_params = mortParams,   fecundity_params = fecundityParams,   fecundity_maturity_params = maturityParam,   dist_type = \"uniform\",   output = \"Type1\" )) #> A COM(P)ADRE database ('CompadreDB') object with ?? SPECIES and 50 MATRICES. #>  #> # A tibble: 50 × 8 #>    mat        mortality_model      b_0    b_1     C fecundity_model     A #>    <list>     <chr>              <dbl>  <dbl> <dbl> <chr>           <dbl> #>  1 <CompdrMt> gompertzmakeham 0.0457   0.141  0.129 step             8.64 #>  2 <CompdrMt> gompertzmakeham 0.0321   0.0827 0.174 step             3.08 #>  3 <CompdrMt> gompertzmakeham 0.0328   0.109  0.146 step             7.75 #>  4 <CompdrMt> gompertzmakeham 0.0467   0.0458 0.146 step             9.52 #>  5 <CompdrMt> gompertzmakeham 0.0489   0.0264 0.147 step             6.48 #>  6 <CompdrMt> gompertzmakeham 0.0452   0.0294 0.199 step             9.57 #>  7 <CompdrMt> gompertzmakeham 0.00412  0.0820 0.139 step             9.25 #>  8 <CompdrMt> gompertzmakeham 0.0223   0.127  0.174 step             8.49 #>  9 <CompdrMt> gompertzmakeham 0.0194   0.106  0.100 step             8.66 #> 10 <CompdrMt> gompertzmakeham 0.000367 0.0391 0.191 step             6.89 #> # ℹ 40 more rows #> # ℹ 1 more variable: fecundity_scaling <dbl> summarise_mpms(myMatrices) #> Summary of matrix dimension: #>    Min. 1st Qu.  Median    Mean 3rd Qu.    Max.  #>   15.00   18.25   22.00   22.98   26.00   39.00  #> Summary of lambda values: #>    Min. 1st Qu.  Median    Mean 3rd Qu.    Max.  #>   2.845   6.010   7.970   7.557   9.150  10.672  #>  #> Summary of maximum F values: #>    Min. 1st Qu.  Median    Mean 3rd Qu.    Max.  #>   2.002   5.157   7.142   6.720   8.327   9.788  #>  #> Summary of maximum U values: #>    Min. 1st Qu.  Median    Mean 3rd Qu.    Max.  #>  0.7829  0.8159  0.8347  0.8365  0.8545  0.8925  #>  #> Summary of minimum non-zero U values: #>    Min. 1st Qu.  Median    Mean 3rd Qu.    Max.  #>  0.5715  0.6881  0.7650  0.7514  0.8160  0.8814 # Obtain the matrices x <- matA(myMatrices)  # Calculate lambda for each matrix sapply(x, popdemo::eigs, what = \"lambda\") #>  [1]  9.480062  3.889616  8.587381 10.343567  7.303660 10.356146 10.112353 #>  [8]  9.308862  9.549256  7.720332 10.672096  7.928430  5.604869  8.872518 #> [15]  6.966830  7.339943  9.468459  3.993036  8.631979  2.871674  8.012464 #> [22]  3.567593  2.844529  8.688251  7.778629  5.968972  8.664013  9.523154 #> [29]  7.123514  9.482587  7.556071 10.495633  7.644149  7.441366  7.792883 #> [36]  9.092281 10.412818  5.422186  9.018497  8.325535  4.386485  5.377892 #> [43]  6.131147  3.940014  8.952296  4.907484  9.138780  9.154187  3.317446 #> [50]  8.668165"},{"path":"https://jonesor.github.io/mpmsim/articles/generating_leslie_models.html","id":"conclusion","dir":"Articles","previous_headings":"","what":"Conclusion","title":"Generating Leslie models","text":"vignette demonstrated generate Leslie matrices using functional forms mortality fecundity, allowing users simulate virtual species varied life histories. matrices can used explore life history parameter differences affect population dynamics, supporting various research educational applications.","code":""},{"path":"https://jonesor.github.io/mpmsim/articles/sampling_error_propagation.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"Sampling error and its propagation","text":"Uncertainty individual elements matrix population model (MPM) can propagate, affecting accuracy metrics derived model, population growth rate, generation time, etc. One approach estimate uncertainty parametric bootstrapping, resampling method explicitly assumes statistical distributions matrix elements generates range possible matrices based assumptions. example, reproductive output can modelled Poisson-distributed process, suitable count-based data, survival can represented binomial distribution, reflecting probability individual survival. assumptions allow realistic variability parameter estimates compared nonparametric methods. Note approach assume initial matrices represent “true” parameters; rather, treats estimates associated uncertainty. parametric bootstrap used precisely quantify uncertainty resampling based estimated parameters. compute_ci function uses parametric bootstrapping estimate 95% confidence interval (95% CI) MPM-derived metric. Specifically, repeatedly samples matrix elements assumed distributions, generating sampling distribution metric interest. 95% CI calculated 2.5th 97.5th percentiles distribution, providing empirical range quantifies uncertainty. width shape sampling distribution—consequently, confidence intervals—influenced several factors, including sample size used estimating matrix elements, matrix model’s structure, assumptions underlying compute_ci function, distribution uncertainties across matrix elements. narrower confidence interval indicates greater precision, precision depends quality underlying assumptions. accurately assess reliability MPM estimates, necessary carefully consider factors interpreting results. following examples show use functions.","code":""},{"path":"https://jonesor.github.io/mpmsim/articles/sampling_error_propagation.html","id":"aims","dir":"Articles","previous_headings":"","what":"Aims","title":"Sampling error and its propagation","text":"purpose vignette illustrate use mpmsim assess estimate sampling error MPMs uncertainty propagates derived metrics. approach useful several reasons, including: Estimating confidence intervals (CIs) key demographic metrics, population growth rate using parametric bootstrapping methods. Exploring impact sample size precision estimates population growth rate metrics derived MPMs. Evaluating propagation uncertainty across different matrix elements submatrices (survival/growth vs. reproduction) MPMs.","code":""},{"path":"https://jonesor.github.io/mpmsim/articles/sampling_error_propagation.html","id":"estimate-95-confidence-intervals","dir":"Articles","previous_headings":"","what":"Estimate 95% Confidence Intervals","title":"Sampling error and its propagation","text":"can estimate 95% CI metric derived matrix population model. example, focus population growth rate, λ\\lambda. Consider matrix model , composed submatrices U (survival/growth) F (sexual reproduction), = U + F. methods require matrix model split component submatrices underlying processes governed distributions different statistical properties: individual survival treated binary process (0 = dies, 1 = survives), whereas individual reproduction follows Poisson distribution. example, matrix simple, top-right element representing reproduction, elements represent survival growth. method assumes matrices represent true values, wish calculate confidence intervals. 𝐀=[0.15.00.20.4] \\mathbf{} = \\begin{bmatrix} 0.1 & 5.0 \\\\ 0.2 & 0.4 \\ \\end{bmatrix} 𝐔=[0.10.00.20.4] \\mathbf{U} = \\begin{bmatrix} 0.1 & 0.0 \\\\ 0.2 & 0.4 \\ \\end{bmatrix} 𝐅=[0.05.00.00.0] \\mathbf{F} = \\begin{bmatrix} 0.0 & 5.0 \\\\ 0.0 & 0.0 \\ \\end{bmatrix} can enter matrices R follows, first entering U F matrices, summing get matrix. estimated population growth rate (λ\\lambda) can calculated using eigs function popdemo package like : can now estimate 95% CI estimate, based knowledge sample size(s) used parameterise MPM. sample size used estimate element matrix 20 individuals, can estimate 95% CI λ\\lambda using compute_ci function. function requires several arguments: mat_U mat_F represent survival/growth matrix reproductive output matrix respectively, sample_size specifies number individuals used estimate element (case, 20). argument FUN defines function applied resulting matrix calculate desired metric. can examine sampling distribution λ\\lambda estimates using argument dist.= TRUE.","code":"matU <- matrix(c(   0.1, 0.0,   0.2, 0.4 ), byrow = TRUE, nrow = 2)  matF <- matrix(c(   0.0, 5.0,   0.0, 0.0 ), byrow = TRUE, nrow = 2)  matA <- matU + matF popdemo::eigs(matA, what = \"lambda\") #> [1] 1.261187 compute_ci(   mat_U = matU, mat_F = matF, sample_size = 20,   FUN = popdemo::eigs, what = \"lambda\" ) #>      2.5%     97.5%  #> 0.7097788 1.7020301 distLambda_20 <- compute_ci(   mat_U = matU, mat_F = matF,   sample_size = 20, FUN = popdemo::eigs, what = \"lambda\",   dist.out = TRUE ) hist(distLambda_20$estimates)"},{"path":"https://jonesor.github.io/mpmsim/articles/sampling_error_propagation.html","id":"sample-sizes-that-vary-across-the-mpm","dir":"Articles","previous_headings":"","what":"Sample sizes that vary across the MPM","title":"Sampling error and its propagation","text":"example, assumed sample size used make parameter estimates (.e. element matrix model) throughout model. However, sample size might vary across different parts matrix submatrices due variations data availability biological processes. example, data survival growth (represented U matrix) might abundant processes can often tracked easily field studies. contrast, reproductive output data (represented F matrix) may harder collect, especially species complex reproductive cycles, leading smaller sample sizes. Additionally, environmental factors study limitations can result unequal sampling efforts across different life stages, contributing varying sample sizes matrix elements. account , compute_ci function allows flexibility specifying sample size, can added several ways control variability modelled across different parts matrix. alternative providing single value apply uniformly elements (done ) can provide matrix specifying sample sizes element, list matrices distinct components (e.g., U F matrices). flexibility helps tailor modelling uncertainty reflect different data availability across biological processes. instance, following code, use MPM , split U F submatrices (matU matF, respectively), now assume sample size varies components, 40 individuals U 15 F. , sample size consistent across elements within U matrix, also assign different sample sizes individual elements matrix, allowing different sample sizes different transitions.","code":"# Define the sample sizes for U mat_U_ss <- matrix(c(   40, 40,   40, 40 ), byrow = TRUE, nrow = 2)  # Define sample sizes for F mat_F_ss <- matrix(c(   0.0, 15,   0.0, 0.0 ), byrow = TRUE, nrow = 2)  # Combine sample sizes into list sampleSizes <- list(mat_U_ss = mat_U_ss, mat_F_ss = mat_F_ss)  # Calculate CI for lambda compute_ci(   mat_U = matU, mat_F = matF, sample_size = sampleSizes,   FUN = popdemo::eigs, what = \"lambda\" ) #>     2.5%    97.5%  #> 0.895995 1.579860"},{"path":"https://jonesor.github.io/mpmsim/articles/sampling_error_propagation.html","id":"exploring-the-impact-of-sample-size","dir":"Articles","previous_headings":"","what":"Exploring the impact of sample size","title":"Sampling error and its propagation","text":"Sample size critical determining precision statistical estimates. demographic studies, small sample sizes can lead high uncertainty estimates derived measures like λ\\lambda, making difficult make strong inferences. Larger sample sizes reduce uncertainty, seen narrower confidence intervals around λ\\lambda increase sample size 20 (calculated ) 100 ().  approach can used perform form power analysis simulation, technique determining sample size required detect effect specified statistical power significance level. instance, one might ask, ’sample size needed confidently conclude population growth rate 1.0? following code creates plot visualize precision λ\\lambda estimates improves sample size increases. first defines set sample sizes iterate , uses compute_ci calculate confidence intervals (CIs) λ\\lambda estimated MPMs based sample sizes. plots λ\\lambda estimates CIs, along reference line λ=1\\lambda = 1. goal show sample size increases, width CIs shrinks, increasing confidence value λ\\lambda. case, sample size approximately 70 appears sufficient. However, sample size likely greater importance elastic elements MPM. Therefore, focusing elements help users better understand specific sample size requirements system. targeted approach lead nuanced study design, allowing optimized sampling efforts areas precision matters .","code":"distLambda_100 <- compute_ci(   mat_U = matU, mat_F = matF,   sample_size = 100, FUN = popdemo::eigs, what = \"lambda\",   dist.out = TRUE )  par(mfrow = c(2, 1)) hist(distLambda_20$estimates, xlim = c(0, 1.75)) hist(distLambda_100$estimates, xlim = c(0, 1.75)) # Define sample sizes to iterate over sample_sizes <- seq(10, 100, 10)  # Lambda value for reference matA <- matF + matU true_lambda <- popdemo::eigs(matA, what = \"lambda\")  # Initialize an empty data frame with predefined columns ci_results <- data.frame(   sample_size = sample_sizes,   ci_lower = numeric(length(sample_sizes)),   ci_upper = numeric(length(sample_sizes)),   estimate_mean = numeric(length(sample_sizes)) )  # Loop through each sample size and calculate the CI for lambda for (i in seq_along(sample_sizes)) {   n <- sample_sizes[i]    # Compute CI for the current sample size   dist_lambda <- compute_ci(     mat_U = matU, mat_F = matF,     sample_size = n, FUN = popdemo::eigs, what = \"lambda\",     dist.out = TRUE   )    # Calculate 95% CI from the distribution   ci_results$ci_lower[i] <- quantile(dist_lambda$estimates, 0.025)   ci_results$ci_upper[i] <- quantile(dist_lambda$estimates, 0.975)   ci_results$estimate_mean[i] <- mean(dist_lambda$estimates) }  # Calculate error bars ci_lower_error <- ci_results$estimate_mean - ci_results$ci_lower ci_upper_error <- ci_results$ci_upper - ci_results$estimate_mean  # Create the plot plot(ci_results$sample_size, ci_results$estimate_mean,   ylim = range(ci_results$ci_lower, ci_results$ci_upper),   pch = 19, xlab = \"Sample Size\", ylab = \"Lambda Estimate\",   main = \"Effect of Sample Size on Lambda Estimate Precision\" )  # Add error bars and reference line arrows(ci_results$sample_size, ci_results$ci_lower,   ci_results$sample_size, ci_results$ci_upper,   angle = 90, code = 3, length = 0.05, col = \"blue\" ) abline(h = 1, lty = 2)"},{"path":"https://jonesor.github.io/mpmsim/articles/sampling_error_propagation.html","id":"conclusion","dir":"Articles","previous_headings":"","what":"Conclusion","title":"Sampling error and its propagation","text":"vignette demonstrates sampling error propagates MPMs, influencing metrics like population growth rate, provides practical method estimating confidence intervals metrics using compute_ci. applying tools like compute_ci, users can also evaluate effect sample size estimate precision, using information optimize data collection efforts improve reliability demographic estimates.","code":""},{"path":"https://jonesor.github.io/mpmsim/articles/sampling_error_propagation.html","id":"addendum","dir":"Articles","previous_headings":"","what":"Addendum","title":"Sampling error and its propagation","text":"compute_ci function intended metrics rely full matrix. However, metrics, like life_expect_mean Rage package, require U matrix. metrics , users use compute_ci_U function, works similarly compute_ci, specifically designed metrics focus solely survival growth processes within U matrix.","code":""},{"path":"https://jonesor.github.io/mpmsim/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Owen Jones. Author, maintainer.","code":""},{"path":"https://jonesor.github.io/mpmsim/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Jones O (2025). mpmsim: Simulation Matrix Population Models Defined Life History Characteristics. R package version 3.1.0.9000, https://github.com/jonesor/mpmsim.","code":"@Manual{,   title = {mpmsim: Simulation of Matrix Population Models with Defined Life History Characteristics},   author = {Owen Jones},   year = {2025},   note = {R package version 3.1.0.9000},   url = {https://github.com/jonesor/mpmsim}, }"},{"path":"https://jonesor.github.io/mpmsim/index.html","id":"mpmsim-","dir":"","previous_headings":"","what":"Simulation of Matrix Population Models with Defined Life History Characteristics","title":"Simulation of Matrix Population Models with Defined Life History Characteristics","text":"mpmsim contains tools generating random semi-random matrix population models (MPMs) given particular life history archetype. also facilitates generation Leslie matrices, simulation MPMs based expected transition rates sample sizes. can useful exploring uncertainty inferences sample sizes small (unknown).","code":""},{"path":"https://jonesor.github.io/mpmsim/index.html","id":"installation","dir":"","previous_headings":"","what":"Installation","title":"Simulation of Matrix Population Models with Defined Life History Characteristics","text":"can install latest stable version mpmsim CRAN like :","code":"install.packages(\"mpmsim\")"},{"path":"https://jonesor.github.io/mpmsim/index.html","id":"development-versions","dir":"","previous_headings":"Installation","what":"Development version(s)","title":"Simulation of Matrix Population Models with Defined Life History Characteristics","text":"package developed () GitHub. can install latest development version mpmsim like : development may versions, additional functionality, available different GitHub “branches”. install one branches, use following syntax:","code":"# install package 'remotes' if necessary # will already be installed if 'devtools' is installed install.packages(\"remotes\")  # argument 'build_opts = NULL' only needed if you want to build vignettes remotes::install_github(\"jonesor/mpmsim\", build_opts = NULL) # install from the 'dev' branch remotes::install_github(\"jonesor/mpmsim\", ref = \"dev\")"},{"path":"https://jonesor.github.io/mpmsim/index.html","id":"usage","dir":"","previous_headings":"","what":"Usage","title":"Simulation of Matrix Population Models with Defined Life History Characteristics","text":"First, load package.","code":"library(mpmsim)"},{"path":"https://jonesor.github.io/mpmsim/index.html","id":"generate-a-leslie-matrix","dir":"","previous_headings":"Usage","what":"Generate a Leslie matrix","title":"Simulation of Matrix Population Models with Defined Life History Characteristics","text":"make_leslie_mpm function can used generate Leslie matrix model (Leslie, 1945) stages represent discrete age classes (usually years life). Leslie matrix, survival represented lower sub-diagonal lower-right-hand corner element, fecundity (reproduction) shown top row. survival fecundity length equal number stages model. Users can specify survival fecundity either single value vector values, length equal dimensions matrix model. arguments single values, value repeated along survival/fecundity sequence.","code":"make_leslie_mpm(   survival = seq(0.1, 0.45, length.out = 4),   fecundity = c(0, 0, 2.4, 5), n_stages = 4, split = FALSE ) #>      [,1]      [,2]      [,3] [,4] #> [1,]  0.0 0.0000000 2.4000000 5.00 #> [2,]  0.1 0.0000000 0.0000000 0.00 #> [3,]  0.0 0.2166667 0.0000000 0.00 #> [4,]  0.0 0.0000000 0.3333333 0.45"},{"path":"https://jonesor.github.io/mpmsim/index.html","id":"using-functional-forms-for-mortality-and-fecundity","dir":"","previous_headings":"Usage","what":"Using functional forms for mortality and fecundity","title":"Simulation of Matrix Population Models with Defined Life History Characteristics","text":"Users can generate Leslie matrices particular functional forms mortality first making data frame simplified life table includes age survival probability within age interval. model_mortality function can handle following models: Gompertz, Gompertz-Makeham, Weibull, Weibull-Makeham, Siler Exponential. function returns standard life table data.frame including columns age (x), age-specific hazard (hx), survivorship (lx), age-specific probability death survival (qx px). default, life table truncated age survivorship function declines 0.01 (.e. 1% individuals cohort remain alive). example produce life table based Gompertz mortality: Users can also use functional form fecundity (see ?model_fecundity), including, logistic, step, von Bertalanffy, Normal Hadwiger. simple step function assumed. Subsequently, survival fecundity values can applied Leslie matrix follows.","code":"(surv_prob <- model_mortality(params = c(0.2, 0.4), model = \"Gompertz\")) #>   x        hx         lx        qx        px #> 1 0 0.2000000 1.00000000 0.2205623 0.7794377 #> 2 1 0.2983649 0.77943774 0.3104641 0.6895359 #> 3 2 0.4451082 0.53745028 0.4256784 0.5743216 #> 4 3 0.6640234 0.30866930 0.5627783 0.4372217 #> 5 4 0.9906065 0.13495691 0.7089351 0.2910649 #> 6 5 1.4778112 0.03928123 0.8413767 0.1586233 survival <- surv_prob$px fecundity <- model_fecundity(   age = 0:(length(survival) - 1),   params = c(A = 5), maturity = 2, model = \"step\" ) make_leslie_mpm(   survival = survival, fecundity = fecundity,   n_stages = length(survival), split = FALSE ) #>           [,1]      [,2]      [,3]      [,4]      [,5]      [,6] #> [1,] 0.0000000 0.0000000 5.0000000 5.0000000 5.0000000 5.0000000 #> [2,] 0.7794377 0.0000000 0.0000000 0.0000000 0.0000000 0.0000000 #> [3,] 0.0000000 0.6895359 0.0000000 0.0000000 0.0000000 0.0000000 #> [4,] 0.0000000 0.0000000 0.5743216 0.0000000 0.0000000 0.0000000 #> [5,] 0.0000000 0.0000000 0.0000000 0.4372217 0.0000000 0.0000000 #> [6,] 0.0000000 0.0000000 0.0000000 0.0000000 0.2910649 0.1586233"},{"path":"https://jonesor.github.io/mpmsim/index.html","id":"sets-of-leslie-matrices","dir":"","previous_headings":"Usage","what":"Sets of Leslie matrices","title":"Simulation of Matrix Population Models with Defined Life History Characteristics","text":"Users can generate large numbers plausible Leslie matrices using rand_leslie_set function. arguments function include number models (n_models), type mortality (e.g. GompertzMakeham) reproduction (e.g. step). specific parameters mortality reproduction provided defined distributions parameters can drawn random. type distribution defined dist_type argument can uniform normal, distributions defined using mortality_params fecundity_params arguments, accept data frames distribution parameters. example, following code produces list five Leslie matrices Gompertz-Makeham mortality characteristics reproduction step function. First, define limits uniform distributions Gompertz mortality step fecundity functions. also set maturity drawn distribution ranging 0 3. Now produce models. output “Type5” simple list main matrix model, outputs can also split submatrices (e.g. U F matrices), CompadreDB object.","code":"mortParams <- data.frame(   minVal = c(0.05, 0.08, 0.7),   maxVal = c(0.14, 0.15, 0.7) )  fecParams <- data.frame(minVal = 4, maxVal = 6) maturityParams <- c(0, 3) outputMPMs <- rand_leslie_set(   n_models = 5, mortality_model = \"GompertzMakeham\", fecundity_model = \"step\",   mortality_params = mortParams,   fecundity_params = fecParams,   fecundity_maturity_params = maturityParams,   dist_type = \"uniform\",   output = \"Type5\" )  outputMPMs #> [[1]] #>           [,1]      [,2]      [,3]      [,4]      [,5]      [,6] #> [1,] 0.0000000 0.0000000 0.0000000 4.5722791 4.5722791 4.5722791 #> [2,] 0.4305453 0.0000000 0.0000000 0.0000000 0.0000000 0.0000000 #> [3,] 0.0000000 0.4210229 0.0000000 0.0000000 0.0000000 0.0000000 #> [4,] 0.0000000 0.0000000 0.4102704 0.0000000 0.0000000 0.0000000 #> [5,] 0.0000000 0.0000000 0.0000000 0.3981747 0.0000000 0.0000000 #> [6,] 0.0000000 0.0000000 0.0000000 0.0000000 0.3846275 0.3695309 #>  #> [[2]] #>           [,1]      [,2]     [,3]      [,4]      [,5]      [,6] #> [1,] 0.0000000 5.4731766 5.473177 5.4731766 5.4731766 5.4731766 #> [2,] 0.4429031 0.0000000 0.000000 0.0000000 0.0000000 0.0000000 #> [3,] 0.0000000 0.4366956 0.000000 0.0000000 0.0000000 0.0000000 #> [4,] 0.0000000 0.0000000 0.429826 0.0000000 0.0000000 0.0000000 #> [5,] 0.0000000 0.0000000 0.000000 0.4222377 0.0000000 0.0000000 #> [6,] 0.0000000 0.0000000 0.000000 0.0000000 0.4138729 0.4046735 #>  #> [[3]] #>           [,1]     [,2]      [,3]      [,4]      [,5]      [,6] #> [1,] 0.0000000 0.000000 0.0000000 4.9154836 4.9154836 4.9154836 #> [2,] 0.4419032 0.000000 0.0000000 0.0000000 0.0000000 0.0000000 #> [3,] 0.0000000 0.434841 0.0000000 0.0000000 0.0000000 0.0000000 #> [4,] 0.0000000 0.000000 0.4269406 0.0000000 0.0000000 0.0000000 #> [5,] 0.0000000 0.000000 0.0000000 0.4181238 0.0000000 0.0000000 #> [6,] 0.0000000 0.000000 0.0000000 0.0000000 0.4083108 0.3974225 #>  #> [[4]] #>          [,1]      [,2]      [,3]      [,4]      [,5]      [,6] #> [1,] 0.000000 0.0000000 0.0000000 4.9245856 4.9245856 4.9245856 #> [2,] 0.431272 0.0000000 0.0000000 0.0000000 0.0000000 0.0000000 #> [3,] 0.000000 0.4250633 0.0000000 0.0000000 0.0000000 0.0000000 #> [4,] 0.000000 0.0000000 0.4183198 0.0000000 0.0000000 0.0000000 #> [5,] 0.000000 0.0000000 0.0000000 0.4110069 0.0000000 0.0000000 #> [6,] 0.000000 0.0000000 0.0000000 0.0000000 0.4030901 0.3945359 #>  #> [[5]] #>           [,1]      [,2]      [,3]      [,4]      [,5]      [,6] #> [1,] 0.0000000 0.0000000 4.9499942 4.9499942 4.9499942 4.9499942 #> [2,] 0.4298125 0.0000000 0.0000000 0.0000000 0.0000000 0.0000000 #> [3,] 0.0000000 0.4241257 0.0000000 0.0000000 0.0000000 0.0000000 #> [4,] 0.0000000 0.0000000 0.4180004 0.0000000 0.0000000 0.0000000 #> [5,] 0.0000000 0.0000000 0.0000000 0.4114112 0.0000000 0.0000000 #> [6,] 0.0000000 0.0000000 0.0000000 0.0000000 0.4043329 0.3967408"},{"path":"https://jonesor.github.io/mpmsim/index.html","id":"generate-single-random-lefkovitch-mpms","dir":"","previous_headings":"Usage","what":"Generate single random Lefkovitch MPMs","title":"Simulation of Matrix Population Models with Defined Life History Characteristics","text":"rand_lefko_mpm function can used generate random Lefkovitch matrix population model (MPM) (Lefkovitch, 1965), element values based defined life history archetypes. function draws survival transition/growth probabilities Dirichlet distribution ensure column totals, including death, less equal 1. Fecundity can specified single value vector length equal dimensions matrix. specified single value, placed top-right corner matrix. specified vector length n_stages, spans entire top row matrix. archetype argument can used constrain MPMs, example, archetype = 2 constraints survival probability increase monotonically individuals advance later stages. information, see documentation rand_lefko_mpm Takada et al. (2018), archetypes derived. following example, split output matrices U F submatrices, can summed create full matrix model.","code":"(rMPM <- rand_lefko_mpm(   n_stages = 3, fecundity = 20,   archetype = 2, split = TRUE )) #> $mat_A #>           [,1]       [,2]       [,3] #> [1,] 0.2070973 0.33155927 20.4132432 #> [2,] 0.3836494 0.52219726  0.3625132 #> [3,] 0.2615892 0.03314957  0.1157180 #>  #> $mat_U #>           [,1]       [,2]      [,3] #> [1,] 0.2070973 0.33155927 0.4132432 #> [2,] 0.3836494 0.52219726 0.3625132 #> [3,] 0.2615892 0.03314957 0.1157180 #>  #> $mat_F #>      [,1] [,2] [,3] #> [1,]    0    0   20 #> [2,]    0    0    0 #> [3,]    0    0    0"},{"path":"https://jonesor.github.io/mpmsim/index.html","id":"generate-a-set-of-random-lefkovitch-mpms","dir":"","previous_headings":"Usage","what":"Generate a set of random Lefkovitch MPMs","title":"Simulation of Matrix Population Models with Defined Life History Characteristics","text":"rand_lefko_set function can used quickly generate large numbers Lefkovitch MPMs using approach. example, following code generates five MPMs archetype 1. using constraint argument, users can specify acceptable characteristics set matrices. case, population growth rate range, can useful life history analyses might assume life histories lambda values close 1 can persist nature. set argument output = \"Type5\" ensure function returns list object.","code":"library(popbio) constrain_df <- data.frame(fun = \"lambda\", arg = NA, lower = 0.9, upper = 1.1) rand_lefko_set(   n_models = 5, n_stages = 4, fecundity = 8, archetype = 1, constraint = constrain_df,   output = \"Type5\" ) #> [[1]] #>            [,1]       [,2]       [,3]       [,4] #> [1,] 0.28730926 0.02716436 0.26331722 8.46373314 #> [2,] 0.14460260 0.15628773 0.23535192 0.02222792 #> [3,] 0.10395162 0.24279393 0.10570287 0.17071769 #> [4,] 0.03134086 0.27716832 0.01175425 0.07549711 #>  #> [[2]] #>            [,1]       [,2]        [,3]      [,4] #> [1,] 0.14077752 0.04357884 0.429128096 8.0837046 #> [2,] 0.09905905 0.52812214 0.007308617 0.2701657 #> [3,] 0.36955076 0.11374572 0.109339485 0.2160414 #> [4,] 0.01698186 0.01869725 0.143428706 0.1214954 #>  #> [[3]] #>             [,1]       [,2]       [,3]      [,4] #> [1,] 0.160744755 0.02845733 0.03688629 8.1365669 #> [2,] 0.041433197 0.24550232 0.01277293 0.1219770 #> [3,] 0.791265908 0.02813589 0.25420572 0.2599794 #> [4,] 0.002908193 0.21314599 0.04493534 0.3332529 #>  #> [[4]] #>             [,1]       [,2]       [,3]       [,4] #> [1,] 0.196022839 0.39576976 0.27489845 8.24843871 #> [2,] 0.350613432 0.10892595 0.28872665 0.05133337 #> [3,] 0.084225194 0.23979127 0.19811975 0.41727119 #> [4,] 0.009066956 0.06365681 0.09946455 0.11853471 #>  #> [[5]] #>            [,1]       [,2]       [,3]       [,4] #> [1,] 0.04407168 0.09512729 0.03927867 8.00717018 #> [2,] 0.07098214 0.28541167 0.23663234 0.49786947 #> [3,] 0.36675467 0.46916408 0.06540892 0.13898581 #> [4,] 0.05606256 0.11920243 0.03335758 0.08196272"},{"path":"https://jonesor.github.io/mpmsim/index.html","id":"calculate-confidence-intervals-for-derived-estimates","dir":"","previous_headings":"Usage","what":"Calculate confidence intervals for derived estimates","title":"Simulation of Matrix Population Models with Defined Life History Characteristics","text":"Sometimes, users may find confronted MPM can calculate various metrics, need calculate confidence interval metrics. compute_ci function designed address need computing 95% confidence intervals (CIs) measures derived complete MPM (.e. matrix). accomplished using parametric bootstrapping, generating sampling distribution MPM performing numerous random independent draws using sampling distribution underlying transition rate. approach relies (1) known (estimated) sample size estimate model (2) assumption survival-related processes binomial, reproduction processes follow Poisson distribution. ’s example, use Lefkovitch model , believe sample size 10 individuals parameter estimate. point estimate population growth rate (lambda) 2.539. Users can calculate 95% CI, assuming sample size 10, like : sample_size argument can handle various cases, example, sample size varies across matrix, U F submatrices (see ?compute_ci). equivalent function, compute_ci_U designed use derived estimate requires U submatrix (opposed submatrices matrix).","code":"library(popdemo) eigs(rMPM$mat_A, what = \"lambda\") #> [1] 2.539016 compute_ci(   mat_U = rMPM$mat_U, mat_F = rMPM$mat_F,   sample_size = 10,   FUN = eigs, what = \"lambda\" ) #>      2.5%     97.5%  #> 0.8384508 3.4177693"},{"path":"https://jonesor.github.io/mpmsim/index.html","id":"simulate-sampling-error-for-an-mpm","dir":"","previous_headings":"Usage","what":"Simulate sampling error for an MPM","title":"Simulation of Matrix Population Models with Defined Life History Characteristics","text":"function add_mpm_error can used simulate MPM sampling error, based expected transition rates (survival fecundity) sample sizes. useful initial phases study, part power analysis, used simply get feel expected variation different circumstances. expected transition rates must provided matrices. sample size(s) can given either matrix sample sizes element matrix single value applied elements matrix. function uses binomial process simulate survival/growth elements Poisson process simulate fecundity elements. result, sample sizes large, simulated MPM closely reflect expected transition rates. contrast, sample sizes small, simulated matrices become variable. illustrate use function, following code first generates 3-stage Leslie matrix using make_leslie_mpm function. passes U F matrices Leslie matrix add_mpm_error function. , two matrices simulated, first sample size 1000, sample size seven. list arbitrary number matrices can generated easily using replicate, follows. coerced CompadreDB object, necessary, using cdb_build_cdb function Rcompadre package.","code":"mats <- make_leslie_mpm(   survival = c(0.3, 0.5, 0.8),   fecundity = c(0, 2.2, 4.4),   n_stages = 3, split = TRUE )  add_mpm_error(   mat_U = mats$mat_U, mat_F = mats$mat_F,   sample_size = 1000, split = FALSE, by_type = FALSE ) #>       [,1]  [,2]  [,3] #> [1,] 0.000 2.220 4.316 #> [2,] 0.293 0.000 0.000 #> [3,] 0.000 0.485 0.816  add_mpm_error(   mat_U = mats$mat_U, mat_F = mats$mat_F,   sample_size = 7, split = FALSE, by_type = FALSE ) #>           [,1]      [,2]      [,3] #> [1,] 0.0000000 3.5714286 4.2857143 #> [2,] 0.1428571 0.0000000 0.0000000 #> [3,] 0.0000000 0.2857143 0.8571429 replicate(   n = 5,   add_mpm_error(     mat_U = mats$mat_U, mat_F = mats$mat_F,     sample_size = 7, split = FALSE, by_type = FALSE   ) ) #> , , 1 #>  #>           [,1]      [,2]      [,3] #> [1,] 0.0000000 1.5714286 4.7142857 #> [2,] 0.5714286 0.0000000 0.0000000 #> [3,] 0.0000000 0.2857143 0.8571429 #>  #> , , 2 #>  #>           [,1]      [,2]     [,3] #> [1,] 0.0000000 1.0000000 4.857143 #> [2,] 0.1428571 0.0000000 0.000000 #> [3,] 0.0000000 0.2857143 1.000000 #>  #> , , 3 #>  #>           [,1]      [,2]     [,3] #> [1,] 0.0000000 1.8571429 4.571429 #> [2,] 0.1428571 0.0000000 0.000000 #> [3,] 0.0000000 0.4285714 1.000000 #>  #> , , 4 #>  #>           [,1]      [,2]      [,3] #> [1,] 0.0000000 2.7142857 4.2857143 #> [2,] 0.4285714 0.0000000 0.0000000 #> [3,] 0.0000000 0.7142857 0.8571429 #>  #> , , 5 #>  #>           [,1]      [,2]      [,3] #> [1,] 0.0000000 2.0000000 4.4285714 #> [2,] 0.2857143 0.0000000 0.0000000 #> [3,] 0.0000000 0.8571429 0.7142857"},{"path":"https://jonesor.github.io/mpmsim/index.html","id":"plot-a-matrix","dir":"","previous_headings":"Usage","what":"Plot a matrix","title":"Simulation of Matrix Population Models with Defined Life History Characteristics","text":"can helpful visualise matrices. can accomplished function plot_matrix. output plot_matrix class ggplot colour scheme can modified usual way , example, scale_fill_gradient similar. ’s matrix: ’s plot:","code":"rMPM$mat_U #>           [,1]       [,2]      [,3] #> [1,] 0.2070973 0.33155927 0.4132432 #> [2,] 0.3836494 0.52219726 0.3625132 #> [3,] 0.2615892 0.03314957 0.1157180 p <- plot_matrix(rMPM$mat_U) p + ggplot2::scale_fill_gradient(low = \"black\", high = \"yellow\")"},{"path":"https://jonesor.github.io/mpmsim/index.html","id":"references","dir":"","previous_headings":"","what":"References","title":"Simulation of Matrix Population Models with Defined Life History Characteristics","text":"Lefkovitch, L. P. (1965). study population growth organisms grouped stages. Biometrics, 21(1), 1. Leslie, P. H. (1945). use matrices certain population mathematics. Biometrika, 33 (3), 183–212. Takada, T., Kawai, Y., & Salguero-Gómez, R. (2018). cautionary note elasticity analyses ternary plot using randomly generated population matrices. Population Ecology, 60(1), 37–47.","code":""},{"path":"https://jonesor.github.io/mpmsim/index.html","id":"contributions","dir":"","previous_headings":"","what":"Contributions","title":"Simulation of Matrix Population Models with Defined Life History Characteristics","text":"contributions welcome. Please note project released Contributor Code Conduct. participating project agree abide terms. numerous ways contributing. can submit bug reports, suggestions etc. opening issue. can copy fork repository, make code edits send us pull request. ’s . also welcome email .","code":""},{"path":"https://jonesor.github.io/mpmsim/reference/add_mpm_error.html","id":null,"dir":"Reference","previous_headings":"","what":"Add sampling error to matrix population models (MPMs) based on expected values of transition rates and sample sizes — add_mpm_error","title":"Add sampling error to matrix population models (MPMs) based on expected values of transition rates and sample sizes — add_mpm_error","text":"Produces list matrix population models based expected values transition matrix sample size. expected values provided lists two submatrices: mat_U growth/development survival transitions mat_F reproductive transitions. output mat_U values simulated based expected probabilities, assuming binomial process sample size defined sample_size. output mat_F values simulated using Poisson process sample size defined sample_size.Thus users can expect large sample sizes result simulated matrices match closely expectations, simulated matrices small sample sizes variable.","code":""},{"path":"https://jonesor.github.io/mpmsim/reference/add_mpm_error.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Add sampling error to matrix population models (MPMs) based on expected values of transition rates and sample sizes — add_mpm_error","text":"","code":"add_mpm_error(mat_U, mat_F, sample_size, split = TRUE, by_type = TRUE)"},{"path":"https://jonesor.github.io/mpmsim/reference/add_mpm_error.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Add sampling error to matrix population models (MPMs) based on expected values of transition rates and sample sizes — add_mpm_error","text":"mat_U list U submatrices, single U submatrix. mat_F list F submatrices, single F submatrix. sample_size either (1) single matrix sample sizes element every MPM, (2) list two named matrices (\"mat_F_ss\", \"mat_U_ss\") containing sample sizes survival reproductive output submatrices every MPM (3) single value applied every element every matrix. split logical, whether split output survival reproductive output matrices . Defaults TRUE. by_type logical indicating whether matrices returned list type (, U, F, C). split FALSE, by_type must also FALSE. Defaults TRUE.","code":""},{"path":"https://jonesor.github.io/mpmsim/reference/add_mpm_error.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Add sampling error to matrix population models (MPMs) based on expected values of transition rates and sample sizes — add_mpm_error","text":"list matrices survival reproductive output split = TRUE, otherwise single matrix sum survival reproductive output.","code":""},{"path":"https://jonesor.github.io/mpmsim/reference/add_mpm_error.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Add sampling error to matrix population models (MPMs) based on expected values of transition rates and sample sizes — add_mpm_error","text":"sample_size input 0, assumed estimate element(s) concerned known without error.","code":""},{"path":[]},{"path":"https://jonesor.github.io/mpmsim/reference/add_mpm_error.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Add sampling error to matrix population models (MPMs) based on expected values of transition rates and sample sizes — add_mpm_error","text":"Owen Jones jones@biology.sdu.dk","code":""},{"path":"https://jonesor.github.io/mpmsim/reference/add_mpm_error.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Add sampling error to matrix population models (MPMs) based on expected values of transition rates and sample sizes — add_mpm_error","text":"","code":"set.seed(42) # set seed for repeatability  # First generate a set of MPMs mpm_set <- rand_lefko_set(n = 5, n_stages = 5, fecundity = c(   0, 0, 4, 8, 10 ), archetype = 4, output = \"Type4\")  # Now apply sampling error to this set add_mpm_error(   mat_U = mpm_set$U_list, mat_F = mpm_set$F_list, sample_size =     50 ) #> $A_list #> $A_list[[1]] #>      [,1] [,2] [,3] [,4] [,5] #> [1,] 0.04 0.00 4.16 7.36 9.92 #> [2,] 0.40 0.38 0.00 0.00 0.00 #> [3,] 0.00 0.00 0.20 0.00 0.00 #> [4,] 0.00 0.00 0.44 0.42 0.00 #> [5,] 0.00 0.00 0.00 0.32 0.94 #>  #> $A_list[[2]] #>      [,1] [,2] [,3] [,4]  [,5] #> [1,] 0.02 0.00 3.88 8.14 11.38 #> [2,] 0.32 0.38 0.00 0.00  0.00 #> [3,] 0.00 0.02 0.64 0.00  0.00 #> [4,] 0.00 0.00 0.04 0.38  0.00 #> [5,] 0.00 0.00 0.00 0.32  0.76 #>  #> $A_list[[3]] #>      [,1] [,2] [,3] [,4] [,5] #> [1,]  0.5 0.00 4.34 8.06 9.58 #> [2,]  0.0 0.56 0.00 0.00 0.00 #> [3,]  0.0 0.20 0.38 0.00 0.00 #> [4,]  0.0 0.00 0.38 0.20 0.00 #> [5,]  0.0 0.00 0.00 0.68 1.00 #>  #> $A_list[[4]] #>      [,1] [,2] [,3] [,4] [,5] #> [1,] 0.26 0.00 3.66 8.24 9.34 #> [2,] 0.00 0.00 0.00 0.00 0.00 #> [3,] 0.00 0.38 0.06 0.00 0.00 #> [4,] 0.00 0.00 0.36 0.14 0.00 #> [5,] 0.00 0.00 0.00 0.58 0.88 #>  #> $A_list[[5]] #>      [,1] [,2] [,3] [,4] [,5] #> [1,] 0.20 0.00 4.24 7.44 9.80 #> [2,] 0.26 0.46 0.00 0.00 0.00 #> [3,] 0.00 0.08 0.70 0.00 0.00 #> [4,] 0.00 0.00 0.04 0.10 0.00 #> [5,] 0.00 0.00 0.00 0.58 0.78 #>  #>  #> $U_list #> $U_list[[1]] #>      [,1] [,2] [,3] [,4] [,5] #> [1,] 0.04 0.00 0.00 0.00 0.00 #> [2,] 0.40 0.38 0.00 0.00 0.00 #> [3,] 0.00 0.00 0.20 0.00 0.00 #> [4,] 0.00 0.00 0.44 0.42 0.00 #> [5,] 0.00 0.00 0.00 0.32 0.94 #>  #> $U_list[[2]] #>      [,1] [,2] [,3] [,4] [,5] #> [1,] 0.02 0.00 0.00 0.00 0.00 #> [2,] 0.32 0.38 0.00 0.00 0.00 #> [3,] 0.00 0.02 0.64 0.00 0.00 #> [4,] 0.00 0.00 0.04 0.38 0.00 #> [5,] 0.00 0.00 0.00 0.32 0.76 #>  #> $U_list[[3]] #>      [,1] [,2] [,3] [,4] [,5] #> [1,]  0.5 0.00 0.00 0.00    0 #> [2,]  0.0 0.56 0.00 0.00    0 #> [3,]  0.0 0.20 0.38 0.00    0 #> [4,]  0.0 0.00 0.38 0.20    0 #> [5,]  0.0 0.00 0.00 0.68    1 #>  #> $U_list[[4]] #>      [,1] [,2] [,3] [,4] [,5] #> [1,] 0.26 0.00 0.00 0.00 0.00 #> [2,] 0.00 0.00 0.00 0.00 0.00 #> [3,] 0.00 0.38 0.06 0.00 0.00 #> [4,] 0.00 0.00 0.36 0.14 0.00 #> [5,] 0.00 0.00 0.00 0.58 0.88 #>  #> $U_list[[5]] #>      [,1] [,2] [,3] [,4] [,5] #> [1,] 0.20 0.00 0.00 0.00 0.00 #> [2,] 0.26 0.46 0.00 0.00 0.00 #> [3,] 0.00 0.08 0.70 0.00 0.00 #> [4,] 0.00 0.00 0.04 0.10 0.00 #> [5,] 0.00 0.00 0.00 0.58 0.78 #>  #>  #> $F_list #> $F_list[[1]] #>      [,1] [,2] [,3] [,4] [,5] #> [1,]    0    0 4.16 7.36 9.92 #> [2,]    0    0 0.00 0.00 0.00 #> [3,]    0    0 0.00 0.00 0.00 #> [4,]    0    0 0.00 0.00 0.00 #> [5,]    0    0 0.00 0.00 0.00 #>  #> $F_list[[2]] #>      [,1] [,2] [,3] [,4]  [,5] #> [1,]    0    0 3.88 8.14 11.38 #> [2,]    0    0 0.00 0.00  0.00 #> [3,]    0    0 0.00 0.00  0.00 #> [4,]    0    0 0.00 0.00  0.00 #> [5,]    0    0 0.00 0.00  0.00 #>  #> $F_list[[3]] #>      [,1] [,2] [,3] [,4] [,5] #> [1,]    0    0 4.34 8.06 9.58 #> [2,]    0    0 0.00 0.00 0.00 #> [3,]    0    0 0.00 0.00 0.00 #> [4,]    0    0 0.00 0.00 0.00 #> [5,]    0    0 0.00 0.00 0.00 #>  #> $F_list[[4]] #>      [,1] [,2] [,3] [,4] [,5] #> [1,]    0    0 3.66 8.24 9.34 #> [2,]    0    0 0.00 0.00 0.00 #> [3,]    0    0 0.00 0.00 0.00 #> [4,]    0    0 0.00 0.00 0.00 #> [5,]    0    0 0.00 0.00 0.00 #>  #> $F_list[[5]] #>      [,1] [,2] [,3] [,4] [,5] #> [1,]    0    0 4.24 7.44  9.8 #> [2,]    0    0 0.00 0.00  0.0 #> [3,]    0    0 0.00 0.00  0.0 #> [4,]    0    0 0.00 0.00  0.0 #> [5,]    0    0 0.00 0.00  0.0 #>  #>   # Also works with a single matrix. mats <- make_leslie_mpm(   survival = c(0.1, 0.2, 0.5),   fecundity = c(0, 1.2, 2.4),   n_stages = 3, split = TRUE )  # Sample size is a single value add_mpm_error(mat_U = mats$mat_U, mat_F = mats$mat_F, sample_size = 20) #> $mat_A #>      [,1] [,2] [,3] #> [1,]  0.0  1.0 2.50 #> [2,]  0.1  0.0 0.00 #> [3,]  0.0  0.2 0.45 #>  #> $mat_U #>      [,1] [,2] [,3] #> [1,]  0.0  0.0 0.00 #> [2,]  0.1  0.0 0.00 #> [3,]  0.0  0.2 0.45 #>  #> $mat_F #>      [,1] [,2] [,3] #> [1,]    0    1  2.5 #> [2,]    0    0  0.0 #> [3,]    0    0  0.0 #>   # Sample size is a list of two matrices # here with a sample size of 20 for fecundity and 10 for growth/survival. mpm_set <- rand_lefko_set(   n = 5, n_stages = 3, fecundity = c(0, 2, 4),   archetype = 4, output = \"Type4\" )  ssMats <- list(   \"mat_F_ss\" = matrix(20, nrow = 3, ncol = 3),   \"mat_U_ss\" = matrix(10, nrow = 3, ncol = 3) )  # Add sampling error to the matrix models output <- add_mpm_error(   mat_U = mpm_set$U_list, mat_F = mpm_set$F_list,   sample_size = ssMats )  # Examine the outputs names(output) #> [1] \"A_list\" \"U_list\" \"F_list\" output #> $A_list #> $A_list[[1]] #>      [,1] [,2] [,3] #> [1,]  0.3  1.5  4.1 #> [2,]  0.1  0.3  0.0 #> [3,]  0.0  0.5  1.0 #>  #> $A_list[[2]] #>      [,1] [,2] [,3] #> [1,]  0.5  2.2 4.25 #> [2,]  0.2  0.5 0.00 #> [3,]  0.0  0.3 0.70 #>  #> $A_list[[3]] #>      [,1] [,2] [,3] #> [1,]  0.0  1.9 4.15 #> [2,]  0.9  0.7 0.00 #> [3,]  0.0  0.0 1.00 #>  #> $A_list[[4]] #>      [,1] [,2] [,3] #> [1,]  0.5 1.45  3.7 #> [2,]  0.2 0.40  0.0 #> [3,]  0.0 0.40  1.0 #>  #> $A_list[[5]] #>      [,1] [,2] [,3] #> [1,]  0.7  1.9  3.8 #> [2,]  0.1  0.6  0.0 #> [3,]  0.0  0.4  1.0 #>  #>  #> $U_list #> $U_list[[1]] #>      [,1] [,2] [,3] #> [1,]  0.3  0.0    0 #> [2,]  0.1  0.3    0 #> [3,]  0.0  0.5    1 #>  #> $U_list[[2]] #>      [,1] [,2] [,3] #> [1,]  0.5  0.0  0.0 #> [2,]  0.2  0.5  0.0 #> [3,]  0.0  0.3  0.7 #>  #> $U_list[[3]] #>      [,1] [,2] [,3] #> [1,]  0.0  0.0    0 #> [2,]  0.9  0.7    0 #> [3,]  0.0  0.0    1 #>  #> $U_list[[4]] #>      [,1] [,2] [,3] #> [1,]  0.5  0.0    0 #> [2,]  0.2  0.4    0 #> [3,]  0.0  0.4    1 #>  #> $U_list[[5]] #>      [,1] [,2] [,3] #> [1,]  0.7  0.0    0 #> [2,]  0.1  0.6    0 #> [3,]  0.0  0.4    1 #>  #>  #> $F_list #> $F_list[[1]] #>      [,1] [,2] [,3] #> [1,]    0  1.5  4.1 #> [2,]    0  0.0  0.0 #> [3,]    0  0.0  0.0 #>  #> $F_list[[2]] #>      [,1] [,2] [,3] #> [1,]    0  2.2 4.25 #> [2,]    0  0.0 0.00 #> [3,]    0  0.0 0.00 #>  #> $F_list[[3]] #>      [,1] [,2] [,3] #> [1,]    0  1.9 4.15 #> [2,]    0  0.0 0.00 #> [3,]    0  0.0 0.00 #>  #> $F_list[[4]] #>      [,1] [,2] [,3] #> [1,]    0 1.45  3.7 #> [2,]    0 0.00  0.0 #> [3,]    0 0.00  0.0 #>  #> $F_list[[5]] #>      [,1] [,2] [,3] #> [1,]    0  1.9  3.8 #> [2,]    0  0.0  0.0 #> [3,]    0  0.0  0.0 #>  #>"},{"path":"https://jonesor.github.io/mpmsim/reference/calculate_errors.html","id":null,"dir":"Reference","previous_headings":"","what":"Calculate error (standard error or 95%CI) in elements of a matrix population model. — calculate_errors","title":"Calculate error (standard error or 95%CI) in elements of a matrix population model. — calculate_errors","text":"Given two submatrices matrix population model (mat_U mat_F, growth/survival matrix fecundity matrix respectively) sample size, matrix/matrices sample sizes, function calculates standard error 95% confidence interval (95%CI) element matrix. calculations assume mat_U result binomial processes (.e., survival (0/1) sample n individuals), mat_F result Poisson processes (.e., counts offspring n individuals), n sample size.","code":""},{"path":"https://jonesor.github.io/mpmsim/reference/calculate_errors.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Calculate error (standard error or 95%CI) in elements of a matrix population model. — calculate_errors","text":"","code":"calculate_errors(mat_U, mat_F, sample_size, type = \"sem\", calculate_A = TRUE)"},{"path":"https://jonesor.github.io/mpmsim/reference/calculate_errors.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Calculate error (standard error or 95%CI) in elements of a matrix population model. — calculate_errors","text":"mat_U matrix mean survival probabilities mat_F matrix mean fecundity values sample_size either (1) single matrix sample sizes element MPM, (2) list two named matrices (\"mat_F_ss\", \"mat_U_ss\") containing sample sizes survival fecundity submatrices MPM (3) single value applied whole matrix type character string indicating type error calculate. Must one \"sem\" (standard error), \"CI95\" (95% confidence interval). calculate_A logical argument indicating whether returned error information include matrix error. Defaults TRUE.","code":""},{"path":"https://jonesor.github.io/mpmsim/reference/calculate_errors.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Calculate error (standard error or 95%CI) in elements of a matrix population model. — calculate_errors","text":"list containing original matrices error estimates (upper lower confidence intervals) U, F (optionally) matrices.","code":""},{"path":"https://jonesor.github.io/mpmsim/reference/calculate_errors.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Calculate error (standard error or 95%CI) in elements of a matrix population model. — calculate_errors","text":"output list containing original matrices matrices showing error estimates confidence intervals.","code":""},{"path":[]},{"path":"https://jonesor.github.io/mpmsim/reference/calculate_errors.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Calculate error (standard error or 95%CI) in elements of a matrix population model. — calculate_errors","text":"Owen Jones jones@biology.sdu.dk","code":""},{"path":"https://jonesor.github.io/mpmsim/reference/calculate_errors.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Calculate error (standard error or 95%CI) in elements of a matrix population model. — calculate_errors","text":"","code":"# Set up two submatrices matU <- matrix(c(   0.1, 0,   0.2, 0.4 ), byrow = TRUE, nrow = 2) matF <- matrix(c(   0, 4,   0., 0. ), byrow = TRUE, nrow = 2)  # errors as 95% CI, with a sample size of 20 for all elements calculate_errors(mat_U = matU, mat_F = matF, sample_size = 20, type = \"CI95\") #> $mat_F #>      [,1] [,2] #> [1,]    0    4 #> [2,]    0    0 #>  #> $mat_F_lowerCI #>      [,1]     [,2] #> [1,]    0 3.123461 #> [2,]    0 0.000000 #>  #> $mat_F_upperCI #>      [,1]     [,2] #> [1,]    0 4.876539 #> [2,]    0 0.000000 #>  #> $mat_U #>      [,1] [,2] #> [1,]  0.1  0.0 #> [2,]  0.2  0.4 #>  #> $mat_U_lowerCI #>            [,1]      [,2] #> [1,] 0.00000000 0.0000000 #> [2,] 0.02469227 0.1852928 #>  #> $mat_U_upperCI #>           [,1]      [,2] #> [1,] 0.2314808 0.0000000 #> [2,] 0.3753077 0.6147072 #>  #> $mat_A #>      [,1] [,2] #> [1,]  0.1  4.0 #> [2,]  0.2  0.4 #>  #> $mat_A_lowerCI #>            [,1]      [,2] #> [1,] 0.00000000 3.1234614 #> [2,] 0.02469227 0.1852928 #>  #> $mat_A_upperCI #>           [,1]      [,2] #> [1,] 0.2314808 4.8765386 #> [2,] 0.3753077 0.6147072 #>   # errors as sem, with a sample size of 20 for all elements calculate_errors(mat_U = matU, mat_F = matF, sample_size = 20, type = \"sem\") #> $mat_U #>      [,1] [,2] #> [1,]  0.1  0.0 #> [2,]  0.2  0.4 #>  #> $`,mat_U_error` #>            [,1]      [,2] #> [1,] 0.06708204 0.0000000 #> [2,] 0.08944272 0.1095445 #>  #> $mat_F #>      [,1] [,2] #> [1,]    0    4 #> [2,]    0    0 #>  #> $mat_F_error #>      [,1]      [,2] #> [1,]    0 0.4472136 #> [2,]    0 0.0000000 #>  #> $mat_A #>      [,1] [,2] #> [1,]    0    4 #> [2,]    0    0 #>  #> $mat_A_error #>            [,1]      [,2] #> [1,] 0.06708204 0.4472136 #> [2,] 0.08944272 0.1095445 #>   # Sample size is a single matrix applied to both F and U matrices ssMat <- matrix(10, nrow = 2, ncol = 2)  calculate_errors(   mat_U = matU, mat_F = matF, sample_size = ssMat, type =     \"sem\" ) #> $mat_U #>      [,1] [,2] #> [1,]  0.1  0.0 #> [2,]  0.2  0.4 #>  #> $`,mat_U_error` #>            [,1]      [,2] #> [1,] 0.09486833 0.0000000 #> [2,] 0.12649111 0.1549193 #>  #> $mat_F #>      [,1] [,2] #> [1,]    0    4 #> [2,]    0    0 #>  #> $mat_F_error #>      [,1]      [,2] #> [1,]    0 0.6324555 #> [2,]    0 0.0000000 #>  #> $mat_A #>      [,1] [,2] #> [1,]    0    4 #> [2,]    0    0 #>  #> $mat_A_error #>            [,1]      [,2] #> [1,] 0.09486833 0.6324555 #> [2,] 0.12649111 0.1549193 #>   # Sample size is a list of two matrices, one for F and one for U. ssMats <- list(   \"mat_F_ss\" = matrix(10, nrow = 2, ncol = 2),   \"mat_U_ss\" = matrix(10, nrow = 2, ncol = 2) ) calculate_errors(   mat_U = matU, mat_F = matF, sample_size = ssMats, type =     \"sem\" ) #> $mat_U #>      [,1] [,2] #> [1,]  0.1  0.0 #> [2,]  0.2  0.4 #>  #> $`,mat_U_error` #>            [,1]      [,2] #> [1,] 0.09486833 0.0000000 #> [2,] 0.12649111 0.1549193 #>  #> $mat_F #>      [,1] [,2] #> [1,]    0    4 #> [2,]    0    0 #>  #> $mat_F_error #>      [,1]      [,2] #> [1,]    0 0.6324555 #> [2,]    0 0.0000000 #>  #> $mat_A #>      [,1] [,2] #> [1,]    0    4 #> [2,]    0    0 #>  #> $mat_A_error #>            [,1]      [,2] #> [1,] 0.09486833 0.6324555 #> [2,] 0.12649111 0.1549193 #>"},{"path":"https://jonesor.github.io/mpmsim/reference/compute_ci.html","id":null,"dir":"Reference","previous_headings":"","what":"Compute 95% confidence intervals for derived estimates from a matrix population model — compute_ci","title":"Compute 95% confidence intervals for derived estimates from a matrix population model — compute_ci","text":"function computes 95% confidence interval measures derived matrix population model using parametric bootstrapping. approach sampling distribution matrix population model (MPM) generated taking large number random independent draws using sampling distribution underlying transition rate. approach rests assumption survival-related processes binomial, fecundity Poisson process (see function add_mpm_error() details).","code":""},{"path":"https://jonesor.github.io/mpmsim/reference/compute_ci.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Compute 95% confidence intervals for derived estimates from a matrix population model — compute_ci","text":"","code":"compute_ci(mat_U, mat_F, sample_size, FUN, ..., n_sim = 1000, dist.out = FALSE)"},{"path":"https://jonesor.github.io/mpmsim/reference/compute_ci.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Compute 95% confidence intervals for derived estimates from a matrix population model — compute_ci","text":"mat_U matrix describes growth survival process. mat_F matrix describes fecundity. sample_size either (1) single matrix sample sizes element MPM, (2) list two named matrices (\"mat_F_ss\", \"mat_U_ss\") containing sample sizes survival fecundity submatrices MPM (3) single value applied whole matrix FUN function apply simulated matrix population model. function must take, input, single matrix population model (.e., matrix). functions require U matrix, use compute_ci_U. ... Additional arguments passed FUN. n_sim integer indicating number simulations run. Default 1000. dist.Logical. TRUE, returns list quantiles simulated estimates. Default FALSE.","code":""},{"path":"https://jonesor.github.io/mpmsim/reference/compute_ci.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Compute 95% confidence intervals for derived estimates from a matrix population model — compute_ci","text":"dist.FALSE, numeric vector 2.5th 97.5th quantiles estimated measures. dist.= TRUE, list two elements: quantiles estimates. quantiles numeric vector 2.5th 97.5th quantiles estimated measures, estimates numeric vector estimated measures.","code":""},{"path":"https://jonesor.github.io/mpmsim/reference/compute_ci.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Compute 95% confidence intervals for derived estimates from a matrix population model — compute_ci","text":"inputs U matrix, describes survival-related processes, F matrix describes fecundity. underlying assumption U matrix average binomial process F matrix average Poisson process . confidence interval depend largely sample size used.","code":""},{"path":"https://jonesor.github.io/mpmsim/reference/compute_ci.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Compute 95% confidence intervals for derived estimates from a matrix population model — compute_ci","text":"Chapter 12 Caswell, H. (2001). Matrix Population Models. Sinauer Associates Incorporated.","code":""},{"path":[]},{"path":"https://jonesor.github.io/mpmsim/reference/compute_ci.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Compute 95% confidence intervals for derived estimates from a matrix population model — compute_ci","text":"Owen Jones jones@biology.sdu.dk","code":""},{"path":"https://jonesor.github.io/mpmsim/reference/compute_ci.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Compute 95% confidence intervals for derived estimates from a matrix population model — compute_ci","text":"","code":"set.seed(42) # set seed for repeatability  # Data for use in example matU <- matrix(c(   0.1, 0.0,   0.2, 0.4 ), byrow = TRUE, nrow = 2)  matF <- matrix(c(   0.0, 5.0,   0.0, 0.0 ), byrow = TRUE, nrow = 2)  set.seed(42)  # Example of use to calculate 95% CI of lambda compute_ci(   mat_U = matU, mat_F = matF, sample_size = 10, FUN =     popbio::lambda ) #>     2.5%    97.5%  #> 0.300000 1.824895   # Example of use to calculate 95% CI of generation time compute_ci(   mat_U = matU, mat_F = matF, sample_size = 40, FUN =     popbio::generation.time ) #>     2.5%    97.5%  #> 2.386966 3.072293   # Example of use to calculate 95% CI of generation time and show the # distribution of those bootstrapped estimates xx <- compute_ci(   mat_U = matU, mat_F = matF, sample_size = 100, FUN =     popbio::generation.time, dist.out = TRUE ) summary(xx$quantiles) #>    Min. 1st Qu.  Median    Mean 3rd Qu.    Max.  #>   2.476   2.581   2.686   2.686   2.791   2.896  hist(xx$estimates)"},{"path":"https://jonesor.github.io/mpmsim/reference/compute_ci_U.html","id":null,"dir":"Reference","previous_headings":"","what":"Compute 95% confidence intervals for derived estimates from the U submatrix of a matrix population model — compute_ci_U","title":"Compute 95% confidence intervals for derived estimates from the U submatrix of a matrix population model — compute_ci_U","text":"function computes 95% confidence interval measures derived U submatrix matrix population model using parametric bootstrapping. approach sampling distribution U submatrix generated taking large number random independent draws using sampling distribution underlying transition rate. approach rests assumption survival-related processes binomial (see function add_mpm_error() details).","code":""},{"path":"https://jonesor.github.io/mpmsim/reference/compute_ci_U.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Compute 95% confidence intervals for derived estimates from the U submatrix of a matrix population model — compute_ci_U","text":"","code":"compute_ci_U(mat_U, sample_size, FUN, ..., n_sim = 1000, dist.out = FALSE)"},{"path":"https://jonesor.github.io/mpmsim/reference/compute_ci_U.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Compute 95% confidence intervals for derived estimates from the U submatrix of a matrix population model — compute_ci_U","text":"mat_U matrix describes growth survival process. sample_size either (1) single matrix sample sizes element U matrix, (2) single value applied whole matrix FUN function apply simulated matrix population model. function must take, input, single U submatrix matrix population model (.e., U matrix). functions require matrix, use compute_ci. ... Additional arguments passed FUN. n_sim integer indicating number simulations run. Default 1000. dist.Logical. TRUE, returns list quantiles simulated estimates. Default FALSE.","code":""},{"path":"https://jonesor.github.io/mpmsim/reference/compute_ci_U.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Compute 95% confidence intervals for derived estimates from the U submatrix of a matrix population model — compute_ci_U","text":"dist.FALSE, numeric vector 2.5th 97.5th quantiles estimated measures. dist.= TRUE, list two elements: quantiles estimates. quantiles numeric vector 2.5th 97.5th quantiles estimated measures, estimates numeric vector estimated measures.","code":""},{"path":"https://jonesor.github.io/mpmsim/reference/compute_ci_U.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Compute 95% confidence intervals for derived estimates from the U submatrix of a matrix population model — compute_ci_U","text":"main inputs U matrix, describes survival-related processes. underlying assumption U matrix average binomial process. confidence interval depend largely sample size used.","code":""},{"path":"https://jonesor.github.io/mpmsim/reference/compute_ci_U.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Compute 95% confidence intervals for derived estimates from the U submatrix of a matrix population model — compute_ci_U","text":"Chapter 12 Caswell, H. (2001). Matrix Population Models. Sinauer Associates Incorporated.","code":""},{"path":[]},{"path":"https://jonesor.github.io/mpmsim/reference/compute_ci_U.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Compute 95% confidence intervals for derived estimates from the U submatrix of a matrix population model — compute_ci_U","text":"Owen Jones jones@biology.sdu.dk","code":""},{"path":"https://jonesor.github.io/mpmsim/reference/compute_ci_U.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Compute 95% confidence intervals for derived estimates from the U submatrix of a matrix population model — compute_ci_U","text":"","code":"set.seed(42) # set seed for repeatability  # Data for use in example matU <- matrix(c(   0.1, 0.0,   0.2, 0.4 ), byrow = TRUE, nrow = 2)   # Example of use to calculate 95% CI of life expectancy compute_ci_U(   mat_U = matU, sample_size = 10, FUN =     Rage::life_expect_mean ) #>     2.5%    97.5%  #> 1.000000 2.334524   # Example of use to calculate 95% CI of generation time and show the # distribution of those bootstrapped estimates xx <- compute_ci_U(   mat_U = matU, sample_size = 100, FUN =     Rage::life_expect_mean, dist.out = TRUE )  summary(xx$quantiles) #>    Min. 1st Qu.  Median    Mean 3rd Qu.    Max.  #>   1.314   1.405   1.495   1.495   1.586   1.676  hist(xx$estimates)"},{"path":"https://jonesor.github.io/mpmsim/reference/driven_vital_rate.html","id":null,"dir":"Reference","previous_headings":"","what":"Calculate driven vital rates — driven_vital_rate","title":"Calculate driven vital rates — driven_vital_rate","text":"function calculates new values vital rate, survival fecundity influenced driver (e.g., weather). using driver variable baseline value, along specified slope relationship driver variable vital rate. function works linearised scale, using logit survival log fecundity, takes account error standard deviation.","code":""},{"path":"https://jonesor.github.io/mpmsim/reference/driven_vital_rate.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Calculate driven vital rates — driven_vital_rate","text":"","code":"driven_vital_rate(   driver,   baseline_value = NULL,   slope = NULL,   baseline_driver = NULL,   error_sd = 0,   link = \"logit\" )"},{"path":"https://jonesor.github.io/mpmsim/reference/driven_vital_rate.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Calculate driven vital rates — driven_vital_rate","text":"driver vector driver values. baseline_value vector matrix baseline values vital rate (e.g., survival) influenced (\"driven\") another variable (e.g. climatic variable). slope vector matrix slopes relationship driver variable vital rate driven. baseline_driver baseline_driver parameter single value representing baseline driver value. driver value greater value slope positive, resulting vital rate higher. Conversely, driver value less variable slope positive, resulting vital rate less baseline value. error_sd vector matrix error standard deviations random normal error added driven value vital rate modelled. set 0 (default), error added. link character string indicating type link function use. Valid values \"logit\" (default) \"log\", appropriate survival (U submatrix) fecundity (F submatrix) respectively.","code":""},{"path":"https://jonesor.github.io/mpmsim/reference/driven_vital_rate.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Calculate driven vital rates — driven_vital_rate","text":"Depending input types, either single value, vector list matrices driven values vital rate(s) modelled. list length equal length driver input parameter.","code":""},{"path":"https://jonesor.github.io/mpmsim/reference/driven_vital_rate.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Calculate driven vital rates — driven_vital_rate","text":"relationship driver variable vital rate assumed linear: $$V = * (d - d_b) + x + E$$ $$V$$ new vital rate (scale linear predictor), $$$$ slope, $$x$$ baseline vital rate, $$d$$ driver, $$d_b$$ baseline driver $$E$$ error. input vital rate(s) (baseline_value) can single-element vector representing single vital rate (e.g., survival probability fecundity), longer vector representing series vital rates (e.g., several survival probabilities fecundity values), matrix values (e.g., U F submatrix matrix population model). slopes relationship vital rate (baseline_value) driver can provided single value, applied elements input vital rates, matrix values map onto matrix vital rates. allows users simulate cases different vital rates matrix model affected different ways weather driver. example, juvenile survival might affected driver adult survival. baseline_driver value represents \"normal\" state driver. driver greater baseline_driver slope positive, outcome vital rate higher. driver less baseline_driver variable slope positive, outcome vital rate less baseline_value. error_sd represents error linear relationship driver vital rate.","code":""},{"path":"https://jonesor.github.io/mpmsim/reference/driven_vital_rate.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Calculate driven vital rates — driven_vital_rate","text":"Owen Jones jones@biology.sdu.dk","code":""},{"path":"https://jonesor.github.io/mpmsim/reference/driven_vital_rate.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Calculate driven vital rates — driven_vital_rate","text":"","code":"set.seed(42) # set seed for repeatability  # A single vital rate and a single driver driven_vital_rate(   driver = 14,   baseline_value = 0.5,   slope = .4,   baseline_driver = 10,   error_sd = 0,   link = \"logit\" ) #> [1] 0.8320184  # A single vital rate and a time series of drivers driven_vital_rate(   driver = runif(10, 5, 15),   baseline_value = 0.5,   slope = .4,   baseline_driver = 10,   error_sd = 0,   link = \"logit\" ) #> [[1]] #> [1] 0.8401338 #>  #> [[2]] #> [1] 0.8517385 #>  #> [[3]] #> [1] 0.2982926 #>  #> [[4]] #> [1] 0.7894794 #>  #> [[5]] #> [1] 0.6380665 #>  #> [[6]] #> [1] 0.5190867 #>  #> [[7]] #> [1] 0.7203812 #>  #> [[8]] #> [1] 0.1882634 #>  #> [[9]] #> [1] 0.6520288 #>  #> [[10]] #> [1] 0.6942913 #>   # A matrix of survival values (U submatrix of a Leslie model) # with a series of drivers, and matrices of slopes and errors  lt1 <- model_survival(params = c(b_0 = 0.4, b_1 = 0.5), model = \"Gompertz\") lt1$fecundity <- model_fecundity(   age = 0:max(lt1$x), params = c(A = 10),   maturity = 3, model = \"step\" )  mats <- make_leslie_mpm(   survival = lt1$px, fecundity = lt1$fecundity, n_stages =     nrow(lt1), split = TRUE ) mats$mat_U #>           [,1]      [,2]      [,3]       [,4] #> [1,] 0.0000000 0.0000000 0.0000000 0.00000000 #> [2,] 0.5887555 0.0000000 0.0000000 0.00000000 #> [3,] 0.0000000 0.4175293 0.0000000 0.00000000 #> [4,] 0.0000000 0.0000000 0.2369291 0.09309368 mat_dim <- nrow(mats$mat_U)  driven_vital_rate(   driver = runif(5, 5, 15),   baseline_value = mats$mat_U,   slope = matrix(.4,     nrow = mat_dim,     ncol = mat_dim   ),   baseline_driver = 10,   error_sd = matrix(1, nrow = mat_dim, ncol = mat_dim),   link = \"logit\" ) #> [[1]] #>           [,1]      [,2]      [,3]     [,4] #> [1,] 0.0000000 0.0000000 0.0000000 0.000000 #> [2,] 0.2693641 0.0000000 0.0000000 0.000000 #> [3,] 0.0000000 0.6927488 0.0000000 0.000000 #> [4,] 0.0000000 0.0000000 0.1040332 0.326901 #>  #> [[2]] #>           [,1]      [,2]      [,3]      [,4] #> [1,] 0.0000000 0.0000000 0.0000000 0.0000000 #> [2,] 0.8231306 0.0000000 0.0000000 0.0000000 #> [3,] 0.0000000 0.6409893 0.0000000 0.0000000 #> [4,] 0.0000000 0.0000000 0.2693954 0.1522152 #>  #> [[3]] #>           [,1]      [,2]      [,3]       [,4] #> [1,] 0.0000000 0.0000000 0.0000000 0.00000000 #> [2,] 0.7492108 0.0000000 0.0000000 0.00000000 #> [3,] 0.0000000 0.1103529 0.0000000 0.00000000 #> [4,] 0.0000000 0.0000000 0.4470173 0.03307616 #>  #> [[4]] #>           [,1]     [,2]     [,3]        [,4] #> [1,] 0.0000000 0.000000 0.000000 0.000000000 #> [2,] 0.3233925 0.000000 0.000000 0.000000000 #> [3,] 0.0000000 0.252657 0.000000 0.000000000 #> [4,] 0.0000000 0.000000 0.350992 0.009396171 #>  #> [[5]] #>          [,1]      [,2]       [,3]       [,4] #> [1,] 0.000000 0.0000000 0.00000000 0.00000000 #> [2,] 0.752661 0.0000000 0.00000000 0.00000000 #> [3,] 0.000000 0.5681767 0.00000000 0.00000000 #> [4,] 0.000000 0.0000000 0.09643508 0.07751234 #>"},{"path":"https://jonesor.github.io/mpmsim/reference/generate_mpm_set.html","id":null,"dir":"Reference","previous_headings":"","what":"Generate lists of Lefkovitch matrix population models (MPMs) based on life history archetypes — generate_mpm_set","title":"Generate lists of Lefkovitch matrix population models (MPMs) based on life history archetypes — generate_mpm_set","text":"function deprecated. Use rand_lefko_set instead.","code":""},{"path":"https://jonesor.github.io/mpmsim/reference/generate_mpm_set.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Generate lists of Lefkovitch matrix population models (MPMs) based on life history archetypes — generate_mpm_set","text":"","code":"generate_mpm_set(   n = 10,   n_stages = 3,   archetype = 1,   fecundity = 1.5,   split = TRUE,   by_type = TRUE,   as_compadre = TRUE,   max_surv = 0.99,   constraint = NULL,   attempts = 1000 )"},{"path":"https://jonesor.github.io/mpmsim/reference/generate_mpm_set.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Generate lists of Lefkovitch matrix population models (MPMs) based on life history archetypes — generate_mpm_set","text":"n number MPMs generate. Default 10. n_stages number stages MPMs. Default 3. archetype archetype MPMs. Default 1. fecundity vector fecundities MPMs. Default 1.5. split logical indicating whether split submatrices. Default TRUE. by_type logical indicating whether matrices returned list type (, U, F, C). split FALSE, by_type must coerced FALSE. Defaults TRUE. as_compadre logical indicating whether matrices returned CompadreDB object. Default TRUE. FALSE, function returns list. max_surv maximum acceptable survival value, calculated across transitions stage. Defaults 0.99. used split = TRUE. constraint optional data frame 4 columns named fun, arg, lower upper. columns specify (1) function outputs metric derived matrix (2) argument function (NA, argument supplied) (3) lower acceptable bound metric (4) upper acceptable bound metric. used specify attempts integer indicating number attempts made simulating matrix model. default 1000. takes 1000 attempts make matrix satisfies conditions set arguments, warning produced.","code":""},{"path":"https://jonesor.github.io/mpmsim/reference/generate_mpm_set.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Generate lists of Lefkovitch matrix population models (MPMs) based on life history archetypes — generate_mpm_set","text":"list MPMs meet specified criteria.","code":""},{"path":"https://jonesor.github.io/mpmsim/reference/generate_mpm_set.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Generate lists of Lefkovitch matrix population models (MPMs) based on life history archetypes — generate_mpm_set","text":"function generates list n MPMs according specified criteria. Criteria include archetype, acceptable constraining criteria, include lambda, generation time metric derived matrix. function attempts find matrices fulfil criteria, discarding unacceptable matrices. default, takes 1000 attempts find suitable matrix model, error produced. However, number attempts can altered attempts parameter.","code":""},{"path":[]},{"path":"https://jonesor.github.io/mpmsim/reference/generate_mpm_set.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Generate lists of Lefkovitch matrix population models (MPMs) based on life history archetypes — generate_mpm_set","text":"Owen Jones jones@biology.sdu.dk","code":""},{"path":"https://jonesor.github.io/mpmsim/reference/generate_mpm_set.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Generate lists of Lefkovitch matrix population models (MPMs) based on life history archetypes — generate_mpm_set","text":"","code":"set.seed(42) # set seed for repeatability  # Basic operation, without splitting matrices and with no constraints generate_mpm_set(   n = 10, n_stages = 5, fecundity = c(0, 0, 4, 8, 10),   archetype = 4, split = FALSE, by_type = FALSE, as_compadre = FALSE ) #> Warning: 'generate_mpm_set' is deprecated. #> Use 'rand_lefko_set' instead. #> See help(\"Deprecated\") #> Warning: 'random_mpm' is deprecated. #> Use 'rand_lefko_mpm' instead. #> See help(\"Deprecated\") #> Warning: 'random_mpm' is deprecated. #> Use 'rand_lefko_mpm' instead. #> See help(\"Deprecated\") #> Warning: 'random_mpm' is deprecated. #> Use 'rand_lefko_mpm' instead. #> See help(\"Deprecated\") #> Warning: 'random_mpm' is deprecated. #> Use 'rand_lefko_mpm' instead. #> See help(\"Deprecated\") #> Warning: 'random_mpm' is deprecated. #> Use 'rand_lefko_mpm' instead. #> See help(\"Deprecated\") #> Warning: 'random_mpm' is deprecated. #> Use 'rand_lefko_mpm' instead. #> See help(\"Deprecated\") #> Warning: 'random_mpm' is deprecated. #> Use 'rand_lefko_mpm' instead. #> See help(\"Deprecated\") #> Warning: 'random_mpm' is deprecated. #> Use 'rand_lefko_mpm' instead. #> See help(\"Deprecated\") #> Warning: 'random_mpm' is deprecated. #> Use 'rand_lefko_mpm' instead. #> See help(\"Deprecated\") #> Warning: 'random_mpm' is deprecated. #> Use 'rand_lefko_mpm' instead. #> See help(\"Deprecated\") #> [[1]] #>            [,1]       [,2]      [,3]      [,4]       [,5] #> [1,] 0.04028499 0.00000000 4.0000000 8.0000000 10.0000000 #> [2,] 0.71907852 0.73066610 0.0000000 0.0000000  0.0000000 #> [3,] 0.00000000 0.06797628 0.5129277 0.0000000  0.0000000 #> [4,] 0.00000000 0.00000000 0.2895418 0.8589953  0.0000000 #> [5,] 0.00000000 0.00000000 0.0000000 0.1331578  0.9997924 #>  #> [[2]] #>            [,1]       [,2]      [,3]      [,4]       [,5] #> [1,] 0.04993404 0.00000000 4.0000000 8.0000000 10.0000000 #> [2,] 0.35213116 0.38662704 0.0000000 0.0000000  0.0000000 #> [3,] 0.00000000 0.04413311 0.2022055 0.0000000  0.0000000 #> [4,] 0.00000000 0.00000000 0.4116914 0.4473679  0.0000000 #> [5,] 0.00000000 0.00000000 0.0000000 0.4300040  0.9673925 #>  #> [[3]] #>           [,1]      [,2]      [,3]      [,4]       [,5] #> [1,] 0.3908713 0.0000000 4.0000000 8.0000000 10.0000000 #> [2,] 0.1593942 0.3008004 0.0000000 0.0000000  0.0000000 #> [3,] 0.0000000 0.4611680 0.5792468 0.0000000  0.0000000 #> [4,] 0.0000000 0.0000000 0.2741919 0.2238051  0.0000000 #> [5,] 0.0000000 0.0000000 0.0000000 0.6835265  0.9941976 #>  #> [[4]] #>            [,1]       [,2]       [,3]      [,4]       [,5] #> [1,] 0.01338708 0.00000000 4.00000000 8.0000000 10.0000000 #> [2,] 0.46380038 0.47987890 0.00000000 0.0000000  0.0000000 #> [3,] 0.00000000 0.03799584 0.64886531 0.0000000  0.0000000 #> [4,] 0.00000000 0.00000000 0.01000717 0.3753701  0.0000000 #> [5,] 0.00000000 0.00000000 0.00000000 0.3401858  0.7684915 #>  #> [[5]] #>            [,1]      [,2]      [,3]      [,4]       [,5] #> [1,] 0.67478475 0.0000000 4.0000000 8.0000000 10.0000000 #> [2,] 0.04733024 0.4311501 0.0000000 0.0000000  0.0000000 #> [3,] 0.00000000 0.4961576 0.3634766 0.0000000  0.0000000 #> [4,] 0.00000000 0.0000000 0.5725528 0.7279782  0.0000000 #> [5,] 0.00000000 0.0000000 0.0000000 0.2540920  0.9967819 #>  #> [[6]] #>           [,1]      [,2]      [,3]      [,4]       [,5] #> [1,] 0.3819523 0.0000000 4.0000000 8.0000000 10.0000000 #> [2,] 0.2431420 0.3941680 0.0000000 0.0000000  0.0000000 #> [3,] 0.0000000 0.4929144 0.2382274 0.0000000  0.0000000 #> [4,] 0.0000000 0.0000000 0.7382744 0.7182629  0.0000000 #> [5,] 0.0000000 0.0000000 0.0000000 0.2756301  0.9947253 #>  #> [[7]] #>            [,1]      [,2]       [,3]       [,4]       [,5] #> [1,] 0.16074427 0.0000000 4.00000000 8.00000000 10.0000000 #> [2,] 0.03843446 0.1920300 0.00000000 0.00000000  0.0000000 #> [3,] 0.00000000 0.5599534 0.83063495 0.00000000  0.0000000 #> [4,] 0.00000000 0.0000000 0.01691095 0.06976802  0.0000000 #> [5,] 0.00000000 0.0000000 0.00000000 0.92957038  0.9997121 #>  #> [[8]] #>            [,1]      [,2]      [,3]      [,4]       [,5] #> [1,] 0.11547275 0.0000000 4.0000000 8.0000000 10.0000000 #> [2,] 0.09164534 0.3982819 0.0000000 0.0000000  0.0000000 #> [3,] 0.00000000 0.1783419 0.4565705 0.0000000  0.0000000 #> [4,] 0.00000000 0.0000000 0.3108012 0.7438372  0.0000000 #> [5,] 0.00000000 0.0000000 0.0000000 0.2286126  0.9994464 #>  #> [[9]] #>            [,1]      [,2]      [,3]      [,4]       [,5] #> [1,] 0.40726303 0.0000000 4.0000000 8.0000000 10.0000000 #> [2,] 0.02472534 0.5507259 0.0000000 0.0000000  0.0000000 #> [3,] 0.00000000 0.1762418 0.4303426 0.0000000  0.0000000 #> [4,] 0.00000000 0.0000000 0.3952927 0.1772480  0.0000000 #> [5,] 0.00000000 0.0000000 0.0000000 0.7574622  0.9818421 #>  #> [[10]] #>             [,1]       [,2]      [,3]      [,4]       [,5] #> [1,] 0.195267196 0.00000000 4.0000000 8.0000000 10.0000000 #> [2,] 0.009539193 0.01108828 0.0000000 0.0000000  0.0000000 #> [3,] 0.000000000 0.40598266 0.1292108 0.0000000  0.0000000 #> [4,] 0.000000000 0.00000000 0.3215483 0.2109751  0.0000000 #> [5,] 0.000000000 0.00000000 0.0000000 0.4432477  0.8537529 #>   # Constrain outputs to A matrices with lambda between 0.9 and 1.1 library(popbio) constrain_df <- data.frame(   fun = \"lambda\", arg = NA, lower = 0.9, upper =     1.1 ) generate_mpm_set(   n = 10, n_stages = 5, fecundity = c(0, 0, 4, 8, 10),   archetype = 4, constraint = constrain_df, as_compadre = FALSE ) #> Warning: 'generate_mpm_set' is deprecated. #> Use 'rand_lefko_set' instead. #> See help(\"Deprecated\") #> Warning: 'random_mpm' is deprecated. #> Use 'rand_lefko_mpm' instead. #> See help(\"Deprecated\") #> Warning: 'random_mpm' is deprecated. #> Use 'rand_lefko_mpm' instead. #> See help(\"Deprecated\") #> Warning: 'random_mpm' is deprecated. #> Use 'rand_lefko_mpm' instead. #> See help(\"Deprecated\") #> Warning: 'random_mpm' is deprecated. #> Use 'rand_lefko_mpm' instead. #> See help(\"Deprecated\") #> Warning: 'random_mpm' is deprecated. #> Use 'rand_lefko_mpm' instead. #> See help(\"Deprecated\") #> Warning: 'random_mpm' is deprecated. #> Use 'rand_lefko_mpm' instead. #> See help(\"Deprecated\") #> Warning: 'random_mpm' is deprecated. #> Use 'rand_lefko_mpm' instead. #> See help(\"Deprecated\") #> Warning: 'random_mpm' is deprecated. #> Use 'rand_lefko_mpm' instead. #> See help(\"Deprecated\") #> Warning: 'random_mpm' is deprecated. #> Use 'rand_lefko_mpm' instead. #> See help(\"Deprecated\") #> Warning: 'random_mpm' is deprecated. #> Use 'rand_lefko_mpm' instead. #> See help(\"Deprecated\") #> Warning: 'random_mpm' is deprecated. #> Use 'rand_lefko_mpm' instead. #> See help(\"Deprecated\") #> Warning: 'random_mpm' is deprecated. #> Use 'rand_lefko_mpm' instead. #> See help(\"Deprecated\") #> Warning: 'random_mpm' is deprecated. #> Use 'rand_lefko_mpm' instead. #> See help(\"Deprecated\") #> Warning: 'random_mpm' is deprecated. #> Use 'rand_lefko_mpm' instead. #> See help(\"Deprecated\") #> Warning: 'random_mpm' is deprecated. #> Use 'rand_lefko_mpm' instead. #> See help(\"Deprecated\") #> Warning: 'random_mpm' is deprecated. #> Use 'rand_lefko_mpm' instead. #> See help(\"Deprecated\") #> Warning: 'random_mpm' is deprecated. #> Use 'rand_lefko_mpm' instead. #> See help(\"Deprecated\") #> Warning: 'random_mpm' is deprecated. #> Use 'rand_lefko_mpm' instead. #> See help(\"Deprecated\") #> Warning: 'random_mpm' is deprecated. #> Use 'rand_lefko_mpm' instead. #> See help(\"Deprecated\") #> Warning: 'random_mpm' is deprecated. #> Use 'rand_lefko_mpm' instead. #> See help(\"Deprecated\") #> Warning: 'random_mpm' is deprecated. #> Use 'rand_lefko_mpm' instead. #> See help(\"Deprecated\") #> Warning: 'random_mpm' is deprecated. #> Use 'rand_lefko_mpm' instead. #> See help(\"Deprecated\") #> Warning: 'random_mpm' is deprecated. #> Use 'rand_lefko_mpm' instead. #> See help(\"Deprecated\") #> Warning: 'random_mpm' is deprecated. #> Use 'rand_lefko_mpm' instead. #> See help(\"Deprecated\") #> $A_list #> $A_list[[1]] #>           [,1]       [,2]       [,3]      [,4]      [,5] #> [1,] 0.2025021 0.00000000 4.00000000 8.0000000 10.000000 #> [2,] 0.1808410 0.51560726 0.00000000 0.0000000  0.000000 #> [3,] 0.0000000 0.05938074 0.69893955 0.0000000  0.000000 #> [4,] 0.0000000 0.00000000 0.04270201 0.1153077  0.000000 #> [5,] 0.0000000 0.00000000 0.00000000 0.6563415  0.905483 #>  #> $A_list[[2]] #>           [,1]       [,2]       [,3]      [,4]       [,5] #> [1,] 0.3492059 0.00000000 4.00000000 8.0000000 10.0000000 #> [2,] 0.2623854 0.59588086 0.00000000 0.0000000  0.0000000 #> [3,] 0.0000000 0.02204176 0.03327729 0.0000000  0.0000000 #> [4,] 0.0000000 0.00000000 0.64881290 0.1459793  0.0000000 #> [5,] 0.0000000 0.00000000 0.00000000 0.6109135  0.9411863 #>  #> $A_list[[3]] #>           [,1]      [,2]       [,3]      [,4]      [,5] #> [1,] 0.0100986 0.0000000 4.00000000 8.0000000 10.000000 #> [2,] 0.2816060 0.3421699 0.00000000 0.0000000  0.000000 #> [3,] 0.0000000 0.2403473 0.60176000 0.0000000  0.000000 #> [4,] 0.0000000 0.0000000 0.01202352 0.5052573  0.000000 #> [5,] 0.0000000 0.0000000 0.00000000 0.2482741  0.975591 #>  #> $A_list[[4]] #>            [,1]       [,2]      [,3]      [,4]       [,5] #> [1,] 0.05277117 0.00000000 4.0000000 8.0000000 10.0000000 #> [2,] 0.14635732 0.14395871 0.0000000 0.0000000  0.0000000 #> [3,] 0.00000000 0.09478692 0.2766104 0.0000000  0.0000000 #> [4,] 0.00000000 0.00000000 0.6115977 0.1849629  0.0000000 #> [5,] 0.00000000 0.00000000 0.0000000 0.7926018  0.9830451 #>  #> $A_list[[5]] #>           [,1]       [,2]      [,3]      [,4]      [,5] #> [1,] 0.2695917 0.00000000 4.0000000 8.0000000 10.000000 #> [2,] 0.2267870 0.45112437 0.0000000 0.0000000  0.000000 #> [3,] 0.0000000 0.05989263 0.3118949 0.0000000  0.000000 #> [4,] 0.0000000 0.00000000 0.3091554 0.2289075  0.000000 #> [5,] 0.0000000 0.00000000 0.0000000 0.6927089  0.956369 #>  #> $A_list[[6]] #>           [,1]      [,2]      [,3]       [,4]       [,5] #> [1,] 0.2788292 0.0000000 4.0000000 8.00000000 10.0000000 #> [2,] 0.0816387 0.2433186 0.0000000 0.00000000  0.0000000 #> [3,] 0.0000000 0.3089479 0.1000315 0.00000000  0.0000000 #> [4,] 0.0000000 0.0000000 0.4670093 0.73745701  0.0000000 #> [5,] 0.0000000 0.0000000 0.0000000 0.04978961  0.8887938 #>  #> $A_list[[7]] #>           [,1]      [,2]       [,3]      [,4]       [,5] #> [1,] 0.2772425 0.0000000 4.00000000 8.0000000 10.0000000 #> [2,] 0.1276093 0.4284850 0.00000000 0.0000000  0.0000000 #> [3,] 0.0000000 0.1104893 0.05017521 0.0000000  0.0000000 #> [4,] 0.0000000 0.0000000 0.60407149 0.1454031  0.0000000 #> [5,] 0.0000000 0.0000000 0.00000000 0.7206787  0.8721605 #>  #> $A_list[[8]] #>            [,1]      [,2]      [,3]       [,4]       [,5] #> [1,] 0.00794897 0.0000000 4.0000000 8.00000000 10.0000000 #> [2,] 0.10589532 0.2360636 0.0000000 0.00000000  0.0000000 #> [3,] 0.00000000 0.1030530 0.2807865 0.00000000  0.0000000 #> [4,] 0.00000000 0.0000000 0.1883105 0.62282892  0.0000000 #> [5,] 0.00000000 0.0000000 0.0000000 0.08604455  0.9653569 #>  #> $A_list[[9]] #>           [,1]     [,2]       [,3]      [,4]       [,5] #> [1,] 0.1495233 0.000000 4.00000000 8.0000000 10.0000000 #> [2,] 0.1741336 0.426369 0.00000000 0.0000000  0.0000000 #> [3,] 0.0000000 0.136707 0.62072487 0.0000000  0.0000000 #> [4,] 0.0000000 0.000000 0.06783148 0.1980795  0.0000000 #> [5,] 0.0000000 0.000000 0.00000000 0.5218206  0.7994516 #>  #> $A_list[[10]] #>            [,1]       [,2]       [,3]       [,4]       [,5] #> [1,] 0.04831774 0.00000000 4.00000000 8.00000000 10.0000000 #> [2,] 0.06775510 0.03037236 0.00000000 0.00000000  0.0000000 #> [3,] 0.00000000 0.37177964 0.09800894 0.00000000  0.0000000 #> [4,] 0.00000000 0.00000000 0.33187578 0.74345426  0.0000000 #> [5,] 0.00000000 0.00000000 0.00000000 0.01656937  0.7731065 #>  #>  #> $U_list #> $U_list[[1]] #>           [,1]       [,2]       [,3]      [,4]     [,5] #> [1,] 0.2025021 0.00000000 0.00000000 0.0000000 0.000000 #> [2,] 0.1808410 0.51560726 0.00000000 0.0000000 0.000000 #> [3,] 0.0000000 0.05938074 0.69893955 0.0000000 0.000000 #> [4,] 0.0000000 0.00000000 0.04270201 0.1153077 0.000000 #> [5,] 0.0000000 0.00000000 0.00000000 0.6563415 0.905483 #>  #> $U_list[[2]] #>           [,1]       [,2]       [,3]      [,4]      [,5] #> [1,] 0.3492059 0.00000000 0.00000000 0.0000000 0.0000000 #> [2,] 0.2623854 0.59588086 0.00000000 0.0000000 0.0000000 #> [3,] 0.0000000 0.02204176 0.03327729 0.0000000 0.0000000 #> [4,] 0.0000000 0.00000000 0.64881290 0.1459793 0.0000000 #> [5,] 0.0000000 0.00000000 0.00000000 0.6109135 0.9411863 #>  #> $U_list[[3]] #>           [,1]      [,2]       [,3]      [,4]     [,5] #> [1,] 0.0100986 0.0000000 0.00000000 0.0000000 0.000000 #> [2,] 0.2816060 0.3421699 0.00000000 0.0000000 0.000000 #> [3,] 0.0000000 0.2403473 0.60176000 0.0000000 0.000000 #> [4,] 0.0000000 0.0000000 0.01202352 0.5052573 0.000000 #> [5,] 0.0000000 0.0000000 0.00000000 0.2482741 0.975591 #>  #> $U_list[[4]] #>            [,1]       [,2]      [,3]      [,4]      [,5] #> [1,] 0.05277117 0.00000000 0.0000000 0.0000000 0.0000000 #> [2,] 0.14635732 0.14395871 0.0000000 0.0000000 0.0000000 #> [3,] 0.00000000 0.09478692 0.2766104 0.0000000 0.0000000 #> [4,] 0.00000000 0.00000000 0.6115977 0.1849629 0.0000000 #> [5,] 0.00000000 0.00000000 0.0000000 0.7926018 0.9830451 #>  #> $U_list[[5]] #>           [,1]       [,2]      [,3]      [,4]     [,5] #> [1,] 0.2695917 0.00000000 0.0000000 0.0000000 0.000000 #> [2,] 0.2267870 0.45112437 0.0000000 0.0000000 0.000000 #> [3,] 0.0000000 0.05989263 0.3118949 0.0000000 0.000000 #> [4,] 0.0000000 0.00000000 0.3091554 0.2289075 0.000000 #> [5,] 0.0000000 0.00000000 0.0000000 0.6927089 0.956369 #>  #> $U_list[[6]] #>           [,1]      [,2]      [,3]       [,4]      [,5] #> [1,] 0.2788292 0.0000000 0.0000000 0.00000000 0.0000000 #> [2,] 0.0816387 0.2433186 0.0000000 0.00000000 0.0000000 #> [3,] 0.0000000 0.3089479 0.1000315 0.00000000 0.0000000 #> [4,] 0.0000000 0.0000000 0.4670093 0.73745701 0.0000000 #> [5,] 0.0000000 0.0000000 0.0000000 0.04978961 0.8887938 #>  #> $U_list[[7]] #>           [,1]      [,2]       [,3]      [,4]      [,5] #> [1,] 0.2772425 0.0000000 0.00000000 0.0000000 0.0000000 #> [2,] 0.1276093 0.4284850 0.00000000 0.0000000 0.0000000 #> [3,] 0.0000000 0.1104893 0.05017521 0.0000000 0.0000000 #> [4,] 0.0000000 0.0000000 0.60407149 0.1454031 0.0000000 #> [5,] 0.0000000 0.0000000 0.00000000 0.7206787 0.8721605 #>  #> $U_list[[8]] #>            [,1]      [,2]      [,3]       [,4]      [,5] #> [1,] 0.00794897 0.0000000 0.0000000 0.00000000 0.0000000 #> [2,] 0.10589532 0.2360636 0.0000000 0.00000000 0.0000000 #> [3,] 0.00000000 0.1030530 0.2807865 0.00000000 0.0000000 #> [4,] 0.00000000 0.0000000 0.1883105 0.62282892 0.0000000 #> [5,] 0.00000000 0.0000000 0.0000000 0.08604455 0.9653569 #>  #> $U_list[[9]] #>           [,1]     [,2]       [,3]      [,4]      [,5] #> [1,] 0.1495233 0.000000 0.00000000 0.0000000 0.0000000 #> [2,] 0.1741336 0.426369 0.00000000 0.0000000 0.0000000 #> [3,] 0.0000000 0.136707 0.62072487 0.0000000 0.0000000 #> [4,] 0.0000000 0.000000 0.06783148 0.1980795 0.0000000 #> [5,] 0.0000000 0.000000 0.00000000 0.5218206 0.7994516 #>  #> $U_list[[10]] #>            [,1]       [,2]       [,3]       [,4]      [,5] #> [1,] 0.04831774 0.00000000 0.00000000 0.00000000 0.0000000 #> [2,] 0.06775510 0.03037236 0.00000000 0.00000000 0.0000000 #> [3,] 0.00000000 0.37177964 0.09800894 0.00000000 0.0000000 #> [4,] 0.00000000 0.00000000 0.33187578 0.74345426 0.0000000 #> [5,] 0.00000000 0.00000000 0.00000000 0.01656937 0.7731065 #>  #>  #> $F_list #> $F_list[[1]] #>      [,1] [,2] [,3] [,4] [,5] #> [1,]    0    0    4    8   10 #> [2,]    0    0    0    0    0 #> [3,]    0    0    0    0    0 #> [4,]    0    0    0    0    0 #> [5,]    0    0    0    0    0 #>  #> $F_list[[2]] #>      [,1] [,2] [,3] [,4] [,5] #> [1,]    0    0    4    8   10 #> [2,]    0    0    0    0    0 #> [3,]    0    0    0    0    0 #> [4,]    0    0    0    0    0 #> [5,]    0    0    0    0    0 #>  #> $F_list[[3]] #>      [,1] [,2] [,3] [,4] [,5] #> [1,]    0    0    4    8   10 #> [2,]    0    0    0    0    0 #> [3,]    0    0    0    0    0 #> [4,]    0    0    0    0    0 #> [5,]    0    0    0    0    0 #>  #> $F_list[[4]] #>      [,1] [,2] [,3] [,4] [,5] #> [1,]    0    0    4    8   10 #> [2,]    0    0    0    0    0 #> [3,]    0    0    0    0    0 #> [4,]    0    0    0    0    0 #> [5,]    0    0    0    0    0 #>  #> $F_list[[5]] #>      [,1] [,2] [,3] [,4] [,5] #> [1,]    0    0    4    8   10 #> [2,]    0    0    0    0    0 #> [3,]    0    0    0    0    0 #> [4,]    0    0    0    0    0 #> [5,]    0    0    0    0    0 #>  #> $F_list[[6]] #>      [,1] [,2] [,3] [,4] [,5] #> [1,]    0    0    4    8   10 #> [2,]    0    0    0    0    0 #> [3,]    0    0    0    0    0 #> [4,]    0    0    0    0    0 #> [5,]    0    0    0    0    0 #>  #> $F_list[[7]] #>      [,1] [,2] [,3] [,4] [,5] #> [1,]    0    0    4    8   10 #> [2,]    0    0    0    0    0 #> [3,]    0    0    0    0    0 #> [4,]    0    0    0    0    0 #> [5,]    0    0    0    0    0 #>  #> $F_list[[8]] #>      [,1] [,2] [,3] [,4] [,5] #> [1,]    0    0    4    8   10 #> [2,]    0    0    0    0    0 #> [3,]    0    0    0    0    0 #> [4,]    0    0    0    0    0 #> [5,]    0    0    0    0    0 #>  #> $F_list[[9]] #>      [,1] [,2] [,3] [,4] [,5] #> [1,]    0    0    4    8   10 #> [2,]    0    0    0    0    0 #> [3,]    0    0    0    0    0 #> [4,]    0    0    0    0    0 #> [5,]    0    0    0    0    0 #>  #> $F_list[[10]] #>      [,1] [,2] [,3] [,4] [,5] #> [1,]    0    0    4    8   10 #> [2,]    0    0    0    0    0 #> [3,]    0    0    0    0    0 #> [4,]    0    0    0    0    0 #> [5,]    0    0    0    0    0 #>  #>   # As above, but using popdemo::eigs function instead of popbio::lambda # to illustrate use of argument library(popdemo) #> Welcome to popdemo! This is version 1.3-0 #> Use ?popdemo for an intro, or browseVignettes('popdemo') for vignettes #> Citation for popdemo is here: doi.org/10.1111/j.2041-210X.2012.00222.x #> Development and legacy versions are here: github.com/iainmstott/popdemo constrain_df <- data.frame(   fun = \"eigs\", arg = \"lambda\", lower = 0.9, upper =     1.1 ) generate_mpm_set(   n = 10, n_stages = 5, fecundity = c(0, 0, 4, 8, 10),   archetype = 4, constraint = constrain_df, as_compadre = FALSE ) #> Warning: 'generate_mpm_set' is deprecated. #> Use 'rand_lefko_set' instead. #> See help(\"Deprecated\") #> Warning: 'random_mpm' is deprecated. #> Use 'rand_lefko_mpm' instead. #> See help(\"Deprecated\") #> Warning: 'random_mpm' is deprecated. #> Use 'rand_lefko_mpm' instead. #> See help(\"Deprecated\") #> Warning: 'random_mpm' is deprecated. #> Use 'rand_lefko_mpm' instead. #> See help(\"Deprecated\") #> Warning: 'random_mpm' is deprecated. #> Use 'rand_lefko_mpm' instead. #> See help(\"Deprecated\") #> Warning: 'random_mpm' is deprecated. #> Use 'rand_lefko_mpm' instead. #> See help(\"Deprecated\") #> Warning: 'random_mpm' is deprecated. #> Use 'rand_lefko_mpm' instead. #> See help(\"Deprecated\") #> Warning: 'random_mpm' is deprecated. #> Use 'rand_lefko_mpm' instead. #> See help(\"Deprecated\") #> Warning: 'random_mpm' is deprecated. #> Use 'rand_lefko_mpm' instead. #> See help(\"Deprecated\") #> Warning: 'random_mpm' is deprecated. #> Use 'rand_lefko_mpm' instead. #> See help(\"Deprecated\") #> Warning: 'random_mpm' is deprecated. #> Use 'rand_lefko_mpm' instead. #> See help(\"Deprecated\") #> Warning: 'random_mpm' is deprecated. #> Use 'rand_lefko_mpm' instead. #> See help(\"Deprecated\") #> Warning: 'random_mpm' is deprecated. #> Use 'rand_lefko_mpm' instead. #> See help(\"Deprecated\") #> Warning: 'random_mpm' is deprecated. #> Use 'rand_lefko_mpm' instead. #> See help(\"Deprecated\") #> Warning: 'random_mpm' is deprecated. #> Use 'rand_lefko_mpm' instead. #> See help(\"Deprecated\") #> Warning: 'random_mpm' is deprecated. #> Use 'rand_lefko_mpm' instead. #> See help(\"Deprecated\") #> Warning: 'random_mpm' is deprecated. #> Use 'rand_lefko_mpm' instead. #> See help(\"Deprecated\") #> Warning: 'random_mpm' is deprecated. #> Use 'rand_lefko_mpm' instead. #> See help(\"Deprecated\") #> Warning: 'random_mpm' is deprecated. #> Use 'rand_lefko_mpm' instead. #> See help(\"Deprecated\") #> Warning: 'random_mpm' is deprecated. #> Use 'rand_lefko_mpm' instead. #> See help(\"Deprecated\") #> Warning: 'random_mpm' is deprecated. #> Use 'rand_lefko_mpm' instead. #> See help(\"Deprecated\") #> Warning: 'random_mpm' is deprecated. #> Use 'rand_lefko_mpm' instead. #> See help(\"Deprecated\") #> Warning: 'random_mpm' is deprecated. #> Use 'rand_lefko_mpm' instead. #> See help(\"Deprecated\") #> Warning: 'random_mpm' is deprecated. #> Use 'rand_lefko_mpm' instead. #> See help(\"Deprecated\") #> Warning: 'random_mpm' is deprecated. #> Use 'rand_lefko_mpm' instead. #> See help(\"Deprecated\") #> Warning: 'random_mpm' is deprecated. #> Use 'rand_lefko_mpm' instead. #> See help(\"Deprecated\") #> Warning: 'random_mpm' is deprecated. #> Use 'rand_lefko_mpm' instead. #> See help(\"Deprecated\") #> Warning: 'random_mpm' is deprecated. #> Use 'rand_lefko_mpm' instead. #> See help(\"Deprecated\") #> $A_list #> $A_list[[1]] #>            [,1]      [,2]      [,3]      [,4]       [,5] #> [1,] 0.33328577 0.0000000 4.0000000 8.0000000 10.0000000 #> [2,] 0.06377826 0.2498128 0.0000000 0.0000000  0.0000000 #> [3,] 0.00000000 0.3337334 0.5963528 0.0000000  0.0000000 #> [4,] 0.00000000 0.0000000 0.1693849 0.5795012  0.0000000 #> [5,] 0.00000000 0.0000000 0.0000000 0.2212670  0.8103362 #>  #> $A_list[[2]] #>           [,1]       [,2]       [,3]       [,4]       [,5] #> [1,] 0.0239377 0.00000000 4.00000000 8.00000000 10.0000000 #> [2,] 0.0366482 0.04343731 0.00000000 0.00000000  0.0000000 #> [3,] 0.0000000 0.68395612 0.68478775 0.00000000  0.0000000 #> [4,] 0.0000000 0.00000000 0.08214221 0.06041167  0.0000000 #> [5,] 0.0000000 0.00000000 0.00000000 0.82870382  0.9361283 #>  #> $A_list[[3]] #>            [,1]      [,2]      [,3]       [,4]       [,5] #> [1,] 0.03354061 0.0000000 4.0000000 8.00000000 10.0000000 #> [2,] 0.24257199 0.1737578 0.0000000 0.00000000  0.0000000 #> [3,] 0.00000000 0.1323195 0.2086060 0.00000000  0.0000000 #> [4,] 0.00000000 0.0000000 0.3520131 0.61162941  0.0000000 #> [5,] 0.00000000 0.0000000 0.0000000 0.06355464  0.7634507 #>  #> $A_list[[4]] #>            [,1]      [,2]      [,3]      [,4]       [,5] #> [1,] 0.18298502 0.0000000 4.0000000 8.0000000 10.0000000 #> [2,] 0.05516901 0.0637293 0.0000000 0.0000000  0.0000000 #> [3,] 0.00000000 0.3666609 0.3365942 0.0000000  0.0000000 #> [4,] 0.00000000 0.0000000 0.3601747 0.2711895  0.0000000 #> [5,] 0.00000000 0.0000000 0.0000000 0.4848073  0.9864156 #>  #> $A_list[[5]] #>            [,1]      [,2]       [,3]      [,4]       [,5] #> [1,] 0.00572345 0.0000000 4.00000000 8.0000000 10.0000000 #> [2,] 0.25867680 0.1849481 0.00000000 0.0000000  0.0000000 #> [3,] 0.00000000 0.2763296 0.47875737 0.0000000  0.0000000 #> [4,] 0.00000000 0.0000000 0.04194771 0.2885805  0.0000000 #> [5,] 0.00000000 0.0000000 0.00000000 0.5292559  0.8627223 #>  #> $A_list[[6]] #>           [,1]       [,2]      [,3]       [,4]       [,5] #> [1,] 0.1689392 0.00000000 4.0000000 8.00000000 10.0000000 #> [2,] 0.2063822 0.30596227 0.0000000 0.00000000  0.0000000 #> [3,] 0.0000000 0.07818665 0.1925666 0.00000000  0.0000000 #> [4,] 0.0000000 0.00000000 0.3427810 0.01826475  0.0000000 #> [5,] 0.0000000 0.00000000 0.0000000 0.63827242  0.9756126 #>  #> $A_list[[7]] #>            [,1]      [,2]       [,3]      [,4]       [,5] #> [1,] 0.00652138 0.0000000 4.00000000 8.0000000 10.0000000 #> [2,] 0.00545548 0.2302399 0.00000000 0.0000000  0.0000000 #> [3,] 0.00000000 0.3754500 0.65618224 0.0000000  0.0000000 #> [4,] 0.00000000 0.0000000 0.01014227 0.6273468  0.0000000 #> [5,] 0.00000000 0.0000000 0.00000000 0.3247017  0.9748711 #>  #> $A_list[[8]] #>           [,1]      [,2]      [,3]      [,4]       [,5] #> [1,] 0.1884203 0.0000000 4.0000000 8.0000000 10.0000000 #> [2,] 0.1412555 0.5157395 0.0000000 0.0000000  0.0000000 #> [3,] 0.0000000 0.1011372 0.3102842 0.0000000  0.0000000 #> [4,] 0.0000000 0.0000000 0.3591664 0.6594515  0.0000000 #> [5,] 0.0000000 0.0000000 0.0000000 0.1373212  0.8799535 #>  #> $A_list[[9]] #>            [,1]       [,2]      [,3]      [,4]       [,5] #> [1,] 0.09476255 0.00000000 4.0000000 8.0000000 10.0000000 #> [2,] 0.07831552 0.54792290 0.0000000 0.0000000  0.0000000 #> [3,] 0.00000000 0.09611724 0.5001257 0.0000000  0.0000000 #> [4,] 0.00000000 0.00000000 0.1557204 0.5926258  0.0000000 #> [5,] 0.00000000 0.00000000 0.0000000 0.1258167  0.8132592 #>  #> $A_list[[10]] #>            [,1]      [,2]     [,3]       [,4]       [,5] #> [1,] 0.05344835 0.0000000 4.000000 8.00000000 10.0000000 #> [2,] 0.19325338 0.1600322 0.000000 0.00000000  0.0000000 #> [3,] 0.00000000 0.1377219 0.301253 0.00000000  0.0000000 #> [4,] 0.00000000 0.0000000 0.336472 0.65045350  0.0000000 #> [5,] 0.00000000 0.0000000 0.000000 0.08209705  0.8151836 #>  #>  #> $U_list #> $U_list[[1]] #>            [,1]      [,2]      [,3]      [,4]      [,5] #> [1,] 0.33328577 0.0000000 0.0000000 0.0000000 0.0000000 #> [2,] 0.06377826 0.2498128 0.0000000 0.0000000 0.0000000 #> [3,] 0.00000000 0.3337334 0.5963528 0.0000000 0.0000000 #> [4,] 0.00000000 0.0000000 0.1693849 0.5795012 0.0000000 #> [5,] 0.00000000 0.0000000 0.0000000 0.2212670 0.8103362 #>  #> $U_list[[2]] #>           [,1]       [,2]       [,3]       [,4]      [,5] #> [1,] 0.0239377 0.00000000 0.00000000 0.00000000 0.0000000 #> [2,] 0.0366482 0.04343731 0.00000000 0.00000000 0.0000000 #> [3,] 0.0000000 0.68395612 0.68478775 0.00000000 0.0000000 #> [4,] 0.0000000 0.00000000 0.08214221 0.06041167 0.0000000 #> [5,] 0.0000000 0.00000000 0.00000000 0.82870382 0.9361283 #>  #> $U_list[[3]] #>            [,1]      [,2]      [,3]       [,4]      [,5] #> [1,] 0.03354061 0.0000000 0.0000000 0.00000000 0.0000000 #> [2,] 0.24257199 0.1737578 0.0000000 0.00000000 0.0000000 #> [3,] 0.00000000 0.1323195 0.2086060 0.00000000 0.0000000 #> [4,] 0.00000000 0.0000000 0.3520131 0.61162941 0.0000000 #> [5,] 0.00000000 0.0000000 0.0000000 0.06355464 0.7634507 #>  #> $U_list[[4]] #>            [,1]      [,2]      [,3]      [,4]      [,5] #> [1,] 0.18298502 0.0000000 0.0000000 0.0000000 0.0000000 #> [2,] 0.05516901 0.0637293 0.0000000 0.0000000 0.0000000 #> [3,] 0.00000000 0.3666609 0.3365942 0.0000000 0.0000000 #> [4,] 0.00000000 0.0000000 0.3601747 0.2711895 0.0000000 #> [5,] 0.00000000 0.0000000 0.0000000 0.4848073 0.9864156 #>  #> $U_list[[5]] #>            [,1]      [,2]       [,3]      [,4]      [,5] #> [1,] 0.00572345 0.0000000 0.00000000 0.0000000 0.0000000 #> [2,] 0.25867680 0.1849481 0.00000000 0.0000000 0.0000000 #> [3,] 0.00000000 0.2763296 0.47875737 0.0000000 0.0000000 #> [4,] 0.00000000 0.0000000 0.04194771 0.2885805 0.0000000 #> [5,] 0.00000000 0.0000000 0.00000000 0.5292559 0.8627223 #>  #> $U_list[[6]] #>           [,1]       [,2]      [,3]       [,4]      [,5] #> [1,] 0.1689392 0.00000000 0.0000000 0.00000000 0.0000000 #> [2,] 0.2063822 0.30596227 0.0000000 0.00000000 0.0000000 #> [3,] 0.0000000 0.07818665 0.1925666 0.00000000 0.0000000 #> [4,] 0.0000000 0.00000000 0.3427810 0.01826475 0.0000000 #> [5,] 0.0000000 0.00000000 0.0000000 0.63827242 0.9756126 #>  #> $U_list[[7]] #>            [,1]      [,2]       [,3]      [,4]      [,5] #> [1,] 0.00652138 0.0000000 0.00000000 0.0000000 0.0000000 #> [2,] 0.00545548 0.2302399 0.00000000 0.0000000 0.0000000 #> [3,] 0.00000000 0.3754500 0.65618224 0.0000000 0.0000000 #> [4,] 0.00000000 0.0000000 0.01014227 0.6273468 0.0000000 #> [5,] 0.00000000 0.0000000 0.00000000 0.3247017 0.9748711 #>  #> $U_list[[8]] #>           [,1]      [,2]      [,3]      [,4]      [,5] #> [1,] 0.1884203 0.0000000 0.0000000 0.0000000 0.0000000 #> [2,] 0.1412555 0.5157395 0.0000000 0.0000000 0.0000000 #> [3,] 0.0000000 0.1011372 0.3102842 0.0000000 0.0000000 #> [4,] 0.0000000 0.0000000 0.3591664 0.6594515 0.0000000 #> [5,] 0.0000000 0.0000000 0.0000000 0.1373212 0.8799535 #>  #> $U_list[[9]] #>            [,1]       [,2]      [,3]      [,4]      [,5] #> [1,] 0.09476255 0.00000000 0.0000000 0.0000000 0.0000000 #> [2,] 0.07831552 0.54792290 0.0000000 0.0000000 0.0000000 #> [3,] 0.00000000 0.09611724 0.5001257 0.0000000 0.0000000 #> [4,] 0.00000000 0.00000000 0.1557204 0.5926258 0.0000000 #> [5,] 0.00000000 0.00000000 0.0000000 0.1258167 0.8132592 #>  #> $U_list[[10]] #>            [,1]      [,2]     [,3]       [,4]      [,5] #> [1,] 0.05344835 0.0000000 0.000000 0.00000000 0.0000000 #> [2,] 0.19325338 0.1600322 0.000000 0.00000000 0.0000000 #> [3,] 0.00000000 0.1377219 0.301253 0.00000000 0.0000000 #> [4,] 0.00000000 0.0000000 0.336472 0.65045350 0.0000000 #> [5,] 0.00000000 0.0000000 0.000000 0.08209705 0.8151836 #>  #>  #> $F_list #> $F_list[[1]] #>      [,1] [,2] [,3] [,4] [,5] #> [1,]    0    0    4    8   10 #> [2,]    0    0    0    0    0 #> [3,]    0    0    0    0    0 #> [4,]    0    0    0    0    0 #> [5,]    0    0    0    0    0 #>  #> $F_list[[2]] #>      [,1] [,2] [,3] [,4] [,5] #> [1,]    0    0    4    8   10 #> [2,]    0    0    0    0    0 #> [3,]    0    0    0    0    0 #> [4,]    0    0    0    0    0 #> [5,]    0    0    0    0    0 #>  #> $F_list[[3]] #>      [,1] [,2] [,3] [,4] [,5] #> [1,]    0    0    4    8   10 #> [2,]    0    0    0    0    0 #> [3,]    0    0    0    0    0 #> [4,]    0    0    0    0    0 #> [5,]    0    0    0    0    0 #>  #> $F_list[[4]] #>      [,1] [,2] [,3] [,4] [,5] #> [1,]    0    0    4    8   10 #> [2,]    0    0    0    0    0 #> [3,]    0    0    0    0    0 #> [4,]    0    0    0    0    0 #> [5,]    0    0    0    0    0 #>  #> $F_list[[5]] #>      [,1] [,2] [,3] [,4] [,5] #> [1,]    0    0    4    8   10 #> [2,]    0    0    0    0    0 #> [3,]    0    0    0    0    0 #> [4,]    0    0    0    0    0 #> [5,]    0    0    0    0    0 #>  #> $F_list[[6]] #>      [,1] [,2] [,3] [,4] [,5] #> [1,]    0    0    4    8   10 #> [2,]    0    0    0    0    0 #> [3,]    0    0    0    0    0 #> [4,]    0    0    0    0    0 #> [5,]    0    0    0    0    0 #>  #> $F_list[[7]] #>      [,1] [,2] [,3] [,4] [,5] #> [1,]    0    0    4    8   10 #> [2,]    0    0    0    0    0 #> [3,]    0    0    0    0    0 #> [4,]    0    0    0    0    0 #> [5,]    0    0    0    0    0 #>  #> $F_list[[8]] #>      [,1] [,2] [,3] [,4] [,5] #> [1,]    0    0    4    8   10 #> [2,]    0    0    0    0    0 #> [3,]    0    0    0    0    0 #> [4,]    0    0    0    0    0 #> [5,]    0    0    0    0    0 #>  #> $F_list[[9]] #>      [,1] [,2] [,3] [,4] [,5] #> [1,]    0    0    4    8   10 #> [2,]    0    0    0    0    0 #> [3,]    0    0    0    0    0 #> [4,]    0    0    0    0    0 #> [5,]    0    0    0    0    0 #>  #> $F_list[[10]] #>      [,1] [,2] [,3] [,4] [,5] #> [1,]    0    0    4    8   10 #> [2,]    0    0    0    0    0 #> [3,]    0    0    0    0    0 #> [4,]    0    0    0    0    0 #> [5,]    0    0    0    0    0 #>  #>   # Multiple constraints # Constrain outputs to A matrices with lambda between 0.9 and 1.1, generation # time between 3 and 5 and damping ratio between 1 and 7. library(popbio) constrain_df <- data.frame(   fun = c(\"lambda\", \"generation.time\", \"damping.ratio\"),   arg = c(NA, NA, NA),   lower = c(0.9, 3.0, 1.0),   upper = c(1.1, 5.0, 7.0) ) generate_mpm_set(   n = 10, n_stages = 5, fecundity = c(0, 0, 4, 8, 10),   archetype = 4, constraint = constrain_df, as_compadre = FALSE ) #> Warning: 'generate_mpm_set' is deprecated. #> Use 'rand_lefko_set' instead. #> See help(\"Deprecated\") #> Warning: 'random_mpm' is deprecated. #> Use 'rand_lefko_mpm' instead. #> See help(\"Deprecated\") #> Warning: 'random_mpm' is deprecated. #> Use 'rand_lefko_mpm' instead. #> See help(\"Deprecated\") #> Warning: 'random_mpm' is deprecated. #> Use 'rand_lefko_mpm' instead. #> See help(\"Deprecated\") #> Warning: 'random_mpm' is deprecated. #> Use 'rand_lefko_mpm' instead. #> See help(\"Deprecated\") #> Warning: 'random_mpm' is deprecated. #> Use 'rand_lefko_mpm' instead. #> See help(\"Deprecated\") #> Warning: 'random_mpm' is deprecated. #> Use 'rand_lefko_mpm' instead. #> See help(\"Deprecated\") #> Warning: 'random_mpm' is deprecated. #> Use 'rand_lefko_mpm' instead. #> See help(\"Deprecated\") #> Warning: 'random_mpm' is deprecated. #> Use 'rand_lefko_mpm' instead. #> See help(\"Deprecated\") #> Warning: 'random_mpm' is deprecated. #> Use 'rand_lefko_mpm' instead. #> See help(\"Deprecated\") #> Warning: 'random_mpm' is deprecated. #> Use 'rand_lefko_mpm' instead. #> See help(\"Deprecated\") #> Warning: 'random_mpm' is deprecated. #> Use 'rand_lefko_mpm' instead. #> See help(\"Deprecated\") #> Warning: 'random_mpm' is deprecated. #> Use 'rand_lefko_mpm' instead. #> See help(\"Deprecated\") #> Warning: 'random_mpm' is deprecated. #> Use 'rand_lefko_mpm' instead. #> See help(\"Deprecated\") #> Warning: 'random_mpm' is deprecated. #> Use 'rand_lefko_mpm' instead. #> See help(\"Deprecated\") #> Warning: 'random_mpm' is deprecated. #> Use 'rand_lefko_mpm' instead. #> See help(\"Deprecated\") #> $A_list #> $A_list[[1]] #>           [,1]      [,2]      [,3]      [,4]       [,5] #> [1,] 0.2215161 0.0000000 4.0000000 8.0000000 10.0000000 #> [2,] 0.1628780 0.2398348 0.0000000 0.0000000  0.0000000 #> [3,] 0.0000000 0.4176027 0.5451896 0.0000000  0.0000000 #> [4,] 0.0000000 0.0000000 0.2235974 0.2776922  0.0000000 #> [5,] 0.0000000 0.0000000 0.0000000 0.5255625  0.9682391 #>  #> $A_list[[2]] #>           [,1]        [,2]      [,3]      [,4]       [,5] #> [1,] 0.2633244 0.000000000 4.0000000 8.0000000 10.0000000 #> [2,] 0.2108113 0.532344404 0.0000000 0.0000000  0.0000000 #> [3,] 0.0000000 0.004494054 0.1274034 0.0000000  0.0000000 #> [4,] 0.0000000 0.000000000 0.5361963 0.1105499  0.0000000 #> [5,] 0.0000000 0.000000000 0.0000000 0.5715804  0.8004599 #>  #> $A_list[[3]] #>             [,1]      [,2]      [,3]      [,4]       [,5] #> [1,] 0.036019608 0.0000000 4.0000000 8.0000000 10.0000000 #> [2,] 0.007165058 0.1339785 0.0000000 0.0000000  0.0000000 #> [3,] 0.000000000 0.4912836 0.7179049 0.0000000  0.0000000 #> [4,] 0.000000000 0.0000000 0.1357687 0.4106779  0.0000000 #> [5,] 0.000000000 0.0000000 0.0000000 0.5146034  0.9286131 #>  #> $A_list[[4]] #>           [,1]      [,2]      [,3]      [,4]       [,5] #> [1,] 0.2242099 0.0000000 4.0000000 8.0000000 10.0000000 #> [2,] 0.4212880 0.2347628 0.0000000 0.0000000  0.0000000 #> [3,] 0.0000000 0.4932071 0.5667867 0.0000000  0.0000000 #> [4,] 0.0000000 0.0000000 0.3834741 0.4861952  0.0000000 #> [5,] 0.0000000 0.0000000 0.0000000 0.4657886  0.9670306 #>  #> $A_list[[5]] #>            [,1]       [,2]      [,3]      [,4]       [,5] #> [1,] 0.01632312 0.00000000 4.0000000 8.0000000 10.0000000 #> [2,] 0.16488654 0.21741849 0.0000000 0.0000000  0.0000000 #> [3,] 0.00000000 0.04855655 0.3199929 0.0000000  0.0000000 #> [4,] 0.00000000 0.00000000 0.1293828 0.3595308  0.0000000 #> [5,] 0.00000000 0.00000000 0.0000000 0.4448042  0.8932768 #>  #> $A_list[[6]] #>           [,1]      [,2]       [,3]      [,4]       [,5] #> [1,] 0.4144249 0.0000000 4.00000000 8.0000000 10.0000000 #> [2,] 0.1257273 0.3536676 0.00000000 0.0000000  0.0000000 #> [3,] 0.0000000 0.2470648 0.73727607 0.0000000  0.0000000 #> [4,] 0.0000000 0.0000000 0.06073812 0.1518907  0.0000000 #> [5,] 0.0000000 0.0000000 0.00000000 0.6807092  0.8370672 #>  #> $A_list[[7]] #>           [,1]       [,2]      [,3]       [,4]       [,5] #> [1,] 0.1172182 0.00000000 4.0000000 8.00000000 10.0000000 #> [2,] 0.2959306 0.58901722 0.0000000 0.00000000  0.0000000 #> [3,] 0.0000000 0.04150199 0.1807843 0.00000000  0.0000000 #> [4,] 0.0000000 0.00000000 0.6355638 0.07568457  0.0000000 #> [5,] 0.0000000 0.00000000 0.0000000 0.90359482  0.9831803 #>  #> $A_list[[8]] #>           [,1]      [,2]      [,3]      [,4]       [,5] #> [1,] 0.2851186 0.0000000 4.0000000 8.0000000 10.0000000 #> [2,] 0.4914640 0.5399783 0.0000000 0.0000000  0.0000000 #> [3,] 0.0000000 0.3387130 0.2868371 0.0000000  0.0000000 #> [4,] 0.0000000 0.0000000 0.6329236 0.6625216  0.0000000 #> [5,] 0.0000000 0.0000000 0.0000000 0.3037399  0.9721035 #>  #> $A_list[[9]] #>           [,1]      [,2]       [,3]      [,4]       [,5] #> [1,] 0.2791730 0.0000000 4.00000000 8.0000000 10.0000000 #> [2,] 0.2425753 0.3766383 0.00000000 0.0000000  0.0000000 #> [3,] 0.0000000 0.2745754 0.83467374 0.0000000  0.0000000 #> [4,] 0.0000000 0.0000000 0.01164569 0.4305712  0.0000000 #> [5,] 0.0000000 0.0000000 0.00000000 0.4928974  0.9476323 #>  #> $A_list[[10]] #>           [,1]       [,2]      [,3]       [,4]       [,5] #> [1,] 0.1053867 0.00000000 4.0000000 8.00000000 10.0000000 #> [2,] 0.4436386 0.53789037 0.0000000 0.00000000  0.0000000 #> [3,] 0.0000000 0.02305909 0.1275618 0.00000000  0.0000000 #> [4,] 0.0000000 0.00000000 0.7625399 0.08617495  0.0000000 #> [5,] 0.0000000 0.00000000 0.0000000 0.81587337  0.9278515 #>  #>  #> $U_list #> $U_list[[1]] #>           [,1]      [,2]      [,3]      [,4]      [,5] #> [1,] 0.2215161 0.0000000 0.0000000 0.0000000 0.0000000 #> [2,] 0.1628780 0.2398348 0.0000000 0.0000000 0.0000000 #> [3,] 0.0000000 0.4176027 0.5451896 0.0000000 0.0000000 #> [4,] 0.0000000 0.0000000 0.2235974 0.2776922 0.0000000 #> [5,] 0.0000000 0.0000000 0.0000000 0.5255625 0.9682391 #>  #> $U_list[[2]] #>           [,1]        [,2]      [,3]      [,4]      [,5] #> [1,] 0.2633244 0.000000000 0.0000000 0.0000000 0.0000000 #> [2,] 0.2108113 0.532344404 0.0000000 0.0000000 0.0000000 #> [3,] 0.0000000 0.004494054 0.1274034 0.0000000 0.0000000 #> [4,] 0.0000000 0.000000000 0.5361963 0.1105499 0.0000000 #> [5,] 0.0000000 0.000000000 0.0000000 0.5715804 0.8004599 #>  #> $U_list[[3]] #>             [,1]      [,2]      [,3]      [,4]      [,5] #> [1,] 0.036019608 0.0000000 0.0000000 0.0000000 0.0000000 #> [2,] 0.007165058 0.1339785 0.0000000 0.0000000 0.0000000 #> [3,] 0.000000000 0.4912836 0.7179049 0.0000000 0.0000000 #> [4,] 0.000000000 0.0000000 0.1357687 0.4106779 0.0000000 #> [5,] 0.000000000 0.0000000 0.0000000 0.5146034 0.9286131 #>  #> $U_list[[4]] #>           [,1]      [,2]      [,3]      [,4]      [,5] #> [1,] 0.2242099 0.0000000 0.0000000 0.0000000 0.0000000 #> [2,] 0.4212880 0.2347628 0.0000000 0.0000000 0.0000000 #> [3,] 0.0000000 0.4932071 0.5667867 0.0000000 0.0000000 #> [4,] 0.0000000 0.0000000 0.3834741 0.4861952 0.0000000 #> [5,] 0.0000000 0.0000000 0.0000000 0.4657886 0.9670306 #>  #> $U_list[[5]] #>            [,1]       [,2]      [,3]      [,4]      [,5] #> [1,] 0.01632312 0.00000000 0.0000000 0.0000000 0.0000000 #> [2,] 0.16488654 0.21741849 0.0000000 0.0000000 0.0000000 #> [3,] 0.00000000 0.04855655 0.3199929 0.0000000 0.0000000 #> [4,] 0.00000000 0.00000000 0.1293828 0.3595308 0.0000000 #> [5,] 0.00000000 0.00000000 0.0000000 0.4448042 0.8932768 #>  #> $U_list[[6]] #>           [,1]      [,2]       [,3]      [,4]      [,5] #> [1,] 0.4144249 0.0000000 0.00000000 0.0000000 0.0000000 #> [2,] 0.1257273 0.3536676 0.00000000 0.0000000 0.0000000 #> [3,] 0.0000000 0.2470648 0.73727607 0.0000000 0.0000000 #> [4,] 0.0000000 0.0000000 0.06073812 0.1518907 0.0000000 #> [5,] 0.0000000 0.0000000 0.00000000 0.6807092 0.8370672 #>  #> $U_list[[7]] #>           [,1]       [,2]      [,3]       [,4]      [,5] #> [1,] 0.1172182 0.00000000 0.0000000 0.00000000 0.0000000 #> [2,] 0.2959306 0.58901722 0.0000000 0.00000000 0.0000000 #> [3,] 0.0000000 0.04150199 0.1807843 0.00000000 0.0000000 #> [4,] 0.0000000 0.00000000 0.6355638 0.07568457 0.0000000 #> [5,] 0.0000000 0.00000000 0.0000000 0.90359482 0.9831803 #>  #> $U_list[[8]] #>           [,1]      [,2]      [,3]      [,4]      [,5] #> [1,] 0.2851186 0.0000000 0.0000000 0.0000000 0.0000000 #> [2,] 0.4914640 0.5399783 0.0000000 0.0000000 0.0000000 #> [3,] 0.0000000 0.3387130 0.2868371 0.0000000 0.0000000 #> [4,] 0.0000000 0.0000000 0.6329236 0.6625216 0.0000000 #> [5,] 0.0000000 0.0000000 0.0000000 0.3037399 0.9721035 #>  #> $U_list[[9]] #>           [,1]      [,2]       [,3]      [,4]      [,5] #> [1,] 0.2791730 0.0000000 0.00000000 0.0000000 0.0000000 #> [2,] 0.2425753 0.3766383 0.00000000 0.0000000 0.0000000 #> [3,] 0.0000000 0.2745754 0.83467374 0.0000000 0.0000000 #> [4,] 0.0000000 0.0000000 0.01164569 0.4305712 0.0000000 #> [5,] 0.0000000 0.0000000 0.00000000 0.4928974 0.9476323 #>  #> $U_list[[10]] #>           [,1]       [,2]      [,3]       [,4]      [,5] #> [1,] 0.1053867 0.00000000 0.0000000 0.00000000 0.0000000 #> [2,] 0.4436386 0.53789037 0.0000000 0.00000000 0.0000000 #> [3,] 0.0000000 0.02305909 0.1275618 0.00000000 0.0000000 #> [4,] 0.0000000 0.00000000 0.7625399 0.08617495 0.0000000 #> [5,] 0.0000000 0.00000000 0.0000000 0.81587337 0.9278515 #>  #>  #> $F_list #> $F_list[[1]] #>      [,1] [,2] [,3] [,4] [,5] #> [1,]    0    0    4    8   10 #> [2,]    0    0    0    0    0 #> [3,]    0    0    0    0    0 #> [4,]    0    0    0    0    0 #> [5,]    0    0    0    0    0 #>  #> $F_list[[2]] #>      [,1] [,2] [,3] [,4] [,5] #> [1,]    0    0    4    8   10 #> [2,]    0    0    0    0    0 #> [3,]    0    0    0    0    0 #> [4,]    0    0    0    0    0 #> [5,]    0    0    0    0    0 #>  #> $F_list[[3]] #>      [,1] [,2] [,3] [,4] [,5] #> [1,]    0    0    4    8   10 #> [2,]    0    0    0    0    0 #> [3,]    0    0    0    0    0 #> [4,]    0    0    0    0    0 #> [5,]    0    0    0    0    0 #>  #> $F_list[[4]] #>      [,1] [,2] [,3] [,4] [,5] #> [1,]    0    0    4    8   10 #> [2,]    0    0    0    0    0 #> [3,]    0    0    0    0    0 #> [4,]    0    0    0    0    0 #> [5,]    0    0    0    0    0 #>  #> $F_list[[5]] #>      [,1] [,2] [,3] [,4] [,5] #> [1,]    0    0    4    8   10 #> [2,]    0    0    0    0    0 #> [3,]    0    0    0    0    0 #> [4,]    0    0    0    0    0 #> [5,]    0    0    0    0    0 #>  #> $F_list[[6]] #>      [,1] [,2] [,3] [,4] [,5] #> [1,]    0    0    4    8   10 #> [2,]    0    0    0    0    0 #> [3,]    0    0    0    0    0 #> [4,]    0    0    0    0    0 #> [5,]    0    0    0    0    0 #>  #> $F_list[[7]] #>      [,1] [,2] [,3] [,4] [,5] #> [1,]    0    0    4    8   10 #> [2,]    0    0    0    0    0 #> [3,]    0    0    0    0    0 #> [4,]    0    0    0    0    0 #> [5,]    0    0    0    0    0 #>  #> $F_list[[8]] #>      [,1] [,2] [,3] [,4] [,5] #> [1,]    0    0    4    8   10 #> [2,]    0    0    0    0    0 #> [3,]    0    0    0    0    0 #> [4,]    0    0    0    0    0 #> [5,]    0    0    0    0    0 #>  #> $F_list[[9]] #>      [,1] [,2] [,3] [,4] [,5] #> [1,]    0    0    4    8   10 #> [2,]    0    0    0    0    0 #> [3,]    0    0    0    0    0 #> [4,]    0    0    0    0    0 #> [5,]    0    0    0    0    0 #>  #> $F_list[[10]] #>      [,1] [,2] [,3] [,4] [,5] #> [1,]    0    0    4    8   10 #> [2,]    0    0    0    0    0 #> [3,]    0    0    0    0    0 #> [4,]    0    0    0    0    0 #> [5,]    0    0    0    0    0 #>  #>"},{"path":"https://jonesor.github.io/mpmsim/reference/make_leslie_mpm.html","id":null,"dir":"Reference","previous_headings":"","what":"Create a Leslie matrix population model — make_leslie_mpm","title":"Create a Leslie matrix population model — make_leslie_mpm","text":"function creates Leslie matrix inputs number stages, fecundity (top row matrix), survival probability (value sub-diagonal).","code":""},{"path":"https://jonesor.github.io/mpmsim/reference/make_leslie_mpm.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create a Leslie matrix population model — make_leslie_mpm","text":"","code":"make_leslie_mpm(   survival = NULL,   fecundity = NULL,   n_stages = NULL,   lifetable = NULL,   split = FALSE )"},{"path":"https://jonesor.github.io/mpmsim/reference/make_leslie_mpm.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Create a Leslie matrix population model — make_leslie_mpm","text":"survival numeric value representing survival probability stage along lower -diagonal matrix, final value lower-right corner matrix. one value provided, applied survival elements. fecundity numeric vector length n_stages representing reproductive output stage. one value provided, applied fecundity elements. n_stages numeric value representing number stages matrix lifetable life table containing columns px (age-specific survival) fecundity (age-specific fecundity). split logical argument indicating whether output matrix split separate , U F matrices (= U + F).","code":""},{"path":"https://jonesor.github.io/mpmsim/reference/make_leslie_mpm.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Create a Leslie matrix population model — make_leslie_mpm","text":"matrix size n_stages x n_stages representing Leslie matrix","code":""},{"path":"https://jonesor.github.io/mpmsim/reference/make_leslie_mpm.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Create a Leslie matrix population model — make_leslie_mpm","text":"Note simulations assume post-breeding census, thus avoiding often overlooked issue unaccounted survival reproduction highlighted Kendall et al. (2019). Furthermore, simulations assume covariance among matrix elements (e.g. reproduction survival), therefore allow users capture trade offs directly. capability roadmapped future package release.","code":""},{"path":"https://jonesor.github.io/mpmsim/reference/make_leslie_mpm.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Create a Leslie matrix population model — make_leslie_mpm","text":"Caswell, H. (2001). Matrix Population Models: Construction, Analysis, Interpretation. Sinauer. Leslie, P. H. (1945). use matrices certain population mathematics. Biometrika, 33 (3), 183–212. Leslie, P. H. (1948). Notes Use Matrices Population Mathematics. Biometrika, 35(3-4), 213–245. Kendall, B. E., Fujiwara, M., Diaz-Lopez, J., Schneider, S., Voigt, J., & Wiesner, S. (2019). Persistent problems construction matrix population models. Ecological Modelling, 406, 33–43.","code":""},{"path":[]},{"path":"https://jonesor.github.io/mpmsim/reference/make_leslie_mpm.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Create a Leslie matrix population model — make_leslie_mpm","text":"Owen Jones jones@biology.sdu.dk","code":""},{"path":"https://jonesor.github.io/mpmsim/reference/make_leslie_mpm.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Create a Leslie matrix population model — make_leslie_mpm","text":"","code":"make_leslie_mpm(   survival = 0.5, fecundity = c(0.1, 0.2, 0.3),   n_stages = 3, split = FALSE ) #>      [,1] [,2] [,3] #> [1,]  0.1  0.2  0.3 #> [2,]  0.5  0.0  0.0 #> [3,]  0.0  0.5  0.5 make_leslie_mpm(   survival = c(0.5, 0.6, 0.7), fecundity = c(0.1, 0.2, 0.3),   n_stages = 3 ) #>      [,1] [,2] [,3] #> [1,]  0.1  0.2  0.3 #> [2,]  0.5  0.0  0.0 #> [3,]  0.0  0.6  0.7 make_leslie_mpm(   survival = seq(0.1, 0.7, length.out = 4), fecundity = 0.1,   n_stages = 4 ) #>      [,1] [,2] [,3] [,4] #> [1,]  0.1  0.1  0.1  0.1 #> [2,]  0.1  0.0  0.0  0.0 #> [3,]  0.0  0.3  0.0  0.0 #> [4,]  0.0  0.0  0.5  0.7 make_leslie_mpm(   survival = c(0.8, 0.3, 0.2, 0.1, 0.05), fecundity = 0.2,   n_stages = 5 ) #>      [,1] [,2] [,3] [,4] [,5] #> [1,]  0.2  0.2  0.2  0.2 0.20 #> [2,]  0.8  0.0  0.0  0.0 0.00 #> [3,]  0.0  0.3  0.0  0.0 0.00 #> [4,]  0.0  0.0  0.2  0.0 0.00 #> [5,]  0.0  0.0  0.0  0.1 0.05"},{"path":"https://jonesor.github.io/mpmsim/reference/model_survival.html","id":null,"dir":"Reference","previous_headings":"","what":"Model mortality hazard, survivorship and age-specific survival probability using a mortality model — model_survival","title":"Model mortality hazard, survivorship and age-specific survival probability using a mortality model — model_survival","text":"Generates actuarial life table based defined mortality model.","code":""},{"path":"https://jonesor.github.io/mpmsim/reference/model_survival.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Model mortality hazard, survivorship and age-specific survival probability using a mortality model — model_survival","text":"","code":"model_survival(params, age = NULL, model, truncate = 0.01)  model_mortality(params, age = NULL, model, truncate = 0.01)"},{"path":"https://jonesor.github.io/mpmsim/reference/model_survival.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Model mortality hazard, survivorship and age-specific survival probability using a mortality model — model_survival","text":"params Numeric vector representing parameters mortality model. age Numeric vector representing age. default NULL, whereby survival trajectory modelled age 0 age survivorship synthetic cohort declines threshold defined truncate argument, default 0.01 (.e. 1% cohort remaining alive). model character string specifying name mortality model used. Options gompertz, gompertzmakeham, exponential, siler, weibull, weibullmakeham. names case-sensitive. truncate value defining life table output truncated. default 0.01, indicating life table truncated survivorship (lx) > 0.01 (.e. age 1% cohort remains alive).","code":""},{"path":"https://jonesor.github.io/mpmsim/reference/model_survival.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Model mortality hazard, survivorship and age-specific survival probability using a mortality model — model_survival","text":"dataframe form lifetable columns age (x), hazard (hx), survivorship (lx) mortality (qx) survival probability within interval (px).","code":""},{"path":"https://jonesor.github.io/mpmsim/reference/model_survival.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Model mortality hazard, survivorship and age-specific survival probability using a mortality model — model_survival","text":"required parameters varies depending mortality model. parameters provided vector. *gompertz weibull, parameters b0, b1. *gompertzmakeham weibullmakeham parameters b0, b1 C. *exponential, parameter C. *siler, parameters a0, a1, C, b0 b1. Note parameters must provided order mentioned . x represents age. Gompertz: \\(h_x = b_0 \\mathrm{e}^{b_1  x}\\) Gompertz-Makeham: \\(h_x = b_0 \\mathrm{e}^{b_1  x} + c\\) Exponential: \\(h_x = c\\) Siler: \\(h_x = a_0 \\mathrm{e}^{-a_1  x} + c + b_0 \\mathrm{e}^{b_1 x}\\) Weibull: \\(h_x = b_0  b_1  (b_1  x)^{(b_0 - 1)}\\) Weibull-Makeham: \\(h_x = b_0  b_1  (b_1  x)^{(b_0 - 1)} + c\\) output, probability survival (px) (death (qx)) represent probability individuals enter age interval \\([x,x+1]\\) survive end interval (die end interval). possible estimate value final row life table (\\(x+1\\) value) therefore input values age (x) may need extended capture final interval.","code":""},{"path":"https://jonesor.github.io/mpmsim/reference/model_survival.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Model mortality hazard, survivorship and age-specific survival probability using a mortality model — model_survival","text":"Cox, D.R. & Oakes, D. (1984) Analysis Survival Data. Chapman Hall, London, UK. Pinder III, J.E., Wiener, J.G. & Smith, M.H. (1978) Weibull distribution: method summarizing survivorship data. Ecology, 59, 175–179. Pletcher, S. (1999) Model fitting hypothesis testing age-specific mortality data. Journal Evolutionary Biology, 12, 430–439. Siler, W. (1979) competing-risk model animal mortality. Ecology, 60, 750–757. Vaupel, J., Manton, K. & Stallard, E. (1979) impact heterogeneity individual frailty dynamics mortality. Demography, 16, 439–454.","code":""},{"path":[]},{"path":"https://jonesor.github.io/mpmsim/reference/model_survival.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Model mortality hazard, survivorship and age-specific survival probability using a mortality model — model_survival","text":"Owen Jones jones@biology.sdu.dk","code":""},{"path":"https://jonesor.github.io/mpmsim/reference/model_survival.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Model mortality hazard, survivorship and age-specific survival probability using a mortality model — model_survival","text":"","code":"model_mortality(params = c(b_0 = 0.1, b_1 = 0.2), model = \"Gompertz\") #>     x        hx         lx        qx        px #> 1   0 0.1000000 1.00000000 0.1051240 0.8948760 #> 2   1 0.1221403 0.89487598 0.1268617 0.8731383 #> 3   2 0.1491825 0.78135045 0.1526972 0.8473028 #> 4   3 0.1822119 0.66204041 0.1832179 0.8167821 #> 5   4 0.2225541 0.54074272 0.2190086 0.7809914 #> 6   5 0.2718282 0.42231542 0.2606027 0.7393973 #> 7   6 0.3320117 0.31225886 0.3084127 0.6915873 #> 8   7 0.4055200 0.21595427 0.3626343 0.6373657 #> 9   8 0.4953032 0.13764186 0.4231275 0.5768725 #> 10  9 0.6049647 0.07940180 0.4892807 0.5107193 #> 11 10 0.7389056 0.04055203 0.5598781 0.4401219 #> 12 11 0.9025013 0.01784784 0.6330059 0.3669941  model_mortality(   params = c(b_0 = 0.1, b_1 = 0.2, C = 0.1),   model = \"GompertzMakeham\",   truncate = 0.1 ) #>   x        hx        lx        qx        px #> 1 0 0.2000000 1.0000000 0.1902827 0.8097173 #> 2 1 0.2221403 0.8097173 0.2099518 0.7900482 #> 3 2 0.2491825 0.6397156 0.2333287 0.7666713 #> 4 3 0.2822119 0.4904516 0.2609450 0.7390550 #> 5 4 0.3225541 0.3624707 0.2933298 0.7066702 #> 6 5 0.3718282 0.2561472 0.3309657 0.6690343 #> 7 6 0.4320117 0.1713713 0.3742259 0.6257741 #> 8 7 0.5055200 0.1072397 0.4232876 0.5767124  model_mortality(params = c(c = 0.2), model = \"Exponential\", age = 0:10) #>     x  hx        lx        qx        px #> 1   0 0.2 1.0000000 0.1812692 0.8187308 #> 2   1 0.2 0.8187308 0.1812692 0.8187308 #> 3   2 0.2 0.6703200 0.1812692 0.8187308 #> 4   3 0.2 0.5488116 0.1812692 0.8187308 #> 5   4 0.2 0.4493290 0.1812692 0.8187308 #> 6   5 0.2 0.3678794 0.1812692 0.8187308 #> 7   6 0.2 0.3011942 0.1812692 0.8187308 #> 8   7 0.2 0.2465970 0.1812692 0.8187308 #> 9   8 0.2 0.2018965 0.1812692 0.8187308 #> 10  9 0.2 0.1652989 0.1812692 0.8187308 #> 11 10 0.2 0.1353353        NA        NA  model_mortality(   params = c(a_0 = 0.1, a_1 = 0.2, C = 0.1, b_0 = 0.1, b_1 = 0.2),   model = \"Siler\",   age = 0:10 ) #>    x        hx         lx        qx        px #> 1  0 0.3000000 1.00000000 0.2606669 0.7393331 #> 2  1 0.3040134 0.73933313 0.2666366 0.7333634 #> 3  2 0.3162145 0.54219987 0.2786665 0.7213335 #> 4  3 0.3370930 0.39110690 0.2969238 0.7030762 #> 5  4 0.3674870 0.27497795 0.3216226 0.6783774 #> 6  5 0.4086161 0.18653882 0.3529771 0.6470229 #> 7  6 0.4621311 0.12069488 0.3911330 0.6088670 #> 8  7 0.5301797 0.07348713 0.4360763 0.5639237 #> 9  8 0.6154929 0.04144114 0.4875201 0.5124799 #> 10 9 0.7214946 0.02123775 0.5447766 0.4552234  model_mortality(   params = c(b_0 = 1.4, b_1 = 0.18),   model = \"Weibull\" ) #>     x        hx         lx         qx        px #> 1   0 0.0000000 1.00000000 0.06148553 0.9385145 #> 2   1 0.1269140 0.93851447 0.13686918 0.8631308 #> 3   2 0.1674640 0.81006076 0.16657160 0.8334284 #> 4   3 0.1969509 0.67512765 0.18857273 0.8114273 #> 5   4 0.2209701 0.54781698 0.20648690 0.7935131 #> 6   5 0.2416003 0.43469995 0.22177479 0.7782252 #> 7   6 0.2598783 0.33829446 0.23520126 0.7647987 #> 8   7 0.2764068 0.25872718 0.24722531 0.7527747 #> 9   8 0.2915718 0.19476327 0.25814734 0.7418527 #> 10  9 0.3056374 0.14448565 0.26817620 0.7318238 #> 11 10 0.3187936 0.10573804 0.27746379 0.7225362 #> 12 11 0.3311819 0.07639956 0.28612450 0.7138755 #> 13 12 0.3429115 0.05453977 0.29424691 0.7057531 #> 14 13 0.3540682 0.03849161 0.30190116 0.6980988 #> 15 14 0.3647210 0.02687095 0.30914389 0.6908561 #> 16 15 0.3749264 0.01856396 0.31602155 0.6839785 #> 17 16 0.3847313 0.01269735 0.32257279 0.6774272  model_mortality(   params = c(b_0 = 1.1, b_1 = 0.05, c = 0.2),   model = \"WeibullMakeham\" ) #>     x        hx         lx        qx        px #> 1   0 0.2000000 1.00000000 0.1977871 0.8022129 #> 2   1 0.2407624 0.80221294 0.2151206 0.7848794 #> 3   2 0.2436881 0.62964040 0.2169760 0.7830240 #> 4   3 0.2454959 0.49302353 0.2182027 0.7817973 #> 5   4 0.2468237 0.38544447 0.2191342 0.7808658 #> 6   5 0.2478803 0.30098040 0.2198903 0.7801097 #> 7   6 0.2487612 0.23479772 0.2205292 0.7794708 #> 8   7 0.2495187 0.18301798 0.2210836 0.7789164 #> 9   8 0.2501844 0.14255570 0.2215743 0.7784257 #> 10  9 0.2507790 0.11096903 0.2220149 0.7779851 #> 11 10 0.2513168 0.08633225 0.2224152 0.7775848 #> 12 11 0.2518083 0.06713065 0.2227822 0.7772178 #> 13 12 0.2522610 0.05217514 0.2231213 0.7768787 #> 14 13 0.2526810 0.04053375 0.2234366 0.7765634 #> 15 14 0.2530729 0.03147703 0.2237313 0.7762687 #> 16 15 0.2534403 0.02443463 0.2240082 0.7759918 #> 17 16 0.2537863 0.01896108 0.2242693 0.7757307 #> 18 17 0.2541134 0.01470869 0.2245164 0.7754836 #> 19 18 0.2544236 0.01140635 0.2247511 0.7752489  model_survival(params = c(b_0 = 0.1, b_1 = 0.2), model = \"Gompertz\") #>     x        hx         lx        qx        px #> 1   0 0.1000000 1.00000000 0.1051240 0.8948760 #> 2   1 0.1221403 0.89487598 0.1268617 0.8731383 #> 3   2 0.1491825 0.78135045 0.1526972 0.8473028 #> 4   3 0.1822119 0.66204041 0.1832179 0.8167821 #> 5   4 0.2225541 0.54074272 0.2190086 0.7809914 #> 6   5 0.2718282 0.42231542 0.2606027 0.7393973 #> 7   6 0.3320117 0.31225886 0.3084127 0.6915873 #> 8   7 0.4055200 0.21595427 0.3626343 0.6373657 #> 9   8 0.4953032 0.13764186 0.4231275 0.5768725 #> 10  9 0.6049647 0.07940180 0.4892807 0.5107193 #> 11 10 0.7389056 0.04055203 0.5598781 0.4401219 #> 12 11 0.9025013 0.01784784 0.6330059 0.3669941"},{"path":"https://jonesor.github.io/mpmsim/reference/mpmsim-package.html","id":null,"dir":"Reference","previous_headings":"","what":"mpmsim: Simulation of Matrix Population Models with Defined Life History Characteristics — mpmsim-package","title":"mpmsim: Simulation of Matrix Population Models with Defined Life History Characteristics — mpmsim-package","text":"Allows users simulate matrix population models particular characteristics based aspects life history mortality trajectories fertility trajectories. Also allows exploration sampling error due small sample size.","code":""},{"path":[]},{"path":"https://jonesor.github.io/mpmsim/reference/mpmsim-package.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"mpmsim: Simulation of Matrix Population Models with Defined Life History Characteristics — mpmsim-package","text":"Maintainer: Owen Jones jones@biology.sdu.dk (ORCID)","code":""},{"path":"https://jonesor.github.io/mpmsim/reference/plot_matrix.html","id":null,"dir":"Reference","previous_headings":"","what":"Plot a matrix as a heatmap — plot_matrix","title":"Plot a matrix as a heatmap — plot_matrix","text":"Visualise matrix, matrix population model (MPM), heatmap.","code":""},{"path":"https://jonesor.github.io/mpmsim/reference/plot_matrix.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Plot a matrix as a heatmap — plot_matrix","text":"","code":"plot_matrix(mat, zero_na = FALSE, legend = FALSE, na_colour = NA, ...)"},{"path":"https://jonesor.github.io/mpmsim/reference/plot_matrix.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Plot a matrix as a heatmap — plot_matrix","text":"mat matrix, matrix matrix population model zero_na Logical indicating whether zero values treated NA legend Logical indicating whether include legend na_colour Colour NA values ... Additional arguments passed ggplot","code":""},{"path":"https://jonesor.github.io/mpmsim/reference/plot_matrix.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Plot a matrix as a heatmap — plot_matrix","text":"ggplot object","code":""},{"path":[]},{"path":"https://jonesor.github.io/mpmsim/reference/plot_matrix.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Plot a matrix as a heatmap — plot_matrix","text":"Owen Jones jones@biology.sdu.dk","code":""},{"path":"https://jonesor.github.io/mpmsim/reference/plot_matrix.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Plot a matrix as a heatmap — plot_matrix","text":"","code":"matDim <- 10 A1 <- make_leslie_mpm(   survival = seq(0.1, 0.7, length.out = matDim),   fecundity = seq(0.1, 0.7, length.out = matDim),   n_stages = matDim ) plot_matrix(A1, zero_na = TRUE, na_colour = \"black\")  plot_matrix(A1, zero_na = TRUE, na_colour = NA)"},{"path":"https://jonesor.github.io/mpmsim/reference/rand_lefko_mpm.html","id":null,"dir":"Reference","previous_headings":"","what":"Generate random Lefkovitch matrix population models (MPMs) based on life history archetypes — rand_lefko_mpm","title":"Generate random Lefkovitch matrix population models (MPMs) based on life history archetypes — rand_lefko_mpm","text":"Generates random matrix population model (MPM) element values based defined life history archetypes. Survival transition/growth probabilities particular stage restricted less equal 1 drawing Dirichlet distribution. user can specify archetypes (Takada et al. 2018) restrict MPMs ways: Archetype 1: elements positive, although may small. Therefore, transition /stage possible. model describes life history individuals can progress retrogress rapidly. Archetype 2: form archetype 1 (transition /stage possible), survival probability (column sums survival matrix) increases monotonously individuals advance later stages. model, one first archetype, also allows rapid progression retrogression, realistic stage-specific survival probability increases stage advancement. Archetype 3: positive non-zero elements survival allowed diagonal lower sub-diagonal matrix model represents life cycle species retrogression allowed, progression can happen immediately larger/developed stage (slow progression, e.g., trees). Archetype 4: archetype general form archetype 3, assumption stage-specific survival increases individuals increase size/developmental stage. respect similar archetype 2.","code":""},{"path":"https://jonesor.github.io/mpmsim/reference/rand_lefko_mpm.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Generate random Lefkovitch matrix population models (MPMs) based on life history archetypes — rand_lefko_mpm","text":"","code":"rand_lefko_mpm(n_stages, fecundity, archetype = 1, split = TRUE)"},{"path":"https://jonesor.github.io/mpmsim/reference/rand_lefko_mpm.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Generate random Lefkovitch matrix population models (MPMs) based on life history archetypes — rand_lefko_mpm","text":"n_stages integer defining number stages MPM. fecundity measure reproductive output. average number offspring produced per projection interval stage. Values can provided 4 ways: numeric vector length 1 provide single fecundity measure top right corner matrix model . numeric vector integers length equal n_stages provide fecundity estimates whole top row matrix model. Use 0 cases fecundity. matrix numeric values dimension n_stages provide fecundity estimates entire matrix model. Use 0 cases fecundity. list two matrices numeric values, dimension n_stages, provide lower upper limits mean fecundity entire matrix model. Use 0 lower upper limits cases fecundity. latter case, fecundity value drawn uniform distribution defined range. fecundity particular age class, use value 0 lower upper limit. archetype Indication life history archetype used, based Takada et al. 2018. integer 1 4. split TRUE/FALSE, indicating whether matrix produced split survival matrix reproductive output matrix. true, output becomes list matrix element. Otherwise, output single matrix. Default TRUE.","code":""},{"path":"https://jonesor.github.io/mpmsim/reference/rand_lefko_mpm.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Generate random Lefkovitch matrix population models (MPMs) based on life history archetypes — rand_lefko_mpm","text":"Returns random matrix population model characteristics determined archetype selected fecundity vector. split = TRUE, matrix split separate reproductive output growth/survival matrices, returned list.","code":""},{"path":"https://jonesor.github.io/mpmsim/reference/rand_lefko_mpm.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Generate random Lefkovitch matrix population models (MPMs) based on life history archetypes — rand_lefko_mpm","text":"4 Archetypes, reproductive output placed single element top right matrix, single value. vector length n_stages fecundity vector spans entire top row matrix. function constrained output ergodic matrices. Note simulations assume post-breeding census, thus avoiding often overlooked issue unaccounted survival reproduction highlighted Kendall et al. (2019). Furthermore, simulations assume covariance among matrix elements (e.g. reproduction survival), therefore allow users capture trade offs directly. capability roadmapped future package release.","code":""},{"path":"https://jonesor.github.io/mpmsim/reference/rand_lefko_mpm.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Generate random Lefkovitch matrix population models (MPMs) based on life history archetypes — rand_lefko_mpm","text":"Caswell, H. (2001). Matrix Population Models: Construction, Analysis, Interpretation. Sinauer. Lefkovitch, L. P. (1965). study population growth organisms grouped stages. Biometrics, 21(1), 1. Takada, T., Kawai, Y., & Salguero-Gómez, R. (2018). cautionary note elasticity analyses ternary plot using randomly generated population matrices. Population Ecology, 60(1), 37–47. Kendall, B. E., Fujiwara, M., Diaz-Lopez, J., Schneider, S., Voigt, J., & Wiesner, S. (2019). Persistent problems construction matrix population models. Ecological Modelling, 406, 33–43.","code":""},{"path":[]},{"path":"https://jonesor.github.io/mpmsim/reference/rand_lefko_mpm.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Generate random Lefkovitch matrix population models (MPMs) based on life history archetypes — rand_lefko_mpm","text":"Owen Jones jones@biology.sdu.dk","code":""},{"path":"https://jonesor.github.io/mpmsim/reference/rand_lefko_mpm.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Generate random Lefkovitch matrix population models (MPMs) based on life history archetypes — rand_lefko_mpm","text":"","code":"set.seed(42) # set seed for repeatability  rand_lefko_mpm(n_stages = 2, fecundity = 20, archetype = 1, split = FALSE) #>            [,1]       [,2] #> [1,] 0.73066610 20.0402850 #> [2,] 0.06797628  0.7190785 rand_lefko_mpm(n_stages = 2, fecundity = 20, archetype = 2, split = TRUE) #> $mat_A #>           [,1]        [,2] #> [1,] 0.5129277 20.78121699 #> [2,] 0.2895418  0.04959239 #>  #> $mat_U #>           [,1]       [,2] #> [1,] 0.5129277 0.78121699 #> [2,] 0.2895418 0.04959239 #>  #> $mat_F #>      [,1] [,2] #> [1,]    0   20 #> [2,]    0    0 #>  rand_lefko_mpm(n_stages = 3, fecundity = 20, archetype = 3, split = FALSE) #>            [,1]      [,2]       [,3] #> [1,] 0.26019259 0.0000000 20.0000000 #> [2,] 0.09187956 0.8172080  0.0000000 #> [3,] 0.00000000 0.1640643  0.1762325 rand_lefko_mpm(n_stages = 4, fecundity = 20, archetype = 4, split = TRUE) #> $mat_A #>            [,1]       [,2]      [,3]       [,4] #> [1,] 0.24002446 0.00000000 0.0000000 20.0000000 #> [2,] 0.03254107 0.05480185 0.0000000  0.0000000 #> [3,] 0.00000000 0.62726117 0.7851646  0.0000000 #> [4,] 0.00000000 0.00000000 0.0786406  0.9661587 #>  #> $mat_U #>            [,1]       [,2]      [,3]      [,4] #> [1,] 0.24002446 0.00000000 0.0000000 0.0000000 #> [2,] 0.03254107 0.05480185 0.0000000 0.0000000 #> [3,] 0.00000000 0.62726117 0.7851646 0.0000000 #> [4,] 0.00000000 0.00000000 0.0786406 0.9661587 #>  #> $mat_F #>      [,1] [,2] [,3] [,4] #> [1,]    0    0    0   20 #> [2,]    0    0    0    0 #> [3,]    0    0    0    0 #> [4,]    0    0    0    0 #>  rand_lefko_mpm(   n_stages = 5, fecundity = c(0, 0, 4, 8, 10), archetype = 4,   split = TRUE ) #> $mat_A #>             [,1]      [,2]      [,3]      [,4]       [,5] #> [1,] 0.008672344 0.0000000 4.0000000 8.0000000 10.0000000 #> [2,] 0.027810843 0.2560970 0.0000000 0.0000000  0.0000000 #> [3,] 0.000000000 0.5284182 0.1992335 0.0000000  0.0000000 #> [4,] 0.000000000 0.0000000 0.6157474 0.3219698  0.0000000 #> [5,] 0.000000000 0.0000000 0.0000000 0.6398980  0.9915655 #>  #> $mat_U #>             [,1]      [,2]      [,3]      [,4]      [,5] #> [1,] 0.008672344 0.0000000 0.0000000 0.0000000 0.0000000 #> [2,] 0.027810843 0.2560970 0.0000000 0.0000000 0.0000000 #> [3,] 0.000000000 0.5284182 0.1992335 0.0000000 0.0000000 #> [4,] 0.000000000 0.0000000 0.6157474 0.3219698 0.0000000 #> [5,] 0.000000000 0.0000000 0.0000000 0.6398980 0.9915655 #>  #> $mat_F #>      [,1] [,2] [,3] [,4] [,5] #> [1,]    0    0    4    8   10 #> [2,]    0    0    0    0    0 #> [3,]    0    0    0    0    0 #> [4,]    0    0    0    0    0 #> [5,]    0    0    0    0    0 #>  # Using a range of values for fecundity rand_lefko_mpm(n_stages = 2, fecundity = 20, archetype = 1, split = TRUE) #> $mat_A #>           [,1]        [,2] #> [1,] 0.2558635 20.54431954 #> [2,] 0.0543606  0.07233605 #>  #> $mat_U #>           [,1]       [,2] #> [1,] 0.2558635 0.54431954 #> [2,] 0.0543606 0.07233605 #>  #> $mat_F #>      [,1] [,2] #> [1,]    0   20 #> [2,]    0    0 #>"},{"path":"https://jonesor.github.io/mpmsim/reference/rand_lefko_set.html","id":null,"dir":"Reference","previous_headings":"","what":"Generate lists of Lefkovitch matrix population models (MPMs) based on life history archetypes — rand_lefko_set","title":"Generate lists of Lefkovitch matrix population models (MPMs) based on life history archetypes — rand_lefko_set","text":"function generates list n MPMs according specified criteria. Criteria include archetype, acceptable constraining criteria, include lambda, generation time metric derived matrix. function attempts find matrices fulfil criteria, discarding unacceptable matrices. default, takes 1000 attempts find suitable matrix model, error produced. However, number attempts can altered attempts parameter.","code":""},{"path":"https://jonesor.github.io/mpmsim/reference/rand_lefko_set.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Generate lists of Lefkovitch matrix population models (MPMs) based on life history archetypes — rand_lefko_set","text":"","code":"rand_lefko_set(   n_models = 5,   n_stages = 3,   archetype = 1,   fecundity = 1.5,   output = \"Type1\",   max_surv = 0.99,   constraint = NULL,   attempts = 1000 )"},{"path":"https://jonesor.github.io/mpmsim/reference/rand_lefko_set.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Generate lists of Lefkovitch matrix population models (MPMs) based on life history archetypes — rand_lefko_set","text":"n_models integer indicating number MPMs generate. n_stages number stages MPMs. Default 3. archetype archetype MPMs. Default 1. fecundity average number offspring produced (fecundity). Values can provided 4 ways: numeric vector length 1 providing single measure fecundity top right corner matrix model . numeric vector integers length equal n_stages provide fecundity estimates whole top row matrix model. Use 0 cases fecundity. matrix numeric values dimension n_stages provide fecundity estimates entire matrix model. Use 0 cases fecundity. list two matrices numeric values, dimension n_stages, provide lower upper limits mean fecundity entire matrix model. latter case, fecundity value drawn uniform distribution defined range. fecundity particular age class, use value 0 lower upper limit. output Character string indicating type output. Type1 cdb_split: compadreDB Object containing MPMs split submatrices (.e. , U, F C). Type2 cdb_A: compadreDB Object containing MPMs split submatrices (.e. matrix included). Type3: list_split1 MPMs arranged element list contains model associated submatrices (.e. nth element contains nth matrix alongside nth U F matrices). Type4: list_split2 MPMs arranged list contains 3 lists  matrix U F submatrices respectively. Type5 list_A: list MPMs, including matrix. max_surv maximum acceptable survival value, calculated across transitions stage. Defaults 0.99. used output splits matrix submatrices. constraint optional data frame 4 columns named fun, arg, lower upper. columns specify (1) function outputs metric derived matrix (2) argument function (NA, argument supplied) (3) lower acceptable bound metric (4) upper acceptable bound metric. attempts integer indicating number attempts made simulating matrix model. default 1000. takes 1000 attempts make matrix satisfies conditions set arguments, warning produced.","code":""},{"path":"https://jonesor.github.io/mpmsim/reference/rand_lefko_set.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Generate lists of Lefkovitch matrix population models (MPMs) based on life history archetypes — rand_lefko_set","text":"compadreDB object list MPMs meet specified criteria.","code":""},{"path":"https://jonesor.github.io/mpmsim/reference/rand_lefko_set.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Generate lists of Lefkovitch matrix population models (MPMs) based on life history archetypes — rand_lefko_set","text":"Caswell, H. (2001). Matrix Population Models: Construction, Analysis, Interpretation. Sinauer. Lefkovitch, L. P. (1965). study population growth organisms grouped stages. Biometrics, 21(1), 1. Takada, T., Kawai, Y., & Salguero-Gómez, R. (2018). cautionary note elasticity analyses ternary plot using randomly generated population matrices. Population Ecology, 60(1), 37–47.","code":""},{"path":[]},{"path":"https://jonesor.github.io/mpmsim/reference/rand_lefko_set.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Generate lists of Lefkovitch matrix population models (MPMs) based on life history archetypes — rand_lefko_set","text":"Owen Jones jones@biology.sdu.dk","code":""},{"path":"https://jonesor.github.io/mpmsim/reference/rand_lefko_set.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Generate lists of Lefkovitch matrix population models (MPMs) based on life history archetypes — rand_lefko_set","text":"","code":"set.seed(42) # set seed for repeatability  # Basic operation, without splitting matrices and with no constraints rand_lefko_set(   n_models = 3, n_stages = 5, fecundity = c(0, 0, 4, 8, 10),   archetype = 4, output = \"Type5\" ) #> [[1]] #>            [,1]       [,2]      [,3]      [,4]       [,5] #> [1,] 0.04028499 0.00000000 4.0000000 8.0000000 10.0000000 #> [2,] 0.71907852 0.73066610 0.0000000 0.0000000  0.0000000 #> [3,] 0.00000000 0.06797628 0.5129277 0.0000000  0.0000000 #> [4,] 0.00000000 0.00000000 0.2895418 0.8589953  0.0000000 #> [5,] 0.00000000 0.00000000 0.0000000 0.1331578  0.9997924 #>  #> [[2]] #>            [,1]       [,2]      [,3]      [,4]       [,5] #> [1,] 0.04993404 0.00000000 4.0000000 8.0000000 10.0000000 #> [2,] 0.35213116 0.38662704 0.0000000 0.0000000  0.0000000 #> [3,] 0.00000000 0.04413311 0.2022055 0.0000000  0.0000000 #> [4,] 0.00000000 0.00000000 0.4116914 0.4473679  0.0000000 #> [5,] 0.00000000 0.00000000 0.0000000 0.4300040  0.9673925 #>  #> [[3]] #>           [,1]      [,2]      [,3]      [,4]       [,5] #> [1,] 0.3908713 0.0000000 4.0000000 8.0000000 10.0000000 #> [2,] 0.1593942 0.3008004 0.0000000 0.0000000  0.0000000 #> [3,] 0.0000000 0.4611680 0.5792468 0.0000000  0.0000000 #> [4,] 0.0000000 0.0000000 0.2741919 0.2238051  0.0000000 #> [5,] 0.0000000 0.0000000 0.0000000 0.6835265  0.9941976 #>   # Constrain outputs to A matrices with lambda between 0.9 and 1.1 library(popbio) constrain_df <- data.frame(   fun = \"lambda\", arg = NA, lower = 0.9, upper =     1.1 ) rand_lefko_set(   n_models = 10, n_stages = 5, fecundity = c(0, 0, 4, 8, 10),   archetype = 4, constraint = constrain_df, output = \"Type5\" ) #> [[1]] #>            [,1]      [,2]       [,3]       [,4]       [,5] #> [1,] 0.16074427 0.0000000 4.00000000 8.00000000 10.0000000 #> [2,] 0.03843446 0.1920300 0.00000000 0.00000000  0.0000000 #> [3,] 0.00000000 0.5599534 0.83063495 0.00000000  0.0000000 #> [4,] 0.00000000 0.0000000 0.01691095 0.06976802  0.0000000 #> [5,] 0.00000000 0.0000000 0.00000000 0.92957038  0.9997121 #>  #> [[2]] #>            [,1]      [,2]      [,3]      [,4]       [,5] #> [1,] 0.40726303 0.0000000 4.0000000 8.0000000 10.0000000 #> [2,] 0.02472534 0.5507259 0.0000000 0.0000000  0.0000000 #> [3,] 0.00000000 0.1762418 0.4303426 0.0000000  0.0000000 #> [4,] 0.00000000 0.0000000 0.3952927 0.1772480  0.0000000 #> [5,] 0.00000000 0.0000000 0.0000000 0.7574622  0.9818421 #>  #> [[3]] #>            [,1]         [,2]      [,3]       [,4]       [,5] #> [1,] 0.13213712 0.0000000000 4.0000000 8.00000000 10.0000000 #> [2,] 0.01633696 0.0002954688 0.0000000 0.00000000  0.0000000 #> [3,] 0.00000000 0.4951548186 0.2901663 0.00000000  0.0000000 #> [4,] 0.00000000 0.0000000000 0.3561964 0.96238123  0.0000000 #> [5,] 0.00000000 0.0000000000 0.0000000 0.01793056  0.9986862 #>  #> [[4]] #>           [,1]       [,2]       [,3]      [,4]      [,5] #> [1,] 0.2025021 0.00000000 4.00000000 8.0000000 10.000000 #> [2,] 0.1808410 0.51560726 0.00000000 0.0000000  0.000000 #> [3,] 0.0000000 0.05938074 0.69893955 0.0000000  0.000000 #> [4,] 0.0000000 0.00000000 0.04270201 0.1153077  0.000000 #> [5,] 0.0000000 0.00000000 0.00000000 0.6563415  0.905483 #>  #> [[5]] #>           [,1]        [,2]       [,3]      [,4]       [,5] #> [1,] 0.1014989 0.000000000 4.00000000 8.0000000 10.0000000 #> [2,] 0.4079260 0.641405627 0.00000000 0.0000000  0.0000000 #> [3,] 0.0000000 0.007769844 0.07572709 0.0000000  0.0000000 #> [4,] 0.0000000 0.000000000 0.65797642 0.6475288  0.0000000 #> [5,] 0.0000000 0.000000000 0.00000000 0.3319838  0.9979733 #>  #> [[6]] #>           [,1]       [,2]       [,3]      [,4]       [,5] #> [1,] 0.3492059 0.00000000 4.00000000 8.0000000 10.0000000 #> [2,] 0.2623854 0.59588086 0.00000000 0.0000000  0.0000000 #> [3,] 0.0000000 0.02204176 0.03327729 0.0000000  0.0000000 #> [4,] 0.0000000 0.00000000 0.64881290 0.1459793  0.0000000 #> [5,] 0.0000000 0.00000000 0.00000000 0.6109135  0.9411863 #>  #> [[7]] #>           [,1]      [,2]       [,3]      [,4]      [,5] #> [1,] 0.0100986 0.0000000 4.00000000 8.0000000 10.000000 #> [2,] 0.2816060 0.3421699 0.00000000 0.0000000  0.000000 #> [3,] 0.0000000 0.2403473 0.60176000 0.0000000  0.000000 #> [4,] 0.0000000 0.0000000 0.01202352 0.5052573  0.000000 #> [5,] 0.0000000 0.0000000 0.00000000 0.2482741  0.975591 #>  #> [[8]] #>            [,1]       [,2]      [,3]      [,4]       [,5] #> [1,] 0.05277117 0.00000000 4.0000000 8.0000000 10.0000000 #> [2,] 0.14635732 0.14395871 0.0000000 0.0000000  0.0000000 #> [3,] 0.00000000 0.09478692 0.2766104 0.0000000  0.0000000 #> [4,] 0.00000000 0.00000000 0.6115977 0.1849629  0.0000000 #> [5,] 0.00000000 0.00000000 0.0000000 0.7926018  0.9830451 #>  #> [[9]] #>           [,1]       [,2]      [,3]      [,4]      [,5] #> [1,] 0.2695917 0.00000000 4.0000000 8.0000000 10.000000 #> [2,] 0.2267870 0.45112437 0.0000000 0.0000000  0.000000 #> [3,] 0.0000000 0.05989263 0.3118949 0.0000000  0.000000 #> [4,] 0.0000000 0.00000000 0.3091554 0.2289075  0.000000 #> [5,] 0.0000000 0.00000000 0.0000000 0.6927089  0.956369 #>  #> [[10]] #>           [,1]      [,2]      [,3]       [,4]       [,5] #> [1,] 0.2788292 0.0000000 4.0000000 8.00000000 10.0000000 #> [2,] 0.0816387 0.2433186 0.0000000 0.00000000  0.0000000 #> [3,] 0.0000000 0.3089479 0.1000315 0.00000000  0.0000000 #> [4,] 0.0000000 0.0000000 0.4670093 0.73745701  0.0000000 #> [5,] 0.0000000 0.0000000 0.0000000 0.04978961  0.8887938 #>   # As above, but using popdemo::eigs function instead of popbio::lambda # to illustrate use of argument library(popdemo) constrain_df <- data.frame(   fun = \"eigs\", arg = \"lambda\", lower = 0.9, upper = 1.1 )  rand_lefko_set(   n_models = 10, n_stages = 5, fecundity = c(0, 0, 4, 8, 10),   archetype = 4, constraint = constrain_df, output = \"Type5\" ) #> [[1]] #>           [,1]      [,2]       [,3]      [,4]       [,5] #> [1,] 0.2772425 0.0000000 4.00000000 8.0000000 10.0000000 #> [2,] 0.1276093 0.4284850 0.00000000 0.0000000  0.0000000 #> [3,] 0.0000000 0.1104893 0.05017521 0.0000000  0.0000000 #> [4,] 0.0000000 0.0000000 0.60407149 0.1454031  0.0000000 #> [5,] 0.0000000 0.0000000 0.00000000 0.7206787  0.8721605 #>  #> [[2]] #>            [,1]      [,2]      [,3]       [,4]       [,5] #> [1,] 0.00794897 0.0000000 4.0000000 8.00000000 10.0000000 #> [2,] 0.10589532 0.2360636 0.0000000 0.00000000  0.0000000 #> [3,] 0.00000000 0.1030530 0.2807865 0.00000000  0.0000000 #> [4,] 0.00000000 0.0000000 0.1883105 0.62282892  0.0000000 #> [5,] 0.00000000 0.0000000 0.0000000 0.08604455  0.9653569 #>  #> [[3]] #>           [,1]     [,2]       [,3]      [,4]       [,5] #> [1,] 0.1495233 0.000000 4.00000000 8.0000000 10.0000000 #> [2,] 0.1741336 0.426369 0.00000000 0.0000000  0.0000000 #> [3,] 0.0000000 0.136707 0.62072487 0.0000000  0.0000000 #> [4,] 0.0000000 0.000000 0.06783148 0.1980795  0.0000000 #> [5,] 0.0000000 0.000000 0.00000000 0.5218206  0.7994516 #>  #> [[4]] #>            [,1]      [,2]       [,3]       [,4]       [,5] #> [1,] 0.05927331 0.0000000 4.00000000 8.00000000 10.0000000 #> [2,] 0.22972930 0.2638984 0.00000000 0.00000000  0.0000000 #> [3,] 0.00000000 0.1044152 0.85977997 0.00000000  0.0000000 #> [4,] 0.00000000 0.0000000 0.01677576 0.02321774  0.0000000 #> [5,] 0.00000000 0.0000000 0.00000000 0.95518252  0.9975017 #>  #> [[5]] #>            [,1]       [,2]       [,3]       [,4]       [,5] #> [1,] 0.04831774 0.00000000 4.00000000 8.00000000 10.0000000 #> [2,] 0.06775510 0.03037236 0.00000000 0.00000000  0.0000000 #> [3,] 0.00000000 0.37177964 0.09800894 0.00000000  0.0000000 #> [4,] 0.00000000 0.00000000 0.33187578 0.74345426  0.0000000 #> [5,] 0.00000000 0.00000000 0.00000000 0.01656937  0.7731065 #>  #> [[6]] #>            [,1]      [,2]      [,3]      [,4]       [,5] #> [1,] 0.33328577 0.0000000 4.0000000 8.0000000 10.0000000 #> [2,] 0.06377826 0.2498128 0.0000000 0.0000000  0.0000000 #> [3,] 0.00000000 0.3337334 0.5963528 0.0000000  0.0000000 #> [4,] 0.00000000 0.0000000 0.1693849 0.5795012  0.0000000 #> [5,] 0.00000000 0.0000000 0.0000000 0.2212670  0.8103362 #>  #> [[7]] #>           [,1]       [,2]       [,3]       [,4]       [,5] #> [1,] 0.0239377 0.00000000 4.00000000 8.00000000 10.0000000 #> [2,] 0.0366482 0.04343731 0.00000000 0.00000000  0.0000000 #> [3,] 0.0000000 0.68395612 0.68478775 0.00000000  0.0000000 #> [4,] 0.0000000 0.00000000 0.08214221 0.06041167  0.0000000 #> [5,] 0.0000000 0.00000000 0.00000000 0.82870382  0.9361283 #>  #> [[8]] #>            [,1]      [,2]      [,3]       [,4]       [,5] #> [1,] 0.03354061 0.0000000 4.0000000 8.00000000 10.0000000 #> [2,] 0.24257199 0.1737578 0.0000000 0.00000000  0.0000000 #> [3,] 0.00000000 0.1323195 0.2086060 0.00000000  0.0000000 #> [4,] 0.00000000 0.0000000 0.3520131 0.61162941  0.0000000 #> [5,] 0.00000000 0.0000000 0.0000000 0.06355464  0.7634507 #>  #> [[9]] #>            [,1]      [,2]      [,3]      [,4]       [,5] #> [1,] 0.18298502 0.0000000 4.0000000 8.0000000 10.0000000 #> [2,] 0.05516901 0.0637293 0.0000000 0.0000000  0.0000000 #> [3,] 0.00000000 0.3666609 0.3365942 0.0000000  0.0000000 #> [4,] 0.00000000 0.0000000 0.3601747 0.2711895  0.0000000 #> [5,] 0.00000000 0.0000000 0.0000000 0.4848073  0.9864156 #>  #> [[10]] #>           [,1]       [,2]       [,3]      [,4]       [,5] #> [1,] 0.1134325 0.00000000 4.00000000 8.0000000 10.0000000 #> [2,] 0.1691937 0.26547788 0.00000000 0.0000000  0.0000000 #> [3,] 0.0000000 0.03683351 0.06710737 0.0000000  0.0000000 #> [4,] 0.0000000 0.00000000 0.48303739 0.3510717  0.0000000 #> [5,] 0.0000000 0.00000000 0.00000000 0.6402862  0.9920856 #>   # Multiple constraints # Constrain outputs to A matrices with lambda between 0.9 and 1.1, generation # time between 3 and 5 and damping ratio between 1 and 7. library(popbio) constrain_df <- data.frame(   fun = c(\"lambda\", \"generation.time\", \"damping.ratio\"),   arg = c(NA, NA, NA),   lower = c(0.9, 3.0, 1.0),   upper = c(1.1, 5.0, 7.0) ) rand_lefko_set(   n_models = 10, n_stages = 5, fecundity = c(0, 0, 4, 8, 10),   archetype = 4, constraint = constrain_df, output = \"Type5\" ) #> [[1]] #>            [,1]      [,2]       [,3]      [,4]       [,5] #> [1,] 0.56648471 0.0000000 4.00000000 8.0000000 10.0000000 #> [2,] 0.05281201 0.3000692 0.00000000 0.0000000  0.0000000 #> [3,] 0.00000000 0.3479332 0.01618986 0.0000000  0.0000000 #> [4,] 0.00000000 0.0000000 0.70611327 0.3991537  0.0000000 #> [5,] 0.00000000 0.0000000 0.00000000 0.5322706  0.9656675 #>  #> [[2]] #>            [,1]      [,2]       [,3]      [,4]       [,5] #> [1,] 0.00572345 0.0000000 4.00000000 8.0000000 10.0000000 #> [2,] 0.25867680 0.1849481 0.00000000 0.0000000  0.0000000 #> [3,] 0.00000000 0.2763296 0.47875737 0.0000000  0.0000000 #> [4,] 0.00000000 0.0000000 0.04194771 0.2885805  0.0000000 #> [5,] 0.00000000 0.0000000 0.00000000 0.5292559  0.8627223 #>  #> [[3]] #>           [,1]      [,2]      [,3]      [,4]      [,5] #> [1,] 0.3299881 0.0000000 4.0000000 8.0000000 10.000000 #> [2,] 0.3730901 0.5780448 0.0000000 0.0000000  0.000000 #> [3,] 0.0000000 0.1703570 0.5616340 0.0000000  0.000000 #> [4,] 0.0000000 0.0000000 0.2011312 0.7910559  0.000000 #> [5,] 0.0000000 0.0000000 0.0000000 0.0203304  0.847165 #>  #> [[4]] #>           [,1]      [,2]      [,3]      [,4]       [,5] #> [1,] 0.3403444 0.0000000 4.0000000 8.0000000 10.0000000 #> [2,] 0.1152112 0.1165285 0.0000000 0.0000000  0.0000000 #> [3,] 0.0000000 0.6890762 0.1874684 0.0000000  0.0000000 #> [4,] 0.0000000 0.0000000 0.7050681 0.7296493  0.0000000 #> [5,] 0.0000000 0.0000000 0.0000000 0.1842275  0.9170533 #>  #> [[5]] #>           [,1]       [,2]      [,3]       [,4]       [,5] #> [1,] 0.1689392 0.00000000 4.0000000 8.00000000 10.0000000 #> [2,] 0.2063822 0.30596227 0.0000000 0.00000000  0.0000000 #> [3,] 0.0000000 0.07818665 0.1925666 0.00000000  0.0000000 #> [4,] 0.0000000 0.00000000 0.3427810 0.01826475  0.0000000 #> [5,] 0.0000000 0.00000000 0.0000000 0.63827242  0.9756126 #>  #> [[6]] #>            [,1]      [,2]       [,3]      [,4]       [,5] #> [1,] 0.00652138 0.0000000 4.00000000 8.0000000 10.0000000 #> [2,] 0.00545548 0.2302399 0.00000000 0.0000000  0.0000000 #> [3,] 0.00000000 0.3754500 0.65618224 0.0000000  0.0000000 #> [4,] 0.00000000 0.0000000 0.01014227 0.6273468  0.0000000 #> [5,] 0.00000000 0.0000000 0.00000000 0.3247017  0.9748711 #>  #> [[7]] #>           [,1]       [,2]       [,3]      [,4]       [,5] #> [1,] 0.2948358 0.00000000 4.00000000 8.0000000 10.0000000 #> [2,] 0.2761557 0.01036768 0.00000000 0.0000000  0.0000000 #> [3,] 0.0000000 0.56983696 0.55866742 0.0000000  0.0000000 #> [4,] 0.0000000 0.00000000 0.05776301 0.5119449  0.0000000 #> [5,] 0.0000000 0.00000000 0.00000000 0.1534077  0.7923763 #>  #> [[8]] #>           [,1]      [,2]      [,3]      [,4]       [,5] #> [1,] 0.4268973 0.0000000 4.0000000 8.0000000 10.0000000 #> [2,] 0.1469940 0.1228170 0.0000000 0.0000000  0.0000000 #> [3,] 0.0000000 0.5159129 0.2351381 0.0000000  0.0000000 #> [4,] 0.0000000 0.0000000 0.4172713 0.1631152  0.0000000 #> [5,] 0.0000000 0.0000000 0.0000000 0.6079843  0.9203012 #>  #> [[9]] #>           [,1]      [,2]        [,3]      [,4]       [,5] #> [1,] 0.3658073 0.0000000 4.000000000 8.0000000 10.0000000 #> [2,] 0.3986741 0.7194963 0.000000000 0.0000000  0.0000000 #> [3,] 0.0000000 0.0833023 0.008129479 0.0000000  0.0000000 #> [4,] 0.0000000 0.0000000 0.809932058 0.6717799  0.0000000 #> [5,] 0.0000000 0.0000000 0.000000000 0.2036987  0.8840548 #>  #> [[10]] #>           [,1]      [,2]      [,3]      [,4]      [,5] #> [1,] 0.2012457 0.0000000 4.0000000 8.0000000 10.000000 #> [2,] 0.1674917 0.2097260 0.0000000 0.0000000  0.000000 #> [3,] 0.0000000 0.4571663 0.3774105 0.0000000  0.000000 #> [4,] 0.0000000 0.0000000 0.4973726 0.3033012  0.000000 #> [5,] 0.0000000 0.0000000 0.0000000 0.6690492  0.975605 #>   # Constraints based on user-defined functions are also possible... # User-defined function to calculate survival from the first stage simpleFun <- function(x) {   sum(x[, 1]) }  # Define the constraint, based on the user-defined function constrain_df <- data.frame(   fun = \"simpleFun\", arg = NA, lower = 0.75, upper = 1 )  rand_lefko_set(   n_models = 10, n_stages = 5, fecundity = c(0, 0, 4, 8, 10),   archetype = 4, output = \"Type5\", constraint = constrain_df ) #> [[1]] #>           [,1]      [,2]      [,3]      [,4]       [,5] #> [1,] 0.2851186 0.0000000 4.0000000 8.0000000 10.0000000 #> [2,] 0.4914640 0.5399783 0.0000000 0.0000000  0.0000000 #> [3,] 0.0000000 0.3387130 0.2868371 0.0000000  0.0000000 #> [4,] 0.0000000 0.0000000 0.6329236 0.6625216  0.0000000 #> [5,] 0.0000000 0.0000000 0.0000000 0.3037399  0.9721035 #>  #> [[2]] #>            [,1]      [,2]      [,3]      [,4]       [,5] #> [1,] 0.06555602 0.0000000 4.0000000 8.0000000 10.0000000 #> [2,] 0.71894374 0.6138880 0.0000000 0.0000000  0.0000000 #> [3,] 0.00000000 0.2531078 0.5448483 0.0000000  0.0000000 #> [4,] 0.00000000 0.0000000 0.3314147 0.5727691  0.0000000 #> [5,] 0.00000000 0.0000000 0.0000000 0.3975397  0.9927771 #>  #> [[3]] #>           [,1]      [,2]      [,3]      [,4]       [,5] #> [1,] 0.4875300 0.0000000 4.0000000 8.0000000 10.0000000 #> [2,] 0.2892816 0.6524645 0.0000000 0.0000000  0.0000000 #> [3,] 0.0000000 0.2033185 0.4781757 0.0000000  0.0000000 #> [4,] 0.0000000 0.0000000 0.5121358 0.1269579  0.0000000 #> [5,] 0.0000000 0.0000000 0.0000000 0.8659373  0.9997907 #>  #> [[4]] #>           [,1]       [,2]      [,3]      [,4]       [,5] #> [1,] 0.6686443 0.00000000 4.0000000 8.0000000 10.0000000 #> [2,] 0.1039181 0.03289866 0.0000000 0.0000000  0.0000000 #> [3,] 0.0000000 0.78557368 0.1244681 0.0000000  0.0000000 #> [4,] 0.0000000 0.00000000 0.7182421 0.7979528  0.0000000 #> [5,] 0.0000000 0.00000000 0.0000000 0.1182491  0.9824771 #>  #> [[5]] #>           [,1]      [,2]      [,3]      [,4]       [,5] #> [1,] 0.1173406 0.0000000 4.0000000 8.0000000 10.0000000 #> [2,] 0.6555346 0.6269436 0.0000000 0.0000000  0.0000000 #> [3,] 0.0000000 0.2813469 0.5899624 0.0000000  0.0000000 #> [4,] 0.0000000 0.0000000 0.3682277 0.7846295  0.0000000 #> [5,] 0.0000000 0.0000000 0.0000000 0.2137519  0.9999653 #>  #> [[6]] #>           [,1]      [,2]      [,3]      [,4]       [,5] #> [1,] 0.1722272 0.0000000 4.0000000 8.0000000 10.0000000 #> [2,] 0.6321831 0.3040251 0.0000000 0.0000000  0.0000000 #> [3,] 0.0000000 0.5627847 0.4987978 0.0000000  0.0000000 #> [4,] 0.0000000 0.0000000 0.3717209 0.2923874  0.0000000 #> [5,] 0.0000000 0.0000000 0.0000000 0.6337466  0.9509031 #>  #> [[7]] #>           [,1]      [,2]       [,3]       [,4]       [,5] #> [1,] 0.5640947 0.0000000 4.00000000 8.00000000 10.0000000 #> [2,] 0.2572611 0.4447640 0.00000000 0.00000000  0.0000000 #> [3,] 0.0000000 0.3970424 0.07388491 0.00000000  0.0000000 #> [4,] 0.0000000 0.0000000 0.77197449 0.08657571  0.0000000 #> [5,] 0.0000000 0.0000000 0.00000000 0.81313872  0.9189676 #>  #> [[8]] #>           [,1]      [,2]      [,3]      [,4]       [,5] #> [1,] 0.1975400 0.0000000 4.0000000 8.0000000 10.0000000 #> [2,] 0.5943449 0.5472824 0.0000000 0.0000000  0.0000000 #> [3,] 0.0000000 0.2594387 0.1541316 0.0000000  0.0000000 #> [4,] 0.0000000 0.0000000 0.7614780 0.5107736  0.0000000 #> [5,] 0.0000000 0.0000000 0.0000000 0.4415484  0.9592893 #>  #> [[9]] #>           [,1]      [,2]        [,3]      [,4]       [,5] #> [1,] 0.2079467 0.0000000 4.000000000 8.0000000 10.0000000 #> [2,] 0.6006462 0.3120391 0.000000000 0.0000000  0.0000000 #> [3,] 0.0000000 0.5932424 0.962176500 0.0000000  0.0000000 #> [4,] 0.0000000 0.0000000 0.001385039 0.2303664  0.0000000 #> [5,] 0.0000000 0.0000000 0.000000000 0.7389333  0.9746942 #>  #> [[10]] #>            [,1]      [,2]      [,3]      [,4]       [,5] #> [1,] 0.04095016 0.0000000 4.0000000 8.0000000 10.0000000 #> [2,] 0.81498660 0.7477831 0.0000000 0.0000000  0.0000000 #> [3,] 0.00000000 0.1332249 0.2775395 0.0000000  0.0000000 #> [4,] 0.00000000 0.0000000 0.6312089 0.7569174  0.0000000 #> [5,] 0.00000000 0.0000000 0.0000000 0.2180885  0.9802792 #>"},{"path":"https://jonesor.github.io/mpmsim/reference/rand_leslie_set.html","id":null,"dir":"Reference","previous_headings":"","what":"Generate a set of random Leslie Matrix Population Models — rand_leslie_set","title":"Generate a set of random Leslie Matrix Population Models — rand_leslie_set","text":"Generates set Leslie matrix population models (MPMs) based defined mortality reproductive output models, using model parameters randomly drawn specified distributions.","code":""},{"path":"https://jonesor.github.io/mpmsim/reference/rand_leslie_set.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Generate a set of random Leslie Matrix Population Models — rand_leslie_set","text":"","code":"rand_leslie_set(   n_models = 5,   mortality_model = \"gompertz\",   fecundity_model = \"step\",   mortality_params,   fecundity_params,   fecundity_maturity_params,   dist_type = \"uniform\",   output = \"type1\",   scale_output = FALSE )"},{"path":"https://jonesor.github.io/mpmsim/reference/rand_leslie_set.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Generate a set of random Leslie Matrix Population Models — rand_leslie_set","text":"n_models integer indicating number MPMs generate. mortality_model character string specifying name mortality model used. Options gompertz, gompertzmakeham, exponential, siler, weibull, weibullmakeham. See model_mortality. names case-sensitive. fecundity_model character string specifying name model used reproductive output. Options logistic, step, vonBertalanffy, normal hadwiger. See ?model_fecundity. mortality_params two-column dataframe number rows equal number parameters mortality model. required order parameters depends selected mortality_model (see ?model_mortality): gompertz weibull: b_0, b_1 gompertzmakeham weibullmakeham: b_0, b_1, C exponential: C siler: a_0, a_1, C, b_0, b_1 dist_type uniform rows represent lower upper limits random uniform distribution parameters drawn. dist_type normal, columns represent mean standard deviation random normal distribution parameter values drawn. fecundity_params two-column dataframe number rows equal number parameters fecundity model. required order parameters depends selected fecundity_model (see ?model_fecundity): logistic: , k, x_m step: vonBertalanffy: , k normal: , mu, sd hadwiger: , b, C dist_type uniform rows represent lower upper limits random uniform distribution parameters drawn. dist_type normal, columns represent mean standard deviation random normal distribution parameter values drawn. fecundity_maturity_params vector two elements defining distribution age maturity drawn models. models coerce reproductive output zero point. dist_type uniform values represent lower upper limits random uniform distribution parameters drawn. dist_type normal, values represent mean standard deviation random normal distribution parameter values drawn. dist_type character string specifying type distribution draw parameters . Default uniform. Supported types uniform normal. output Character string indicating type output. Type1 cdb_split: compadreDB Object containing MPMs split submatrices (.e. , U, F C). Type2 cdb_A: compadreDB Object containing MPMs split submatrices (.e. matrix included). Type3: list_split1 MPMs arranged element list contains model associated submatrices (.e. nth element contains nth matrix alongside nth U F matrices). Type4: list_split2 MPMs arranged list contains 3 lists  matrix U F submatrices respectively. Type5 list_A: list MPMs, including matrix. Type6 lifetable: list life tables. Default Type1. scale_output logical argument. TRUE resulting MPMs life tables scaled adjusting reproductive output population growth rate (lambda) 1. Default FALSE.","code":""},{"path":"https://jonesor.github.io/mpmsim/reference/rand_leslie_set.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Generate a set of random Leslie Matrix Population Models — rand_leslie_set","text":"Returns CompadreDB object list containing MPMs life tables generated using specified model parameters drawn random uniform normal distributions. format output MPMs depends arguments output. Outputs may optionally scaled using argument scale_output ensure population growth rate (lambda) 1. output CompadreDB object, parameters models used produce MPM included metadata.","code":""},{"path":[]},{"path":"https://jonesor.github.io/mpmsim/reference/rand_leslie_set.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Generate a set of random Leslie Matrix Population Models — rand_leslie_set","text":"Owen Jones jones@biology.sdu.dk","code":""},{"path":"https://jonesor.github.io/mpmsim/reference/rand_leslie_set.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Generate a set of random Leslie Matrix Population Models — rand_leslie_set","text":"","code":"mortParams <- data.frame(   minVal = c(0, 0.01, 0.1),   maxVal = c(0.14, 0.15, 0.1) )  fecundityParams <- data.frame(   minVal = c(10, 0.5, 8),   maxVal = c(11, 0.9, 10) )  maturityParam <- c(0, 0)  rand_leslie_set(   n_models = 5,   mortality_model = \"gompertzmakeham\",   fecundity_model = \"normal\",   mortality_params = mortParams,   fecundity_params = fecundityParams,   fecundity_maturity_params = maturityParam,   dist_type = \"uniform\",   output = \"Type1\" ) #> A COM(P)ADRE database ('CompadreDB') object with ?? SPECIES and 5 MATRICES. #>  #> # A tibble: 5 × 10 #>   mat        mortality_model    b_0    b_1     C fecundity_model     A    mu #>   <list>     <chr>            <dbl>  <dbl> <dbl> <chr>           <dbl> <dbl> #> 1 <CompdrMt> gompertzmakeham 0.0250 0.0753   0.1 normal           10.2  10.4 #> 2 <CompdrMt> gompertzmakeham 0.101  0.106    0.1 normal           10.2  10.2 #> 3 <CompdrMt> gompertzmakeham 0.0275 0.0956   0.1 normal           10.0  10.7 #> 4 <CompdrMt> gompertzmakeham 0.120  0.0303   0.1 normal           10.6  10.8 #> 5 <CompdrMt> gompertzmakeham 0.0341 0.0305   0.1 normal           10.8  10.7 #> # ℹ 2 more variables: sd <dbl>, fecundity_scaling <dbl>"},{"path":"https://jonesor.github.io/mpmsim/reference/random_mpm.html","id":null,"dir":"Reference","previous_headings":"","what":"Generate random Lefkovitch matrix population models (MPMs) based on life history archetypes — random_mpm","title":"Generate random Lefkovitch matrix population models (MPMs) based on life history archetypes — random_mpm","text":"function deprecated. Use rand_lefko_mpm instead.","code":""},{"path":"https://jonesor.github.io/mpmsim/reference/random_mpm.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Generate random Lefkovitch matrix population models (MPMs) based on life history archetypes — random_mpm","text":"","code":"random_mpm(n_stages, fecundity, archetype = 1, split = FALSE)"},{"path":"https://jonesor.github.io/mpmsim/reference/random_mpm.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Generate random Lefkovitch matrix population models (MPMs) based on life history archetypes — random_mpm","text":"n_stages integer defining number stages MPM. fecundity Fecundity average number offspring produced. Values can provided 4 ways: numeric vector length 1 provide fecundity measure top right corner matrix model . numeric vector integers length equal n_stages provide fecundity estimates whole top row matrix model. Use 0 cases reproduction. matrix numeric values dimension n_stages provide fecundity estimates entire matrix model. Use 0 cases reproduction. list two matrices numeric values, dimension n_stages, provide lower upper estimates mean fecundity entire matrix model. latter case, fecundity value drawn uniform distribution defined range. reproduction particular age class, use value 0 lower upper limit. archetype Indication life history archetype used, based Takada et al. 2018. integer 1 4. split TRUE/FALSE, indicating whether matrix produced split survival matrix fertility matrix. Yeah true, output becomes list matrix element. Otherwise, output single matrix.","code":""},{"path":"https://jonesor.github.io/mpmsim/reference/random_mpm.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Generate random Lefkovitch matrix population models (MPMs) based on life history archetypes — random_mpm","text":"Returns random matrix population model characteristics determined archetype selected fecundity vector. split = TRUE, matrix split separate fertility growth/survival matrices, returned list.","code":""},{"path":"https://jonesor.github.io/mpmsim/reference/random_mpm.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Generate random Lefkovitch matrix population models (MPMs) based on life history archetypes — random_mpm","text":"Generates random matrix population model (MPM) element values based defined life history archetypes. Survival transition/growth probabilities particular stage restricted less equal 1 drawing Dirichlet distribution. user can specify archetypes (Takada et al. 2018) restrict MPMs ways: Archetype 1: elements positive, although may small. Therefore, transition /stage possible. model describes life history individuals can progress retrogress rapidly. Archetype 2: form archetype 1 (transition /stage possible), survival probability (column sums survival matrix) increases monotonously individuals advance later stages. model, one first archetype, also allows rapid progression retrogression, realistic stage-specific survival probability increases stage advancement. Archetype 3: positive non-zero elements survival allowed diagonal lower sub-diagonal matrix model represents life cycle species retrogression allowed, progression can happen immediately larger/developed stage (slow progression, e.g., trees). Archetype 4: archetype general form archetype 3, assumption stage-specific survival increases individuals increase size/developmental stage. respect similar archetype 2. 4 Archetypes, fecundity placed single element top right matrix, single value. vector length n_stages fertility vector spans entire top row matrix. function constrained output ergodic matrices.","code":""},{"path":"https://jonesor.github.io/mpmsim/reference/random_mpm.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Generate random Lefkovitch matrix population models (MPMs) based on life history archetypes — random_mpm","text":"Caswell, H. (2001). Matrix Population Models: Construction, Analysis, Interpretation. Sinauer. Lefkovitch, L. P. (1965). study population growth organisms grouped stages. Biometrics, 21(1), 1. Takada, T., Kawai, Y., & Salguero-Gómez, R. (2018). cautionary note elasticity analyses ternary plot using randomly generated population matrices. Population Ecology, 60(1), 37–47.","code":""},{"path":[]},{"path":"https://jonesor.github.io/mpmsim/reference/random_mpm.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Generate random Lefkovitch matrix population models (MPMs) based on life history archetypes — random_mpm","text":"Owen Jones jones@biology.sdu.dk","code":""},{"path":"https://jonesor.github.io/mpmsim/reference/random_mpm.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Generate random Lefkovitch matrix population models (MPMs) based on life history archetypes — random_mpm","text":"","code":"set.seed(42) # set seed for repeatability  random_mpm(n_stages = 2, fecundity = 20, archetype = 1, split = FALSE) #> Warning: 'random_mpm' is deprecated. #> Use 'rand_lefko_mpm' instead. #> See help(\"Deprecated\") #>            [,1]       [,2] #> [1,] 0.73066610 20.0402850 #> [2,] 0.06797628  0.7190785 random_mpm(n_stages = 2, fecundity = 20, archetype = 2, split = TRUE) #> Warning: 'random_mpm' is deprecated. #> Use 'rand_lefko_mpm' instead. #> See help(\"Deprecated\") #> $mat_A #>           [,1]        [,2] #> [1,] 0.5129277 20.78121699 #> [2,] 0.2895418  0.04959239 #>  #> $mat_U #>           [,1]       [,2] #> [1,] 0.5129277 0.78121699 #> [2,] 0.2895418 0.04959239 #>  #> $mat_F #>      [,1] [,2] #> [1,]    0   20 #> [2,]    0    0 #>  random_mpm(n_stages = 3, fecundity = 20, archetype = 3, split = FALSE) #> Warning: 'random_mpm' is deprecated. #> Use 'rand_lefko_mpm' instead. #> See help(\"Deprecated\") #>            [,1]      [,2]       [,3] #> [1,] 0.26019259 0.0000000 20.0000000 #> [2,] 0.09187956 0.8172080  0.0000000 #> [3,] 0.00000000 0.1640643  0.1762325 random_mpm(n_stages = 4, fecundity = 20, archetype = 4, split = TRUE) #> Warning: 'random_mpm' is deprecated. #> Use 'rand_lefko_mpm' instead. #> See help(\"Deprecated\") #> $mat_A #>            [,1]       [,2]      [,3]       [,4] #> [1,] 0.24002446 0.00000000 0.0000000 20.0000000 #> [2,] 0.03254107 0.05480185 0.0000000  0.0000000 #> [3,] 0.00000000 0.62726117 0.7851646  0.0000000 #> [4,] 0.00000000 0.00000000 0.0786406  0.9661587 #>  #> $mat_U #>            [,1]       [,2]      [,3]      [,4] #> [1,] 0.24002446 0.00000000 0.0000000 0.0000000 #> [2,] 0.03254107 0.05480185 0.0000000 0.0000000 #> [3,] 0.00000000 0.62726117 0.7851646 0.0000000 #> [4,] 0.00000000 0.00000000 0.0786406 0.9661587 #>  #> $mat_F #>      [,1] [,2] [,3] [,4] #> [1,]    0    0    0   20 #> [2,]    0    0    0    0 #> [3,]    0    0    0    0 #> [4,]    0    0    0    0 #>  random_mpm(   n_stages = 5, fecundity = c(0, 0, 4, 8, 10), archetype = 4,   split = TRUE ) #> Warning: 'random_mpm' is deprecated. #> Use 'rand_lefko_mpm' instead. #> See help(\"Deprecated\") #> $mat_A #>             [,1]      [,2]      [,3]      [,4]       [,5] #> [1,] 0.008672344 0.0000000 4.0000000 8.0000000 10.0000000 #> [2,] 0.027810843 0.2560970 0.0000000 0.0000000  0.0000000 #> [3,] 0.000000000 0.5284182 0.1992335 0.0000000  0.0000000 #> [4,] 0.000000000 0.0000000 0.6157474 0.3219698  0.0000000 #> [5,] 0.000000000 0.0000000 0.0000000 0.6398980  0.9915655 #>  #> $mat_U #>             [,1]      [,2]      [,3]      [,4]      [,5] #> [1,] 0.008672344 0.0000000 0.0000000 0.0000000 0.0000000 #> [2,] 0.027810843 0.2560970 0.0000000 0.0000000 0.0000000 #> [3,] 0.000000000 0.5284182 0.1992335 0.0000000 0.0000000 #> [4,] 0.000000000 0.0000000 0.6157474 0.3219698 0.0000000 #> [5,] 0.000000000 0.0000000 0.0000000 0.6398980 0.9915655 #>  #> $mat_F #>      [,1] [,2] [,3] [,4] [,5] #> [1,]    0    0    4    8   10 #> [2,]    0    0    0    0    0 #> [3,]    0    0    0    0    0 #> [4,]    0    0    0    0    0 #> [5,]    0    0    0    0    0 #>  # Using a range of values for fecundity random_mpm(n_stages = 2, fecundity = 20, archetype = 1, split = TRUE) #> Warning: 'random_mpm' is deprecated. #> Use 'rand_lefko_mpm' instead. #> See help(\"Deprecated\") #> $mat_A #>           [,1]        [,2] #> [1,] 0.2558635 20.54431954 #> [2,] 0.0543606  0.07233605 #>  #> $mat_U #>           [,1]       [,2] #> [1,] 0.2558635 0.54431954 #> [2,] 0.0543606 0.07233605 #>  #> $mat_F #>      [,1] [,2] #> [1,]    0   20 #> [2,]    0    0 #>"},{"path":"https://jonesor.github.io/mpmsim/reference/reorganise_matrices.html","id":null,"dir":"Reference","previous_headings":"","what":"Reorganise Matrix Population Models — reorganise_matrices","title":"Reorganise Matrix Population Models — reorganise_matrices","text":"function reorganises list matrix population models, split mat_A, mat_U, mat_F, optionally mat_C sub-matrices. prepares matrices easy conversion compadreDB object.","code":""},{"path":"https://jonesor.github.io/mpmsim/reference/reorganise_matrices.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Reorganise Matrix Population Models — reorganise_matrices","text":"","code":"reorganise_matrices(matrix_list)"},{"path":"https://jonesor.github.io/mpmsim/reference/reorganise_matrices.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Reorganise Matrix Population Models — reorganise_matrices","text":"matrix_list list lists, sub-list contains matrices mat_A, mat_U, mat_F, optionally mat_C.","code":""},{"path":"https://jonesor.github.io/mpmsim/reference/reorganise_matrices.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Reorganise Matrix Population Models — reorganise_matrices","text":"list containing four elements: mat_A, mat_U, mat_F, mat_C. element list matrices corresponding respective matrix type input. mat_C exist sub-list, replaced NA matrix dimensions mat_U.","code":""},{"path":"https://jonesor.github.io/mpmsim/reference/reorganise_matrices.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Reorganise Matrix Population Models — reorganise_matrices","text":"function processes list matrix population models, extracting grouping sub-matrices (mat_A, mat_U, mat_F, optionally mat_C) separate lists. mat_C matrix present model, NA matrix size mat_U used placeholder.","code":""},{"path":[]},{"path":"https://jonesor.github.io/mpmsim/reference/reorganise_matrices.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Reorganise Matrix Population Models — reorganise_matrices","text":"Owen Jones jones@biology.sdu.dk","code":""},{"path":"https://jonesor.github.io/mpmsim/reference/reorganise_matrices.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Reorganise Matrix Population Models — reorganise_matrices","text":"","code":"# Example usage matrix_list <- list(   list(     mat_A = matrix(1, 2, 2),     mat_U = matrix(2, 2, 2),     mat_F = matrix(3, 2, 2),     mat_C = matrix(4, 2, 2)   ),   list(     mat_A = matrix(5, 2, 2),     mat_U = matrix(6, 2, 2),     mat_F = matrix(7, 2, 2)   ) ) reorganised_matrices <- reorganise_matrices(matrix_list) reorganised_matrices$mat_A #> [[1]] #>      [,1] [,2] #> [1,]    1    1 #> [2,]    1    1 #>  #> [[2]] #>      [,1] [,2] #> [1,]    5    5 #> [2,]    5    5 #>"},{"path":"https://jonesor.github.io/mpmsim/reference/summarise_mpms.html","id":null,"dir":"Reference","previous_headings":"","what":"Summarise Matrix Population Models — summarise_mpms","title":"Summarise Matrix Population Models — summarise_mpms","text":"Calculates summarises various metrics matrix population models (MPMs) including dimension (= age Leslie matrices), lambda values, maximum fecundity values, maximum growth/survival transition probabilities, minimum non-zero growth/survival transition probabilities","code":""},{"path":"https://jonesor.github.io/mpmsim/reference/summarise_mpms.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Summarise Matrix Population Models — summarise_mpms","text":"","code":"summarise_mpms(x)"},{"path":"https://jonesor.github.io/mpmsim/reference/summarise_mpms.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Summarise Matrix Population Models — summarise_mpms","text":"x compadreDB object containing matrix population models, typically format compatible matA, matU, matF functions.","code":""},{"path":"https://jonesor.github.io/mpmsim/reference/summarise_mpms.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Summarise Matrix Population Models — summarise_mpms","text":"function prints summaries following metrics: lambda values: lambda values (dominant eigenvalues) matrices. max F values: maximum values F matrices. max U values: maximum values U matrices. minimum non-zero U values: minimum non-zero values U matrices.","code":""},{"path":[]},{"path":"https://jonesor.github.io/mpmsim/reference/summarise_mpms.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Summarise Matrix Population Models — summarise_mpms","text":"","code":"mats <- rand_lefko_set(   n = 10, n_stages = 5, fecundity = c(0, 0, 4, 8, 10),   archetype = 4, output = \"Type1\" )  summarise_mpms(mats) #> Summary of matrix dimension: #>    Min. 1st Qu.  Median    Mean 3rd Qu.    Max.  #>       5       5       5       5       5       5  #> Summary of lambda values: #>    Min. 1st Qu.  Median    Mean 3rd Qu.    Max.  #>   1.000   1.060   1.173   1.194   1.232   1.628  #>  #> Summary of maximum F values: #>    Min. 1st Qu.  Median    Mean 3rd Qu.    Max.  #>      10      10      10      10      10      10  #>  #> Summary of maximum U values: #>    Min. 1st Qu.  Median    Mean 3rd Qu.    Max.  #>  0.9194  0.9372  0.9687  0.9590  0.9761  0.9869  #>  #> Summary of minimum non-zero U values: #>      Min.   1st Qu.    Median      Mean   3rd Qu.      Max.  #> 0.0006678 0.0074466 0.0190447 0.0341075 0.0438259 0.1366390"},{"path":"https://jonesor.github.io/mpmsim/news/index.html","id":"mpmsim-development-version","dir":"Changelog","previous_headings":"","what":"mpmsim (development version)","title":"mpmsim (development version)","text":"minor bug fixes documentation improvements.","code":""},{"path":"https://jonesor.github.io/mpmsim/news/index.html","id":"mpmsim-310","dir":"Changelog","previous_headings":"","what":"mpmsim 3.1.0","title":"mpmsim 3.1.0","text":"CRAN release: 2024-10-12 Added function synonym: model_reproduction() synonymous model_fertility model_fecundity. Improved documentation including three vignettes focussing Leslie models, Lefkovitch models, error propagation respectively. Fixed minor typographical errors documentation.","code":""},{"path":"https://jonesor.github.io/mpmsim/news/index.html","id":"mpmsim-300","dir":"Changelog","previous_headings":"","what":"mpmsim 3.0.0","title":"mpmsim 3.0.0","text":"CRAN release: 2024-07-01 sets matrices returned CompadreDB objects, archetype (Lefkovitch) model parameters (Leslie), now included metadata. Added function rand_leslie_set() generate sets Leslie matrices parameters constituent mortality fertility functions drawn randomly defined distributions. function returns CompadreDB object default, can also set produce lists MPMs life tables. generate_mpm_set() now deprecated, removed later date. Users use rand_lefko_set() instead. random_mpm() now deprecated, removed later date. Users use rand_lefko_mpm() instead. new set generation functions omit arguments split, by_type as_compadre, governed output types generate_mpm_set(). arguments replaced simpler transparent argument, output. Added new function compute_ci_U() calculates confidence intervals traits derived matrix models U submatrix used. example, life expectancy (using function Rage::life_expect_mean()). Added vignette generating Leslie matrices. Added vignette generating Lefkovitch matrices.","code":""},{"path":"https://jonesor.github.io/mpmsim/news/index.html","id":"mpmsim-200","dir":"Changelog","previous_headings":"","what":"mpmsim 2.0.0","title":"mpmsim 2.0.0","text":"CRAN release: 2024-01-15 removed dependency MCMCpack, reportedly archived CRAN. change means previous versions mpmsim may function correctly advisable update new version.","code":""},{"path":"https://jonesor.github.io/mpmsim/news/index.html","id":"mpmsim-110","dir":"Changelog","previous_headings":"","what":"mpmsim 1.1.0","title":"mpmsim 1.1.0","text":"CRAN release: 2023-09-29 modified simulation fecundity random_mpm(). Now values provided mean fecundity can provided range values, whereby value drawn random uniform distribution. best way create set models different fecundity properties. added function simulate action drivers weather vital rates: drive_vital_rate(). added model_mortality() alias model_survival(). function generate_mpm_set() now returns CompadreDB object default. added full suite unit tests using testthat. Test coverage 97.17%.","code":""},{"path":"https://jonesor.github.io/mpmsim/news/index.html","id":"mpmsim-100","dir":"Changelog","previous_headings":"","what":"mpmsim 1.0.0","title":"mpmsim 1.0.0","text":"CRAN release: 2023-04-18","code":""},{"path":"https://jonesor.github.io/mpmsim/news/index.html","id":"first-release-with-the-following-functionality-1-0-0","dir":"Changelog","previous_headings":"","what":"First release, with the following functionality.","title":"mpmsim 1.0.0","text":"Functions simulating Lefkovitch matrix models: generate_mpm_set() andrandom_mpm(). function constructing Leslie matrix models: make_leslie_mpm(), can make use outputs functions describing demographic trajectories (model_fertility() model_survival()). Functions calculating propagating error: add_mpm_error(), calculate_errors() compute_ci(). utility function: plot_matrix()","code":""}]
