[{"path":"https://jonesor.github.io/mpmsim/articles/age_from_stage.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"The robustness of age from stage methods","text":"Stage-classified matrix population models (Lefkovitch models), valuable tools studying population dynamics, especially cases organism demography dependent ontogenetic stage populations age determination difficult. analysis models often adequate, situations age-related information desired, Leslie matrix life table. Cochran Ellner (1992) developed methods obtain age-related life history traits breaking transition matrix birth, survival, fission matrices. methods allow calculation discrete survivorship maternity functions. two fundamental trajectories, various life history metrics can calculated including mean age maturity, generation time, age-specific reproductive value, senescence measures. well methods really perform? example, perform equally well functional forms mortality? Can capture differences senescence rate? following vignette illustrates mpmsim can used address one questions.","code":""},{"path":"https://jonesor.github.io/mpmsim/articles/age_from_stage.html","id":"age-from-stage","dir":"Articles","previous_headings":"","what":"Age-from-stage","title":"The robustness of age from stage methods","text":"First load required packages. Next use model_survival() function create list age-specific survival trajectories based Gompertz mortality function senescence rates (b_1_values) varying 0.1 0.9. values basis life tables. analysis want convert age-based trajectories stage-based matrix models. divide yearly age entries stages. arbitrary way dividing age vector 3 parts: quarter juveniles, half adult, another quarter old individuals. Next ’ll add fertility life tables. Let’s take look one life tables data preparation far clear. important columns age (x), survival (px), fertility (fert) stage (see ?mpm_to_table explanation columns life table). next step turn life tables matching pairs (1) Leslie matrices (2) stage-based matrices.","code":"library(mpmsim) library(dplyr) library(Rage) b_1_values <- seq(0.1, 0.9, 0.1) lifeTables <- list() for (i in 1:length(b_1_values)) {   lifeTables[[i]] <- model_survival(     params = c(b_0 = 0.1, b_1 = b_1_values[i]),     model = \"Gompertz\"   ) } for (i in 1:length(lifeTables)) {   lifeTables[[i]] <- lifeTables[[i]] |>     mutate(stage = ifelse(x <= round(max(x) * 0.25), 1,       ifelse(x <= round(max(x) * 0.75), 2, 3)     )) } for (i in 1:length(lifeTables)) {   lifeTables[[i]] <- lifeTables[[i]] |>     mutate(fert = model_fertility(       age = x, params = c(A = 3),       maturity = min(x[stage == 2]),       model = \"step\"     )) } lifeTables[[5]] #>   x        hx         lx        qx         px stage fert #> 1 0 0.1000000 1.00000000 0.1240411 0.87595894     1    0 #> 2 1 0.1648721 0.87595894 0.1961561 0.80384392     1    0 #> 3 2 0.2718282 0.70413427 0.3023227 0.69767734     1    0 #> 4 3 0.4481689 0.49125852 0.4476301 0.55236995     2    3 #> 5 4 0.7389056 0.27135645 0.6241546 0.37584536     2    3 #> 6 5 1.2182494 0.10198806 0.8007912 0.19920884     3    3 #> 7 6 2.0085537 0.02031692 0.9300552 0.06994476     3    3"},{"path":"https://jonesor.github.io/mpmsim/articles/age_from_stage.html","id":"leslie-matrices","dir":"Articles","previous_headings":"Age-from-stage","what":"Leslie matrices","title":"The robustness of age from stage methods","text":"First Now can turn life tables containing age-specific survival fertility trajectories Leslie matrices using make_leslie_mpm function. matrix models can large small depending maximum life span population: life tables , default, constrained extend age survivorship function falls 0.01. Let’s examine Leslie matrix matches life table previous section.","code":"leslie_matrices <- list() for (i in 1:length(lifeTables)) {   leslie_matrices[[i]] <- make_leslie_mpm(     survival = lifeTables[[i]]$px,     fertility = lifeTables[[i]]$fert,     n_stages = nrow(lifeTables[[i]]), split = TRUE   ) } leslie_matrices[[5]]$matA #>           [,1]      [,2]      [,3]      [,4]      [,5]      [,6]       [,7] #> [1,] 0.0000000 0.0000000 0.0000000 3.0000000 3.0000000 3.0000000 3.00000000 #> [2,] 0.8759589 0.0000000 0.0000000 0.0000000 0.0000000 0.0000000 0.00000000 #> [3,] 0.0000000 0.8038439 0.0000000 0.0000000 0.0000000 0.0000000 0.00000000 #> [4,] 0.0000000 0.0000000 0.6976773 0.0000000 0.0000000 0.0000000 0.00000000 #> [5,] 0.0000000 0.0000000 0.0000000 0.5523699 0.0000000 0.0000000 0.00000000 #> [6,] 0.0000000 0.0000000 0.0000000 0.0000000 0.3758454 0.0000000 0.00000000 #> [7,] 0.0000000 0.0000000 0.0000000 0.0000000 0.0000000 0.1992088 0.06994476"},{"path":"https://jonesor.github.io/mpmsim/articles/age_from_stage.html","id":"lefkovitch-matrices","dir":"Articles","previous_headings":"Age-from-stage","what":"Lefkovitch matrices","title":"The robustness of age from stage methods","text":"Leslie matrices can now construct stage-structured matrix models (Lefkovitch models) using mpm_collapse() function Rage. Let’s examine Lefkovitch matrix matches Leslie matrix life table previous seections:","code":"collapsed_matrices <- list() for (i in 1:length(lifeTables)) {   stages <- lifeTables[[i]]$stage   matrices <- leslie_matrices[[i]]   collapse_list <- split(stages, stages)   # get the indices of each element in the original vector   collapse_list <- lapply(collapse_list, function(x) which(stages %in% x))    collapsed_matrices[[i]] <- Rage::mpm_collapse(     matU = matrices$mat_U,     matF = matrices$mat_F, collapse = collapse_list   ) } collapsed_matrices[[5]]$matA #>           1         2        3 #> 1 0.6670591 3.0000000 3.000000 #> 2 0.1476356 0.3821296 0.000000 #> 3 0.0000000 0.1158355 0.180401"},{"path":"https://jonesor.github.io/mpmsim/articles/age_from_stage.html","id":"recovering-age-specific-trajectories-from-the-stage-based-model","dir":"Articles","previous_headings":"","what":"Recovering age-specific trajectories from the stage-based model","title":"The robustness of age from stage methods","text":"Next can use age-stage-approximation see well can recover “true” values original Leslie matrix/life table. plot, red curve represents “true” values survivorship life table black curve represents estimation survivorship using age--stage approximation.","code":"recovered_life_tables <- list() for (i in 1:length(lifeTables)) { m1 <- collapsed_matrices[[i]] recovered_life_tables[[i]] <- Rage::mpm_to_table(matU = m1$matU, matF = m1$matF,                                             remove_final = TRUE) } i <- 5 recovered_lt <- recovered_life_tables[[i]]  plot(0:(length(recovered_lt$lx) - 1),       recovered_lt$lx, type = \"l\",       xlab = \"age\", ylab = \"survivorship\", main =\"Survivorship\") lines(lifeTables[[i]]$x, lifeTables[[i]]$lx, type = \"l\", col = \"red\")"},{"path":"https://jonesor.github.io/mpmsim/articles/age_from_stage.html","id":"mortality-and-longevity","dir":"Articles","previous_headings":"","what":"Mortality and longevity","title":"The robustness of age from stage methods","text":"also look life table trajectories mortality (hazard).  plot clearly shows mortality (hazard) underestimated across life course trajectory markedly different underlying Gompertz trajectory. caused known issue population structure reaching stationary state: population reaches state, rate change mortality/survival trajectory asymptote zero. can now examine -estimation life span using age--stage methods related Gompertz parameter like .","code":"plot(0:(length(recovered_lt$lx) - 1),       recovered_lt$hx, type = \"l\",       xlab = \"age\", ylab = \"mortality\", main = \"mortality\", ylim = c(0,2)) lines(lifeTables[[i]]$x, lifeTables[[i]]$hx, type = \"l\", col = \"red\") df1 <- data.frame(b_1_values,lifespan_lt = NA, lifespan_afs = NA) for(i in 1:length(lifeTables)){   df1$lifespan_lt[i] <- max(lifeTables[[i]]$x)   df1$lifespan_afs[i] <- max(recovered_life_tables[[i]]$x) }  df1 <- df1 %>%    mutate(lifespan_diff  = lifespan_afs-lifespan_lt) %>%    mutate(lifespan_diff_perc  = 100*(lifespan_diff/lifespan_lt))  plot(df1$b_1_values, df1$lifespan_diff_perc, type = \"b\",       ylab = \"Lifespan overestimation (%)\", xlab = \"Gompertz parameter\")"},{"path":"https://jonesor.github.io/mpmsim/articles/age_from_stage.html","id":"further-questions","dir":"Articles","previous_headings":"","what":"Further questions?","title":"The robustness of age from stage methods","text":"explained elsewhere, issue can ameliorated examining convergence quasi-stationary state (QSD) (see ?Rage::qsd_converge()) affects mortality/survival fertility. One use methods outlined explore issues thoroughly (example) checking age--stage methods perform different life histories different functional forms mortality (see ?mpmsim::model_survival()) fertility. (?mpmsim::model_fertility()).","code":""},{"path":"https://jonesor.github.io/mpmsim/articles/error_propagation.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"Sampling error and its propagation","text":"Uncertainty individual matrix elements matrix population model can lead sampling errors, propagate affect accuracy estimates MPM-derived metrics. metrics include population growth rate, generation time, reactivity many others. One way estimate uncertainty using bootstrapping approach whereby sampling distribution matrix model generated, based assumptions underlying processes matrix model uncertainties individual matrix elements. example, can assume fertility component matrix mean multiple Poisson processes, survival can modeled binomial process. compute_ci() function allows users estimate 95% confidence interval metric can derived matrix population model (). function generates sampling distribution resampling based assumptions calculates posterior distribution metric interest. lower upper bounds 95% CI estimated distribution. width CI reflects precision estimate; narrower CI indicates greater precision, wider CI indicates less precision. Various factors can influence width shape CI, sample size used estimate individual matrix elements, structure matrix model, underlying assumptions made compute_ci() function, distribution uncertainties individual matrix elements. crucial consider factors interpreting results matrix population model assessing precision resulting estimates.","code":""},{"path":"https://jonesor.github.io/mpmsim/articles/error_propagation.html","id":"estimate-95-ci-of-lambda","dir":"Articles","previous_headings":"","what":"Estimate 95% CI of lambda","title":"Sampling error and its propagation","text":"estimate 95% CI metric can calculated matrix model. example focus population growth rate, lambda. Let’s consider matrix model composed submatrices U F. need “split” matrix underlying processes governed distributions different statistical properties. assumed individual’s survival binary (0 = dies, 1 = survives) individual’s reproduction assumed Poisson process. example, matrix simple, top right element represents reproduction, elements represent survival /growth. \\[ \\mathbf{} = \\begin{bmatrix} 0.1 & 3.0 \\\\ 0.2 & 0.4 \\ \\end{bmatrix} \\] Thus: know sample size used estimate element matrix 20 individuals, can estimate downstream 95% confidence intervals , say lambda, follows: Note necessary use sample size element: sample size information can provided matrix integers can vary across matrix. can examine posterior distribution lambda estimates estimates using argument dist.= TRUE.","code":"matU <- matrix(c(   0.1, 0.0,   0.2, 0.4 ), byrow = TRUE, nrow = 2)  matF <- matrix(c(   0.0, 3.0,   0.0, 0.0 ), byrow = TRUE, nrow = 2) compute_ci(mat_U = matU, mat_F = matF, sample_size = 20, FUN = popdemo::eigs, what = \"lambda\") #>      2.5%     97.5%  #> 0.6194733 1.4010436 distLambda_20 <- compute_ci(mat_U = matU, mat_F = matF,                              sample_size = 20, FUN = popdemo::eigs, what = \"lambda\",                              dist.out = TRUE) hist(distLambda_20$estimates)"},{"path":"https://jonesor.github.io/mpmsim/articles/error_propagation.html","id":"exploring-the-impact-of-sample-size","dir":"Articles","previous_headings":"","what":"Exploring the impact of sample size","title":"Sampling error and its propagation","text":"sample size considerably larger, 100? Comparing two distributions, unsurprising posterior distribution large sample size narrower small sample size.  One use approach conduct power analysis simulation. example one ask, “sample size require order detect 20% change population growth rate?”  sample size higher elements others? problem, sample_size argument accepts matrix sample sizes (list matrices labelled mat_U_ss mat_F_ss).","code":"distLambda_100 <- compute_ci(mat_U = matU, mat_F = matF,                               sample_size = 100, FUN = popdemo::eigs, what = \"lambda\",                               dist.out = TRUE) par(mfrow = c(2, 1)) hist(distLambda_20$estimates, xlim = c(0, 1.75)) hist(distLambda_100$estimates, xlim = c(0, 1.75)) observedLambda <- popdemo::eigs(matU + matF, what = \"lambda\") reducedLambda <- observedLambda*0.8   simDist <- compute_ci(mat_U = matU, mat_F = matF,                               sample_size = 50, FUN = popdemo::eigs, what = \"lambda\",                               dist.out = TRUE)$estimates hist(simDist) abline(v = observedLambda,lty = 2, lwd = 2) abline(v = reducedLambda,lty = 2, lwd = 2, col= \"red\") sum(simDist<observedLambda)/length(simDist) #> [1] 0.531 sample_size_mat <- matrix(c(   20, 100,   20, 20 ), byrow = TRUE, nrow = 2)  distLambda_variable <- compute_ci(mat_U = matU, mat_F = matF,                                    sample_size = sample_size_mat,                                    FUN = popdemo::eigs, what = \"lambda\",                                    dist.out = TRUE) hist(distLambda_variable$estimates) par(mfrow = c(3, 1)) hist(distLambda_20$estimates, xlim = c(0, 1.75)) hist(distLambda_100$estimates, xlim = c(0, 1.75)) hist(distLambda_variable$estimates, xlim = c(0, 1.75)) popdemo::elas(matU + matF) #>            [,1]      [,2] #> [1,] 0.03897464 0.3659667 #> [2,] 0.36596672 0.2290919"},{"path":"https://jonesor.github.io/mpmsim/articles/pca.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"Exploring PCA space","text":"Several interesting analyses used MPMs many species explore life history strategies using principal components analysis (PCA). potential criticism studies underlying data biased towards certain taxa, life histories, biomes. unclear much bias influence observed patterns. therefore useful simulate realistic MPMs explore potential artefactual patterns emerge biased data. show mpmsim can help task enable exploration PCA space aid understanding life history strategies.","code":""},{"path":"https://jonesor.github.io/mpmsim/articles/pca.html","id":"simulating-data-for-a-pca","dir":"Articles","previous_headings":"","what":"Simulating data for a PCA","title":"Exploring PCA space","text":"Load required packages First use generate_mpm_set() simulate 500 matrices archetype 1 life history Takada et al. (2018). life history archetype one transition /stage possible individuals can progress retrogress rapidly. simulating matrices can placed CompadreDB object using cdb_build_cdb(). matrices reducible, leads analytical problems calculations can filtered using cdb_flag() followed filter(). convenience, matrices can added compadreDB object like , turned regular data frame (tibble) like . proceeding calculation life history traits make new function, gt_lt, calculate generation time life table. Now can use combination sapply mapply calculate life history traits matrix model. Now added variables data set can extract dataset PCA. can run PCA, add first two principle components data frame plotting purposes. plot can made using autoplot, ggfortify package.  PCA loadings show two strong axes. One evolutionary entropy, longevity, generation time life expectancy aligned, one R0 . Life table entropy aligned less equaly . rather different pattern can observed real data. ?","code":"library(mpmsim) library(Rage) library(Rcompadre) library(dplyr) library(ggfortify) library(viridis) library(popbio) set.seed(42) constrain_df <- data.frame(fun = \"lambda\", arg = NA, lower = 0.9, upper = 1.1) mpm_set <- generate_mpm_set(   n = 500, n_stages = 3, fecundity = c(0, 6, 6), archetype = 1, split = TRUE,   max_surv = 0.95, constraint = constrain_df )  sim_life_hist_1 <- cdb_build_cdb(mat_u = mpm_set$U_list, mat_f = mpm_set$F_list) #> Warning in cdb_build_cdb(mat_u = mpm_set$U_list, mat_f = mpm_set$F_list): #> Metadata does not include a `SpeciesAccepted` column, so number of species not #> provided when viewing object. sim_life_hist_1 <- cdb_flag(sim_life_hist_1, checks = \"check_irreducible\") %>%   filter(check_irreducible == TRUE) # Put the matrices into the metadata sim_life_hist_1$matA <- matA(sim_life_hist_1) sim_life_hist_1$matU <- matU(sim_life_hist_1) sim_life_hist_1$matF <- matF(sim_life_hist_1)  # Use cdb_metadata to turn this into a data frame sim_life_hist_1 <- cdb_metadata(sim_life_hist_1) # New functions to calculate generation time from life table. # Function to calculate generation time from the life table gt_lt <- function(matU, matF, start = 1, ...) {   tempLT <- mpm_to_table(matU, matF, start = start, ...)   return(sum(tempLT$x * tempLT$lxmx) / sum(tempLT$lxmx)) } sim_life_hist_1$gt_lt <- mapply(gt_lt, sim_life_hist_1$matU, sim_life_hist_1$matF) sim_life_hist_1$longevity <- sapply(sim_life_hist_1$matU, Rage::longevity,   x_max = 1000, lx_crit = 0.01 ) sim_life_hist_1$lifeExpect <- sapply(sim_life_hist_1$matU, Rage::life_expect_mean) sim_life_hist_1$entropy_d <- mapply(   entropy_d, sim_life_hist_1$matU,   sim_life_hist_1$matF ) sim_life_hist_1$entropy_k <- mapply(entropy_k, sim_life_hist_1$matU) sim_life_hist_1$nrr_R0 <- mapply(   net_repro_rate, sim_life_hist_1$matU,   sim_life_hist_1$matF ) pcData <- sim_life_hist_1 %>%   select(gt_lt, longevity, lifeExpect, entropy_d, entropy_k, nrr_R0) %>%   na.omit() PCA <- prcomp(pcData, scale = TRUE, center = TRUE)  # Add the PC data to the raw data. pcData <- pcData %>%   cbind(PCA$x[, 1:2]) PCA_plot <- autoplot(   object = PCA, alpha = 0, size = 4, fill = \"#55616D60\",   loadings.colour = \"#0072B2\", shape = 16,   loadings = TRUE, loadings.label = TRUE, loadings.label.colour = \"red\",   loadings.label.size = 3, loadings.label.repel = TRUE,   frame = FALSE, frame.type = \"norm\", scale = 0 )  PCA_plot$layers <- c(   geom_point(aes_(     x = pcData$PC1,     y = pcData$PC2   ),   size = 2, alpha = .5   ),   PCA_plot$layers )  PCA_plot"},{"path":"https://jonesor.github.io/mpmsim/articles/pca.html","id":"repeating-with-a-different-archetype","dir":"Articles","previous_headings":"","what":"Repeating with a different archetype","title":"Exploring PCA space","text":"repeat whole analysis different archetype (4) get following plot.","code":"#> # A tibble: 6 × 5 #>   matrixID check_irreducible matA          matU          matF          #>      <int> <lgl>             <list>        <list>        <list>        #> 1        1 TRUE              <dbl [3 × 3]> <dbl [3 × 3]> <dbl [3 × 3]> #> 2        2 TRUE              <dbl [3 × 3]> <dbl [3 × 3]> <dbl [3 × 3]> #> 3        3 TRUE              <dbl [3 × 3]> <dbl [3 × 3]> <dbl [3 × 3]> #> 4        4 TRUE              <dbl [3 × 3]> <dbl [3 × 3]> <dbl [3 × 3]> #> 5        5 TRUE              <dbl [3 × 3]> <dbl [3 × 3]> <dbl [3 × 3]> #> 6        6 TRUE              <dbl [3 × 3]> <dbl [3 × 3]> <dbl [3 × 3]>"},{"path":"https://jonesor.github.io/mpmsim/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Owen Jones. Author, maintainer.","code":""},{"path":"https://jonesor.github.io/mpmsim/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Jones O (2023). mpmsim: Simulates Matrix Population Models Particular Life History Characteristics. R package version 0.1.0.9000, https://github.com/jonesor/mpmsim.","code":"@Manual{,   title = {mpmsim: Simulates Matrix Population Models with Particular Life History Characteristics},   author = {Owen Jones},   year = {2023},   note = {R package version 0.1.0.9000},   url = {https://github.com/jonesor/mpmsim}, }"},{"path":"https://jonesor.github.io/mpmsim/index.html","id":"mpmsim-","dir":"","previous_headings":"","what":"Simulates Matrix Population Models with Particular Life History\n    Characteristics","title":"Simulates Matrix Population Models with Particular Life History\n    Characteristics","text":"mpmsim contains tools generating random semi-random matrix population models (MPMs) given particular life history archetype. also facilitates generation Leslie matrices, simulation MPMs based expected transition rates sample sizes. can useful exploring uncertainty inferences sample sizes small (unknown).","code":""},{"path":"https://jonesor.github.io/mpmsim/index.html","id":"installation","dir":"","previous_headings":"","what":"Installation","title":"Simulates Matrix Population Models with Particular Life History\n    Characteristics","text":"can install development version mpmsim like :","code":"# install package 'remotes' if necessary # will already be installed if 'devtools' is installed install.packages(\"remotes\")  # argument 'build_opts = NULL' only needed if you want to build vignettes remotes::install_github(\"jonesor/mpmsim\", build_opts = NULL)"},{"path":"https://jonesor.github.io/mpmsim/index.html","id":"usage","dir":"","previous_headings":"","what":"Usage","title":"Simulates Matrix Population Models with Particular Life History\n    Characteristics","text":"First, load package.","code":"library(mpmsim)"},{"path":"https://jonesor.github.io/mpmsim/index.html","id":"generate-a-leslie-matrix","dir":"","previous_headings":"Usage","what":"Generate a Leslie matrix","title":"Simulates Matrix Population Models with Particular Life History\n    Characteristics","text":"make_leslie_mpm function can used generate Leslie matrix, stages represent discrete age classes. Leslie matrix, survival represented lower sub-diagonal lower-right-hand corner element, fertility shown top row. survival fertility length equal number stages model. Users can specify survival fertility either single value vector values, length equal dimensions matrix model. arguments single values, value repeated along survival/fertility sequence.","code":"make_leslie_mpm(   survival = seq(0.1, 0.45, length.out = 4),   fertility = c(0, 0, 2.4, 5), n_stages = 4, split = FALSE ) #>      [,1]      [,2]      [,3] [,4] #> [1,]  0.0 0.0000000 2.4000000 5.00 #> [2,]  0.1 0.0000000 0.0000000 0.00 #> [3,]  0.0 0.2166667 0.0000000 0.00 #> [4,]  0.0 0.0000000 0.3333333 0.45"},{"path":"https://jonesor.github.io/mpmsim/index.html","id":"using-a-functional-form-for-mortality","dir":"","previous_headings":"Usage","what":"Using a functional form for mortality","title":"Simulates Matrix Population Models with Particular Life History\n    Characteristics","text":"Users can generate Leslie matrices particular functional forms mortality first making data frame simplified life table includes age survival probability within age interval. Age-specific survival probability given px column output model_survival. Users can also use functional form fertility (see model_fertility) simple step function assumed. Subsequently, survival fertility values can applied Leslie matrix follows.","code":"(surv_prob <- model_survival(params = c(0.2, 0.4), model = \"Gompertz\")) #>   x        hx         lx        qx        px #> 1 0 0.2000000 1.00000000 0.2205623 0.7794377 #> 2 1 0.2983649 0.77943774 0.3104641 0.6895359 #> 3 2 0.4451082 0.53745028 0.4256784 0.5743216 #> 4 3 0.6640234 0.30866930 0.5627783 0.4372217 #> 5 4 0.9906065 0.13495691 0.7089351 0.2910649 #> 6 5 1.4778112 0.03928123 0.8413767 0.1586233 survival <- surv_prob$px fertility <- model_fertility(age = 0:(length(survival)-1),                               params = c(A = 5), maturity = 2, model = \"step\") make_leslie_mpm(   survival = survival, fertility = fertility,   n_stages = length(survival), split = FALSE ) #>           [,1]      [,2]      [,3]      [,4]      [,5]      [,6] #> [1,] 0.0000000 0.0000000 5.0000000 5.0000000 5.0000000 5.0000000 #> [2,] 0.7794377 0.0000000 0.0000000 0.0000000 0.0000000 0.0000000 #> [3,] 0.0000000 0.6895359 0.0000000 0.0000000 0.0000000 0.0000000 #> [4,] 0.0000000 0.0000000 0.5743216 0.0000000 0.0000000 0.0000000 #> [5,] 0.0000000 0.0000000 0.0000000 0.4372217 0.0000000 0.0000000 #> [6,] 0.0000000 0.0000000 0.0000000 0.0000000 0.2910649 0.1586233"},{"path":"https://jonesor.github.io/mpmsim/index.html","id":"sets-of-leslie-matrices","dir":"","previous_headings":"Usage","what":"Sets of Leslie matrices","title":"Simulates Matrix Population Models with Particular Life History\n    Characteristics","text":"Users can generate large numbers plausible Leslie matrices repeating make_leslie_mpm command loop. example, following code produces list five Leslie matrices increasing survival age. ’s one way similar thing uncertainty applied Gompertz mortality.","code":"sample_size <- 5 juvSurv <- runif(n = sample_size, min = 0.0, max = 0.1) adultSurv <- runif(n = sample_size, min = 0.4, max = 0.8) adultFert <- rpois(sample_size, 6)  outputMPMs <- NULL for (i in 1:sample_size) {   outputMPMs[[i]] <- make_leslie_mpm(     survival = seq(juvSurv[i], adultSurv[i], length.out = 6),     fertility = c(0, 0, rep(adultFert[i], 4)), n_stages = 6, split = FALSE   ) }  outputMPMs #> [[1]] #>           [,1]      [,2]      [,3]      [,4]      [,5]      [,6] #> [1,] 0.0000000 0.0000000 6.0000000 6.0000000 6.0000000 6.0000000 #> [2,] 0.0914806 0.0000000 0.0000000 0.0000000 0.0000000 0.0000000 #> [3,] 0.0000000 0.1947122 0.0000000 0.0000000 0.0000000 0.0000000 #> [4,] 0.0000000 0.0000000 0.2979437 0.0000000 0.0000000 0.0000000 #> [5,] 0.0000000 0.0000000 0.0000000 0.4011753 0.0000000 0.0000000 #> [6,] 0.0000000 0.0000000 0.0000000 0.0000000 0.5044068 0.6076384 #>  #> [[2]] #>            [,1]      [,2]      [,3]      [,4]      [,5]      [,6] #> [1,] 0.00000000 0.0000000 7.0000000 7.0000000 7.0000000 7.0000000 #> [2,] 0.09370754 0.0000000 0.0000000 0.0000000 0.0000000 0.0000000 #> [3,] 0.00000000 0.2138931 0.0000000 0.0000000 0.0000000 0.0000000 #> [4,] 0.00000000 0.0000000 0.3340787 0.0000000 0.0000000 0.0000000 #> [5,] 0.00000000 0.0000000 0.0000000 0.4542642 0.0000000 0.0000000 #> [6,] 0.00000000 0.0000000 0.0000000 0.0000000 0.5744498 0.6946353 #>  #> [[3]] #>            [,1]      [,2]      [,3]       [,4]       [,5]       [,6] #> [1,] 0.00000000 0.0000000 10.000000 10.0000000 10.0000000 10.0000000 #> [2,] 0.02861395 0.0000000  0.000000  0.0000000  0.0000000  0.0000000 #> [3,] 0.00000000 0.1136645  0.000000  0.0000000  0.0000000  0.0000000 #> [4,] 0.00000000 0.0000000  0.198715  0.0000000  0.0000000  0.0000000 #> [5,] 0.00000000 0.0000000  0.000000  0.2837656  0.0000000  0.0000000 #> [6,] 0.00000000 0.0000000  0.000000  0.0000000  0.3688161  0.4538666 #>  #> [[4]] #>            [,1]      [,2]      [,3]      [,4]      [,5]      [,6] #> [1,] 0.00000000 0.0000000 4.0000000 4.0000000 4.0000000 4.0000000 #> [2,] 0.08304476 0.0000000 0.0000000 0.0000000 0.0000000 0.0000000 #> [3,] 0.00000000 0.1989952 0.0000000 0.0000000 0.0000000 0.0000000 #> [4,] 0.00000000 0.0000000 0.3149456 0.0000000 0.0000000 0.0000000 #> [5,] 0.00000000 0.0000000 0.0000000 0.4308961 0.0000000 0.0000000 #> [6,] 0.00000000 0.0000000 0.0000000 0.0000000 0.5468465 0.6627969 #>  #> [[5]] #>            [,1]      [,2]      [,3]      [,4]      [,5]      [,6] #> [1,] 0.00000000 0.0000000 6.0000000 6.0000000 6.0000000 6.0000000 #> [2,] 0.06417455 0.0000000 0.0000000 0.0000000 0.0000000 0.0000000 #> [3,] 0.00000000 0.1877448 0.0000000 0.0000000 0.0000000 0.0000000 #> [4,] 0.00000000 0.0000000 0.3113151 0.0000000 0.0000000 0.0000000 #> [5,] 0.00000000 0.0000000 0.0000000 0.4348854 0.0000000 0.0000000 #> [6,] 0.00000000 0.0000000 0.0000000 0.0000000 0.5584556 0.6820259 sample_size <- 5 b0_values <- rnorm(n = sample_size, mean = 0.3, sd = 0.1) b1_values <- rnorm(n = sample_size, mean = 0.4, sd = 0.1) fertility_values <- rnorm(n = sample_size, mean = 3, sd = 1)  outputMPMs <- NULL for (i in 1:sample_size) {   surv_prob <- model_survival(     params = c(b0_values[i], b1_values[i]),     model = \"Gompertz\"   )   survival <- surv_prob$px    maturity <- 2   fertility <- c(     rep(0, maturity),     rep(fertility_values[i], length(survival) - maturity)   )    outputMPMs[[i]] <- make_leslie_mpm(     survival = survival, fertility = fertility,     n_stages = length(survival), split = FALSE   ) }  outputMPMs #> [[1]] #>           [,1]      [,2]      [,3]      [,4]       [,5] #> [1,] 0.0000000 0.0000000 3.9657529 3.9657529 3.96575288 #> [2,] 0.5662538 0.0000000 0.0000000 0.0000000 0.00000000 #> [3,] 0.0000000 0.4267964 0.0000000 0.0000000 0.00000000 #> [4,] 0.0000000 0.0000000 0.2795021 0.0000000 0.00000000 #> [5,] 0.0000000 0.0000000 0.0000000 0.1483049 0.05742431 #>  #> [[2]] #>           [,1]      [,2]      [,3]      [,4]      [,5] #> [1,] 0.0000000 0.0000000 2.1854291 2.1854291 2.1854291 #> [2,] 0.7828594 0.0000000 0.0000000 0.0000000 0.0000000 #> [3,] 0.0000000 0.6593341 0.0000000 0.0000000 0.0000000 #> [4,] 0.0000000 0.0000000 0.4922804 0.0000000 0.0000000 #> [5,] 0.0000000 0.0000000 0.0000000 0.2994381 0.1285137 #>  #> [[3]] #>           [,1]      [,2]      [,3]      [,4]       [,5] #> [1,] 0.0000000 0.0000000 3.2839578 3.2839578 3.28395781 #> [2,] 0.6591217 0.0000000 0.0000000 0.0000000 0.00000000 #> [3,] 0.0000000 0.5037044 0.0000000 0.0000000 0.00000000 #> [4,] 0.0000000 0.0000000 0.3236247 0.0000000 0.00000000 #> [5,] 0.0000000 0.0000000 0.0000000 0.1562993 0.04720172 #>  #> [[4]] #>           [,1]      [,2]      [,3]      [,4]      [,5]       [,6] #> [1,] 0.0000000 0.0000000 2.8383014 2.8383014 2.8383014 2.83830135 #> [2,] 0.7775471 0.0000000 0.0000000 0.0000000 0.0000000 0.00000000 #> [3,] 0.0000000 0.6636757 0.0000000 0.0000000 0.0000000 0.00000000 #> [4,] 0.0000000 0.0000000 0.5127486 0.0000000 0.0000000 0.00000000 #> [5,] 0.0000000 0.0000000 0.0000000 0.3367703 0.0000000 0.00000000 #> [6,] 0.0000000 0.0000000 0.0000000 0.0000000 0.1697708 0.05561344 #>  #> [[5]] #>           [,1]      [,2]      [,3]      [,4] #> [1,] 0.0000000 0.0000000 4.9355718 4.9355718 #> [2,] 0.5533382 0.0000000 0.0000000 0.0000000 #> [3,] 0.0000000 0.3959549 0.0000000 0.0000000 #> [4,] 0.0000000 0.0000000 0.2344795 0.1032486"},{"path":"https://jonesor.github.io/mpmsim/index.html","id":"simulate-an-mpm-using-a-particular-sample-size","dir":"","previous_headings":"Usage","what":"Simulate an MPM using a particular sample size","title":"Simulates Matrix Population Models with Particular Life History\n    Characteristics","text":"function simulate_mpm can used simulate MPM based expected transition rates (survival fecundity) sample sizes. expected transition rates must provided matrices. sample size(s) can given either matrix sample sizes element matrix single value applied elements matrix. function uses binomial process simulate survival/growth elements Poisson process simulate fecundity elements. result, sample sizes large, simulated MPM closely reflect expected transition rates. contrast, sample sizes small, simulated matrices become variable. illustrate use function, following code first generates 3-stage Leslie matrix using make_leslie_mpm function. passes U F matrices Leslie matrix simulate_mpm function. , two matrices simulated, first sample size 1000, sample size seven. list arbitrary number matrices can generated easily using replicate, follows.","code":"mats <- make_leslie_mpm(   survival = c(0.3, 0.5, 0.8),   fertility = c(0, 2.2, 4.4),   n_stages = 3, split = TRUE )  simulate_mpm(   mat_U = mats$mat_U, mat_F = mats$mat_F,   sample_size = 1000, split = FALSE ) #>       [,1]  [,2]  [,3] #> [1,] 0.000 2.255 4.482 #> [2,] 0.287 0.000 0.000 #> [3,] 0.000 0.507 0.794  simulate_mpm(   mat_U = mats$mat_U, mat_F = mats$mat_F,   sample_size = 7, split = FALSE ) #>           [,1]      [,2]     [,3] #> [1,] 0.0000000 1.8571429 4.714286 #> [2,] 0.4285714 0.0000000 0.000000 #> [3,] 0.0000000 0.7142857 1.000000 replicate(   n = 5,   simulate_mpm(     mat_U = mats$mat_U, mat_F = mats$mat_F,     sample_size = 7, split = FALSE   ) ) #> , , 1 #>  #>      [,1]      [,2]      [,3] #> [1,]    0 1.5714286 4.1428571 #> [2,]    0 0.0000000 0.0000000 #> [3,]    0 0.4285714 0.7142857 #>  #> , , 2 #>  #>           [,1]      [,2]      [,3] #> [1,] 0.0000000 2.2857143 5.5714286 #> [2,] 0.7142857 0.0000000 0.0000000 #> [3,] 0.0000000 0.5714286 0.7142857 #>  #> , , 3 #>  #>           [,1]      [,2]      [,3] #> [1,] 0.0000000 2.1428571 4.4285714 #> [2,] 0.1428571 0.0000000 0.0000000 #> [3,] 0.0000000 0.5714286 0.5714286 #>  #> , , 4 #>  #>           [,1]      [,2]      [,3] #> [1,] 0.0000000 1.7142857 4.0000000 #> [2,] 0.7142857 0.0000000 0.0000000 #> [3,] 0.0000000 0.5714286 0.8571429 #>  #> , , 5 #>  #>           [,1]      [,2]      [,3] #> [1,] 0.0000000 2.5714286 4.5714286 #> [2,] 0.4285714 0.0000000 0.0000000 #> [3,] 0.0000000 0.4285714 0.7142857"},{"path":"https://jonesor.github.io/mpmsim/index.html","id":"generate-single-random-lefkovitch-mpms","dir":"","previous_headings":"Usage","what":"Generate single random Lefkovitch MPMs","title":"Simulates Matrix Population Models with Particular Life History\n    Characteristics","text":"random_mpm function can used generate random Lefkovitch matrix population model (MPM) element values based defined life history archetypes. function draws survival transition/growth probabilities Dirichlet distribution ensure column totals, including death, less equal 1. Fecundity can specified single value vector length equal dimensions matrix. specified single value, placed top-right corner matrix. specified vector length n_stages, spans entire top row matrix. archetype argument can used constrain MPMs, example, archetype = 2 constraints survival probability increase monotonically individuals advance later stages. information, see documentation random_mpm Takada et al. (2018). following example, split output matrices U F matrices, summed create matrix.","code":"(rMPM <- random_mpm(   n_stages = 3, fecundity = 20,   archetype = 2, split = TRUE )) #> $mat_A #>            [,1]        [,2]       [,3] #> [1,] 0.01566286 0.003962617 18.2372038 #> [2,] 0.19165445 0.447044844  0.1369993 #> [3,] 0.25834510 0.111258159  0.3916082 #>  #> $mat_U #>            [,1]        [,2]      [,3] #> [1,] 0.01566286 0.003962617 0.2372038 #> [2,] 0.19165445 0.447044844 0.1369993 #> [3,] 0.25834510 0.111258159 0.3916082 #>  #> $mat_F #>      [,1] [,2] [,3] #> [1,]    0    0   18 #> [2,]    0    0    0 #> [3,]    0    0    0"},{"path":"https://jonesor.github.io/mpmsim/index.html","id":"generate-a-set-of-random-lefkovitch-mpms","dir":"","previous_headings":"Usage","what":"Generate a set of random Lefkovitch MPMs","title":"Simulates Matrix Population Models with Particular Life History\n    Characteristics","text":"generate_mpm_set function can used quickly generate large numbers Lefkovitch MPMs using approach. example, following code generates five MPMs archetype 1. using constraint argument, users can specify acceptable characteristics set matrices. case, population growth rate range, can useful life history analyses might assume life histories lambda values close 1 can persist nature.","code":"library(popbio) constrain_df <- data.frame(fun = \"lambda\", arg = NA, lower = 0.9, upper = 1.1) generate_mpm_set(   n = 5, n_stages = 4, fecundity = 8, archetype = 1, constraint = constrain_df ) #> $A_list #> $A_list[[1]] #>             [,1]       [,2]       [,3]      [,4] #> [1,] 0.683817095 0.07436408 0.40352369 3.0190505 #> [2,] 0.065426834 0.57796228 0.03221829 0.1655543 #> [3,] 0.002387016 0.24212237 0.07486204 0.5271301 #> [4,] 0.064758332 0.01273125 0.05122861 0.2238208 #>  #> $A_list[[2]] #>             [,1]      [,2]       [,3]       [,4] #> [1,] 0.004719656 0.3348849 0.40387912 6.27662294 #> [2,] 0.128065308 0.3286158 0.09015260 0.09244601 #> [3,] 0.427166249 0.1241865 0.23033102 0.10502351 #> [4,] 0.019221780 0.1375705 0.08540422 0.07442567 #>  #> $A_list[[3]] #>            [,1]       [,2]       [,3]      [,4] #> [1,] 0.13142886 0.56014076 0.03765468 8.2803291 #> [2,] 0.47796787 0.20166801 0.12569645 0.1171839 #> [3,] 0.01832387 0.00426959 0.66699351 0.3060712 #> [4,] 0.01184625 0.09086567 0.09119377 0.0438874 #>  #> $A_list[[4]] #>            [,1]        [,2]       [,3]       [,4] #> [1,] 0.23046148 0.183227044 0.68851806 6.36699301 #> [2,] 0.09507294 0.001175577 0.07291332 0.11467588 #> [3,] 0.50611523 0.262006976 0.12849628 0.01109936 #> [4,] 0.01556241 0.107666011 0.04314266 0.05970144 #>  #> $A_list[[5]] #>             [,1]       [,2]        [,3]       [,4] #> [1,] 0.124409734 0.16562576 0.005851048 9.19474143 #> [2,] 0.109222906 0.01030503 0.359592193 0.17404735 #> [3,] 0.007652419 0.39395405 0.491292690 0.51713935 #> [4,] 0.011558679 0.29005229 0.074311694 0.01453069 #>  #>  #> $U_list #> $U_list[[1]] #>             [,1]       [,2]       [,3]      [,4] #> [1,] 0.683817095 0.07436408 0.40352369 0.0190505 #> [2,] 0.065426834 0.57796228 0.03221829 0.1655543 #> [3,] 0.002387016 0.24212237 0.07486204 0.5271301 #> [4,] 0.064758332 0.01273125 0.05122861 0.2238208 #>  #> $U_list[[2]] #>             [,1]      [,2]       [,3]       [,4] #> [1,] 0.004719656 0.3348849 0.40387912 0.27662294 #> [2,] 0.128065308 0.3286158 0.09015260 0.09244601 #> [3,] 0.427166249 0.1241865 0.23033102 0.10502351 #> [4,] 0.019221780 0.1375705 0.08540422 0.07442567 #>  #> $U_list[[3]] #>            [,1]       [,2]       [,3]      [,4] #> [1,] 0.13142886 0.56014076 0.03765468 0.2803291 #> [2,] 0.47796787 0.20166801 0.12569645 0.1171839 #> [3,] 0.01832387 0.00426959 0.66699351 0.3060712 #> [4,] 0.01184625 0.09086567 0.09119377 0.0438874 #>  #> $U_list[[4]] #>            [,1]        [,2]       [,3]       [,4] #> [1,] 0.23046148 0.183227044 0.68851806 0.36699301 #> [2,] 0.09507294 0.001175577 0.07291332 0.11467588 #> [3,] 0.50611523 0.262006976 0.12849628 0.01109936 #> [4,] 0.01556241 0.107666011 0.04314266 0.05970144 #>  #> $U_list[[5]] #>             [,1]       [,2]        [,3]       [,4] #> [1,] 0.124409734 0.16562576 0.005851048 0.19474143 #> [2,] 0.109222906 0.01030503 0.359592193 0.17404735 #> [3,] 0.007652419 0.39395405 0.491292690 0.51713935 #> [4,] 0.011558679 0.29005229 0.074311694 0.01453069 #>  #>  #> $F_list #> $F_list[[1]] #>      [,1] [,2] [,3] [,4] #> [1,]    0    0    0    3 #> [2,]    0    0    0    0 #> [3,]    0    0    0    0 #> [4,]    0    0    0    0 #>  #> $F_list[[2]] #>      [,1] [,2] [,3] [,4] #> [1,]    0    0    0    6 #> [2,]    0    0    0    0 #> [3,]    0    0    0    0 #> [4,]    0    0    0    0 #>  #> $F_list[[3]] #>      [,1] [,2] [,3] [,4] #> [1,]    0    0    0    8 #> [2,]    0    0    0    0 #> [3,]    0    0    0    0 #> [4,]    0    0    0    0 #>  #> $F_list[[4]] #>      [,1] [,2] [,3] [,4] #> [1,]    0    0    0    6 #> [2,]    0    0    0    0 #> [3,]    0    0    0    0 #> [4,]    0    0    0    0 #>  #> $F_list[[5]] #>      [,1] [,2] [,3] [,4] #> [1,]    0    0    0    9 #> [2,]    0    0    0    0 #> [3,]    0    0    0    0 #> [4,]    0    0    0    0"},{"path":"https://jonesor.github.io/mpmsim/index.html","id":"plot-a-matrix","dir":"","previous_headings":"Usage","what":"Plot a matrix","title":"Simulates Matrix Population Models with Particular Life History\n    Characteristics","text":"can helpful visualise matrices. can accomplished function plot_matrix. output plot_matrix class ggplot colour scheme can modified usual way , example, scale_fill_gradient similar. ’s matrix: ’s plot:","code":"rMPM$mat_U #>            [,1]        [,2]      [,3] #> [1,] 0.01566286 0.003962617 0.2372038 #> [2,] 0.19165445 0.447044844 0.1369993 #> [3,] 0.25834510 0.111258159 0.3916082 p <- plot_matrix(rMPM$mat_U) p + ggplot2::scale_fill_gradient(low = \"black\", high = \"yellow\")"},{"path":"https://jonesor.github.io/mpmsim/index.html","id":"contributions","dir":"","previous_headings":"","what":"Contributions","title":"Simulates Matrix Population Models with Particular Life History\n    Characteristics","text":"contributions welcome. Please note project released Contributor Code Conduct. participating project agree abide terms. numerous ways contributing. can submit bug reports, suggestions etc. opening issue. can copy fork repository, make code edits send us pull request. ’s . also welcome email .","code":""},{"path":"https://jonesor.github.io/mpmsim/reference/calculate_errors.html","id":null,"dir":"Reference","previous_headings":"","what":"Calculate error (standard error or 95%CI) in elements of a matrix population\nmodel. — calculate_errors","title":"Calculate error (standard error or 95%CI) in elements of a matrix population\nmodel. — calculate_errors","text":"Given two submatrices matrix population model (mat_U mat_F, growth/survival matrix reproduction matrix respectively) sample size, matrix/matrices sample sizes, function calculates standard error 95% confidence interval (95%CI) element matrix. calculations assume mat_U result binomial processes (.e., survival (0/1) sample n individuals), mat_F result Poisson processes (.e., counts offspring n individuals), n sample size.","code":""},{"path":"https://jonesor.github.io/mpmsim/reference/calculate_errors.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Calculate error (standard error or 95%CI) in elements of a matrix population\nmodel. — calculate_errors","text":"","code":"calculate_errors(mat_U, mat_F, sample_size, type = \"sem\", calculate_A = TRUE)"},{"path":"https://jonesor.github.io/mpmsim/reference/calculate_errors.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Calculate error (standard error or 95%CI) in elements of a matrix population\nmodel. — calculate_errors","text":"mat_U matrix mean survival probabilities mat_F matrix mean fecundity values sample_size either (1) single matrix sample sizes element MPM, (2) list two named matrices (\"mat_F_ss\", \"mat_U_ss\") containing sample sizes survival fertility submatrices MPM (3) single value applied whole matrix type character string indicating type error calculate. Must one \"sem\" (standard error), \"CI95\" (95% confidence interval). calculate_A logical argument indicating whether returned error information include matrix error. Defaults TRUE.","code":""},{"path":"https://jonesor.github.io/mpmsim/reference/calculate_errors.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Calculate error (standard error or 95%CI) in elements of a matrix population\nmodel. — calculate_errors","text":"list containing original matrices error estimates (upper lower confidence intervals) U, F (optionally) matrices.","code":""},{"path":"https://jonesor.github.io/mpmsim/reference/calculate_errors.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Calculate error (standard error or 95%CI) in elements of a matrix population\nmodel. — calculate_errors","text":"output list containing original matrices matrices showing error estimates confidence intervals.","code":""},{"path":[]},{"path":"https://jonesor.github.io/mpmsim/reference/calculate_errors.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Calculate error (standard error or 95%CI) in elements of a matrix population\nmodel. — calculate_errors","text":"Owen Jones jones@biology.sdu.dk","code":""},{"path":"https://jonesor.github.io/mpmsim/reference/calculate_errors.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Calculate error (standard error or 95%CI) in elements of a matrix population\nmodel. — calculate_errors","text":"","code":"matU <- matrix(c(   0.1, 0,   0.2, 0.4 ), byrow = TRUE, nrow = 2) matF <- matrix(c(   0, 4,   0., 0. ), byrow = TRUE, nrow = 2)  calculate_errors(mat_U = matU, mat_F = matF, sample_size = 20, type = \"CI95\") #> $mat_F #>      [,1] [,2] #> [1,]    0    4 #> [2,]    0    0 #>  #> $mat_F_lowerCI #>      [,1]     [,2] #> [1,]    0 3.123461 #> [2,]    0 0.000000 #>  #> $mat_F_upperCI #>      [,1]     [,2] #> [1,]    0 4.876539 #> [2,]    0 0.000000 #>  #> $mat_U #>      [,1] [,2] #> [1,]  0.1  0.0 #> [2,]  0.2  0.4 #>  #> $mat_U_lowerCI #>            [,1]      [,2] #> [1,] 0.00000000 0.0000000 #> [2,] 0.02469227 0.1852928 #>  #> $mat_U_upperCI #>           [,1]      [,2] #> [1,] 0.2314808 0.0000000 #> [2,] 0.3753077 0.6147072 #>  #> $mat_A #>      [,1] [,2] #> [1,]  0.1  4.0 #> [2,]  0.2  0.4 #>  #> $mat_A_lowerCI #>             [,1]      [,2] #> [1,] -0.03148080 3.1234614 #> [2,]  0.02469227 0.1852928 #>  #> $mat_A_upperCI #>           [,1]      [,2] #> [1,] 0.2314808 4.8765386 #> [2,] 0.3753077 0.6147072 #>  calculate_errors(mat_U = matU, mat_F = matF, sample_size = 20, type = \"sem\") #> $mat_U #>      [,1] [,2] #> [1,]  0.1  0.0 #> [2,]  0.2  0.4 #>  #> $`,mat_U_error` #>            [,1]      [,2] #> [1,] 0.06708204 0.0000000 #> [2,] 0.08944272 0.1095445 #>  #> $mat_F #>      [,1] [,2] #> [1,]    0    4 #> [2,]    0    0 #>  #> $mat_F_error #>      [,1]      [,2] #> [1,]    0 0.4472136 #> [2,]    0 0.0000000 #>  #> $mat_A #>      [,1] [,2] #> [1,]    0    4 #> [2,]    0    0 #>  #> $mat_A_error #>            [,1]      [,2] #> [1,] 0.06708204 0.4472136 #> [2,] 0.08944272 0.1095445 #>   # Sample size is a single matrix applied to both F and U matrices ssMat <- matrix(10, nrow = 2, ncol = 2)  calculate_errors(   mat_U = matU, mat_F = matF, sample_size = ssMat, type =     \"sem\" ) #> $mat_U #>      [,1] [,2] #> [1,]  0.1  0.0 #> [2,]  0.2  0.4 #>  #> $`,mat_U_error` #>            [,1]      [,2] #> [1,] 0.09486833 0.0000000 #> [2,] 0.12649111 0.1549193 #>  #> $mat_F #>      [,1] [,2] #> [1,]    0    4 #> [2,]    0    0 #>  #> $mat_F_error #>      [,1]      [,2] #> [1,]    0 0.6324555 #> [2,]    0 0.0000000 #>  #> $mat_A #>      [,1] [,2] #> [1,]    0    4 #> [2,]    0    0 #>  #> $mat_A_error #>            [,1]      [,2] #> [1,] 0.09486833 0.6324555 #> [2,] 0.12649111 0.1549193 #>   # Sample size is a list of two matrices ssMats <- list(   \"mat_F_ss\" = matrix(10, nrow = 2, ncol = 2),   \"mat_U_ss\" = matrix(10, nrow = 2, ncol = 2) ) calculate_errors(   mat_U = matU, mat_F = matF, sample_size = ssMats, type =     \"sem\" ) #> $mat_U #>      [,1] [,2] #> [1,]  0.1  0.0 #> [2,]  0.2  0.4 #>  #> $`,mat_U_error` #>            [,1]      [,2] #> [1,] 0.09486833 0.0000000 #> [2,] 0.12649111 0.1549193 #>  #> $mat_F #>      [,1] [,2] #> [1,]    0    4 #> [2,]    0    0 #>  #> $mat_F_error #>      [,1]      [,2] #> [1,]    0 0.6324555 #> [2,]    0 0.0000000 #>  #> $mat_A #>      [,1] [,2] #> [1,]    0    4 #> [2,]    0    0 #>  #> $mat_A_error #>            [,1]      [,2] #> [1,] 0.09486833 0.6324555 #> [2,] 0.12649111 0.1549193 #>"},{"path":"https://jonesor.github.io/mpmsim/reference/compute_ci.html","id":null,"dir":"Reference","previous_headings":"","what":"Compute 95% confidence intervals for derived estimates from a matrix\npopulation model — compute_ci","title":"Compute 95% confidence intervals for derived estimates from a matrix\npopulation model — compute_ci","text":"function computes 95% confidence interval measures derived matrix population model using parametric bootstrapping. approach sampling distribution matrix population model (MPM) generated taking large number random independent draws using sampling distribution underlying transition rate. approach rests assumption survival-related processes binomial, reproduction Poisson process (see function simulate_mpm() details).","code":""},{"path":"https://jonesor.github.io/mpmsim/reference/compute_ci.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Compute 95% confidence intervals for derived estimates from a matrix\npopulation model — compute_ci","text":"","code":"compute_ci(mat_U, mat_F, sample_size, FUN, ..., n_sim = 1000, dist.out = FALSE)"},{"path":"https://jonesor.github.io/mpmsim/reference/compute_ci.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Compute 95% confidence intervals for derived estimates from a matrix\npopulation model — compute_ci","text":"mat_U matrix describes growth survival process. mat_F matrix describes reproduction. sample_size either (1) single matrix sample sizes element MPM, (2) list two named matrices (\"mat_F_ss\", \"mat_U_ss\") containing sample sizes survival fertility submatrices MPM (3) single value applied whole matrix FUN function apply simulated matrix population model. function must take, input, single matrix population model (.e., matrix). ... Additional arguments passed FUN. n_sim integer indicating number simulations run. Default 1000. dist.Logical. TRUE, returns list quantiles simulated estimates. Default FALSE.","code":""},{"path":"https://jonesor.github.io/mpmsim/reference/compute_ci.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Compute 95% confidence intervals for derived estimates from a matrix\npopulation model — compute_ci","text":"dist.FALSE, numeric vector 2.5th 97.5th quantiles estimated measures. dist.= TRUE, list two elements: quantiles estimates. quantiles numeric vector 2.5th 97.5th quantiles estimated measures, estimates numeric vector estimated measures.","code":""},{"path":"https://jonesor.github.io/mpmsim/reference/compute_ci.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Compute 95% confidence intervals for derived estimates from a matrix\npopulation model — compute_ci","text":"inputs U matrix, describes survival-related processes, F matrix describes reproduction. underlying assumption U matrix average binomial process F matrix average Poisson process . confidence interval depend largely sample size used.","code":""},{"path":"https://jonesor.github.io/mpmsim/reference/compute_ci.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Compute 95% confidence intervals for derived estimates from a matrix\npopulation model — compute_ci","text":"Chapter 12 Caswell, H. (2001). Matrix Population Models. Sinauer Associates Incorporated.","code":""},{"path":[]},{"path":"https://jonesor.github.io/mpmsim/reference/compute_ci.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Compute 95% confidence intervals for derived estimates from a matrix\npopulation model — compute_ci","text":"Owen Jones jones@biology.sdu.dk","code":""},{"path":"https://jonesor.github.io/mpmsim/reference/compute_ci.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Compute 95% confidence intervals for derived estimates from a matrix\npopulation model — compute_ci","text":"","code":"# Data for use in example matU <- matrix(c(   0.1, 0.0,   0.2, 0.4 ), byrow = TRUE, nrow = 2)  matF <- matrix(c(   0.0, 3.0,   0.0, 0.0 ), byrow = TRUE, nrow = 2)  # Example of use to calculate 95% CI of lambda compute_ci(   mat_U = matU, mat_F = matF, sample_size = 10, FUN =     popdemo::eigs, what = \"lambda\" ) #> Warning: More than one eigenvalues have equal absolute magnitude #>     2.5%    97.5%  #> 0.300000 1.560271   # Example of use to calculate 95% CI of generation time compute_ci(   mat_U = matU, mat_F = matF, sample_size = 10, FUN =     popbio::generation.time ) #> Warning: Some estimates are Inf.  #>  #>             Try running with argument `dist.out = TRUE` #>             and examine the estimates. #>     2.5%    97.5%  #> 2.249426      Inf   # Example of use to calculate 95% CI of generation time and show the # distribution of those bootstrapped estimates xx <- compute_ci(   mat_U = matU, mat_F = matF, sample_size = 100, FUN =     popbio::generation.time, dist.out = TRUE ) summary(xx$quantiles) #>    Min. 1st Qu.  Median    Mean 3rd Qu.    Max.  #>   2.545   2.675   2.804   2.804   2.933   3.062  hist(xx$estimates)"},{"path":"https://jonesor.github.io/mpmsim/reference/generate_mpm_set.html","id":null,"dir":"Reference","previous_headings":"","what":"Generate lists of Lefkovitch matrix population models (MPMs) based on life\nhistory archetypes — generate_mpm_set","title":"Generate lists of Lefkovitch matrix population models (MPMs) based on life\nhistory archetypes — generate_mpm_set","text":"function generates list n MPMs according specified criteria. Criteria include archetype, acceptable constraining criteria, include lambda, generation time metric derived matrix. function attempts find matrices fulfill criteria, discarding unacceptable matrices. default, takes 1000 attempts find suitable matrix model, error produced. However, number attempts can altered attempts parameter.","code":""},{"path":"https://jonesor.github.io/mpmsim/reference/generate_mpm_set.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Generate lists of Lefkovitch matrix population models (MPMs) based on life\nhistory archetypes — generate_mpm_set","text":"","code":"generate_mpm_set(   n = 10,   n_stages = 3,   archetype = 1,   fecundity = 1.5,   split = TRUE,   by_type = TRUE,   max_surv = 0.99,   constraint = NULL,   attempts = 1000 )"},{"path":"https://jonesor.github.io/mpmsim/reference/generate_mpm_set.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Generate lists of Lefkovitch matrix population models (MPMs) based on life\nhistory archetypes — generate_mpm_set","text":"n number MPMs generate. Default 10. n_stages number stages MPMs. Default 3. archetype archetype MPMs. Default 1. fecundity vector fecundities MPMs. Default 1.5. split logical indicating whether split submatrices. Default TRUE. by_type logical indicating whether matrices returned list type (, U, F, C). split FALSE, by_type must also FALSE. max_surv maximum acceptable survival value. Defaults 0.99. used split = TRUE. constraint optional data frame 4 columns named fun, arg, lower upper. columns specify (1) function outputs metric derived matrix (2) argument function (NA, argument supplied) (3) lower acceptable bound metric (4) upper acceptable bound metric. used specify attempts integer indicating number attempts made simulating matrix model. default 1000. takes 1000 attempts make matrix satisfies conditions set arguments, warning produced.","code":""},{"path":"https://jonesor.github.io/mpmsim/reference/generate_mpm_set.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Generate lists of Lefkovitch matrix population models (MPMs) based on life\nhistory archetypes — generate_mpm_set","text":"list MPMs meet specified criteria.","code":""},{"path":[]},{"path":"https://jonesor.github.io/mpmsim/reference/generate_mpm_set.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Generate lists of Lefkovitch matrix population models (MPMs) based on life\nhistory archetypes — generate_mpm_set","text":"Owen Jones jones@biology.sdu.dk","code":""},{"path":"https://jonesor.github.io/mpmsim/reference/generate_mpm_set.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Generate lists of Lefkovitch matrix population models (MPMs) based on life\nhistory archetypes — generate_mpm_set","text":"","code":"# Basic operation, without splitting matrices and with no constraints generate_mpm_set(   n = 10, n_stages = 5, fecundity = c(0, 0, 4, 8, 10),   archetype = 4, split = FALSE ) #> Error in generate_mpm_set(n = 10, n_stages = 5, fecundity = c(0, 0, 4,     8, 10), archetype = 4, split = FALSE): If split is FALSE, then by_type must also be FALSE  # Constrain outputs to A matrices with lambda between 0.9 and 1.1 library(popbio) constrain_df <- data.frame(   fun = \"lambda\", arg = NA, lower = 0.9, upper =     1.1 ) generate_mpm_set(   n = 10, n_stages = 5, fecundity = c(0, 0, 4, 8, 10),   archetype = 4, constraint = constrain_df ) #> $A_list #> $A_list[[1]] #>            [,1]       [,2]      [,3]      [,4]       [,5] #> [1,] 0.59172410 0.00000000 3.0000000 7.0000000 13.0000000 #> [2,] 0.03928654 0.64623186 0.0000000 0.0000000  0.0000000 #> [3,] 0.00000000 0.02707035 0.2940232 0.0000000  0.0000000 #> [4,] 0.00000000 0.00000000 0.5196510 0.6367752  0.0000000 #> [5,] 0.00000000 0.00000000 0.0000000 0.2315941  0.9254113 #>  #> $A_list[[2]] #>            [,1]      [,2]       [,3]      [,4]       [,5] #> [1,] 0.24626067 0.0000000 5.00000000 8.0000000 12.0000000 #> [2,] 0.07629902 0.2497351 0.00000000 0.0000000  0.0000000 #> [3,] 0.00000000 0.1290864 0.66495243 0.0000000  0.0000000 #> [4,] 0.00000000 0.0000000 0.09219072 0.2893268  0.0000000 #> [5,] 0.00000000 0.0000000 0.00000000 0.4996649  0.8650195 #>  #> $A_list[[3]] #>            [,1]      [,2]       [,3]      [,4]       [,5] #> [1,] 0.20478944 0.0000000 4.00000000 8.0000000 12.0000000 #> [2,] 0.01509631 0.3194143 0.00000000 0.0000000  0.0000000 #> [3,] 0.00000000 0.3397877 0.08749785 0.0000000  0.0000000 #> [4,] 0.00000000 0.0000000 0.61277615 0.2539657  0.0000000 #> [5,] 0.00000000 0.0000000 0.00000000 0.5771964  0.9680015 #>  #> $A_list[[4]] #>            [,1]      [,2]      [,3]       [,4]       [,5] #> [1,] 0.49141268 0.0000000 3.0000000 10.0000000 11.0000000 #> [2,] 0.02319536 0.3173920 0.0000000  0.0000000  0.0000000 #> [3,] 0.00000000 0.3038625 0.6017887  0.0000000  0.0000000 #> [4,] 0.00000000 0.0000000 0.1626274  0.1808382  0.0000000 #> [5,] 0.00000000 0.0000000 0.0000000  0.6091564  0.9047155 #>  #> $A_list[[5]] #>            [,1]       [,2]      [,3]       [,4]       [,5] #> [1,] 0.07627263 0.00000000 6.0000000 13.0000000 15.0000000 #> [2,] 0.06781778 0.26903098 0.0000000  0.0000000  0.0000000 #> [3,] 0.00000000 0.06399574 0.5515509  0.0000000  0.0000000 #> [4,] 0.00000000 0.00000000 0.1701671  0.6095316  0.0000000 #> [5,] 0.00000000 0.00000000 0.0000000  0.1790399  0.8856996 #>  #> $A_list[[6]] #>           [,1]        [,2]       [,3]       [,4]       [,5] #> [1,] 0.1860569 0.000000000 4.00000000 11.0000000 15.0000000 #> [2,] 0.2342026 0.448128178 0.00000000  0.0000000  0.0000000 #> [3,] 0.0000000 0.008416447 0.08124431  0.0000000  0.0000000 #> [4,] 0.0000000 0.000000000 0.67295693  0.6248886  0.0000000 #> [5,] 0.0000000 0.000000000 0.00000000  0.3212519  0.9841611 #>  #> $A_list[[7]] #>            [,1]      [,2]      [,3]      [,4]      [,5] #> [1,] 0.10871782 0.0000000 2.0000000 6.0000000 13.000000 #> [2,] 0.03368915 0.1020122 0.0000000 0.0000000  0.000000 #> [3,] 0.00000000 0.1311565 0.2535163 0.0000000  0.000000 #> [4,] 0.00000000 0.0000000 0.1828480 0.2229901  0.000000 #> [5,] 0.00000000 0.0000000 0.0000000 0.4900117  0.953543 #>  #> $A_list[[8]] #>            [,1]       [,2]       [,3]      [,4]       [,5] #> [1,] 0.03466013 0.00000000 4.00000000 6.0000000 14.0000000 #> [2,] 0.10623234 0.04276315 0.00000000 0.0000000  0.0000000 #> [3,] 0.00000000 0.29450065 0.69949682 0.0000000  0.0000000 #> [4,] 0.00000000 0.00000000 0.00435283 0.1876286  0.0000000 #> [5,] 0.00000000 0.00000000 0.00000000 0.6661410  0.9096006 #>  #> $A_list[[9]] #>            [,1]      [,2]      [,3]      [,4]      [,5] #> [1,] 0.08147748 0.0000000 6.0000000 9.0000000 7.0000000 #> [2,] 0.05177217 0.4443598 0.0000000 0.0000000 0.0000000 #> [3,] 0.00000000 0.1201678 0.6047314 0.0000000 0.0000000 #> [4,] 0.00000000 0.0000000 0.1842868 0.3216026 0.0000000 #> [5,] 0.00000000 0.0000000 0.0000000 0.5020081 0.9206748 #>  #> $A_list[[10]] #>           [,1]      [,2]       [,3]      [,4]       [,5] #> [1,] 0.5055821 0.0000000 2.00000000 7.0000000 14.0000000 #> [2,] 0.1557725 0.6568405 0.00000000 0.0000000  0.0000000 #> [3,] 0.0000000 0.0128138 0.71495796 0.0000000  0.0000000 #> [4,] 0.0000000 0.0000000 0.01988592 0.1540314  0.0000000 #> [5,] 0.0000000 0.0000000 0.00000000 0.8262843  0.9833724 #>  #>  #> $U_list #> $U_list[[1]] #>            [,1]       [,2]      [,3]      [,4]      [,5] #> [1,] 0.59172410 0.00000000 0.0000000 0.0000000 0.0000000 #> [2,] 0.03928654 0.64623186 0.0000000 0.0000000 0.0000000 #> [3,] 0.00000000 0.02707035 0.2940232 0.0000000 0.0000000 #> [4,] 0.00000000 0.00000000 0.5196510 0.6367752 0.0000000 #> [5,] 0.00000000 0.00000000 0.0000000 0.2315941 0.9254113 #>  #> $U_list[[2]] #>            [,1]      [,2]       [,3]      [,4]      [,5] #> [1,] 0.24626067 0.0000000 0.00000000 0.0000000 0.0000000 #> [2,] 0.07629902 0.2497351 0.00000000 0.0000000 0.0000000 #> [3,] 0.00000000 0.1290864 0.66495243 0.0000000 0.0000000 #> [4,] 0.00000000 0.0000000 0.09219072 0.2893268 0.0000000 #> [5,] 0.00000000 0.0000000 0.00000000 0.4996649 0.8650195 #>  #> $U_list[[3]] #>            [,1]      [,2]       [,3]      [,4]      [,5] #> [1,] 0.20478944 0.0000000 0.00000000 0.0000000 0.0000000 #> [2,] 0.01509631 0.3194143 0.00000000 0.0000000 0.0000000 #> [3,] 0.00000000 0.3397877 0.08749785 0.0000000 0.0000000 #> [4,] 0.00000000 0.0000000 0.61277615 0.2539657 0.0000000 #> [5,] 0.00000000 0.0000000 0.00000000 0.5771964 0.9680015 #>  #> $U_list[[4]] #>            [,1]      [,2]      [,3]      [,4]      [,5] #> [1,] 0.49141268 0.0000000 0.0000000 0.0000000 0.0000000 #> [2,] 0.02319536 0.3173920 0.0000000 0.0000000 0.0000000 #> [3,] 0.00000000 0.3038625 0.6017887 0.0000000 0.0000000 #> [4,] 0.00000000 0.0000000 0.1626274 0.1808382 0.0000000 #> [5,] 0.00000000 0.0000000 0.0000000 0.6091564 0.9047155 #>  #> $U_list[[5]] #>            [,1]       [,2]      [,3]      [,4]      [,5] #> [1,] 0.07627263 0.00000000 0.0000000 0.0000000 0.0000000 #> [2,] 0.06781778 0.26903098 0.0000000 0.0000000 0.0000000 #> [3,] 0.00000000 0.06399574 0.5515509 0.0000000 0.0000000 #> [4,] 0.00000000 0.00000000 0.1701671 0.6095316 0.0000000 #> [5,] 0.00000000 0.00000000 0.0000000 0.1790399 0.8856996 #>  #> $U_list[[6]] #>           [,1]        [,2]       [,3]      [,4]      [,5] #> [1,] 0.1860569 0.000000000 0.00000000 0.0000000 0.0000000 #> [2,] 0.2342026 0.448128178 0.00000000 0.0000000 0.0000000 #> [3,] 0.0000000 0.008416447 0.08124431 0.0000000 0.0000000 #> [4,] 0.0000000 0.000000000 0.67295693 0.6248886 0.0000000 #> [5,] 0.0000000 0.000000000 0.00000000 0.3212519 0.9841611 #>  #> $U_list[[7]] #>            [,1]      [,2]      [,3]      [,4]     [,5] #> [1,] 0.10871782 0.0000000 0.0000000 0.0000000 0.000000 #> [2,] 0.03368915 0.1020122 0.0000000 0.0000000 0.000000 #> [3,] 0.00000000 0.1311565 0.2535163 0.0000000 0.000000 #> [4,] 0.00000000 0.0000000 0.1828480 0.2229901 0.000000 #> [5,] 0.00000000 0.0000000 0.0000000 0.4900117 0.953543 #>  #> $U_list[[8]] #>            [,1]       [,2]       [,3]      [,4]      [,5] #> [1,] 0.03466013 0.00000000 0.00000000 0.0000000 0.0000000 #> [2,] 0.10623234 0.04276315 0.00000000 0.0000000 0.0000000 #> [3,] 0.00000000 0.29450065 0.69949682 0.0000000 0.0000000 #> [4,] 0.00000000 0.00000000 0.00435283 0.1876286 0.0000000 #> [5,] 0.00000000 0.00000000 0.00000000 0.6661410 0.9096006 #>  #> $U_list[[9]] #>            [,1]      [,2]      [,3]      [,4]      [,5] #> [1,] 0.08147748 0.0000000 0.0000000 0.0000000 0.0000000 #> [2,] 0.05177217 0.4443598 0.0000000 0.0000000 0.0000000 #> [3,] 0.00000000 0.1201678 0.6047314 0.0000000 0.0000000 #> [4,] 0.00000000 0.0000000 0.1842868 0.3216026 0.0000000 #> [5,] 0.00000000 0.0000000 0.0000000 0.5020081 0.9206748 #>  #> $U_list[[10]] #>           [,1]      [,2]       [,3]      [,4]      [,5] #> [1,] 0.5055821 0.0000000 0.00000000 0.0000000 0.0000000 #> [2,] 0.1557725 0.6568405 0.00000000 0.0000000 0.0000000 #> [3,] 0.0000000 0.0128138 0.71495796 0.0000000 0.0000000 #> [4,] 0.0000000 0.0000000 0.01988592 0.1540314 0.0000000 #> [5,] 0.0000000 0.0000000 0.00000000 0.8262843 0.9833724 #>  #>  #> $F_list #> $F_list[[1]] #>      [,1] [,2] [,3] [,4] [,5] #> [1,]    0    0    3    7   13 #> [2,]    0    0    0    0    0 #> [3,]    0    0    0    0    0 #> [4,]    0    0    0    0    0 #> [5,]    0    0    0    0    0 #>  #> $F_list[[2]] #>      [,1] [,2] [,3] [,4] [,5] #> [1,]    0    0    5    8   12 #> [2,]    0    0    0    0    0 #> [3,]    0    0    0    0    0 #> [4,]    0    0    0    0    0 #> [5,]    0    0    0    0    0 #>  #> $F_list[[3]] #>      [,1] [,2] [,3] [,4] [,5] #> [1,]    0    0    4    8   12 #> [2,]    0    0    0    0    0 #> [3,]    0    0    0    0    0 #> [4,]    0    0    0    0    0 #> [5,]    0    0    0    0    0 #>  #> $F_list[[4]] #>      [,1] [,2] [,3] [,4] [,5] #> [1,]    0    0    3   10   11 #> [2,]    0    0    0    0    0 #> [3,]    0    0    0    0    0 #> [4,]    0    0    0    0    0 #> [5,]    0    0    0    0    0 #>  #> $F_list[[5]] #>      [,1] [,2] [,3] [,4] [,5] #> [1,]    0    0    6   13   15 #> [2,]    0    0    0    0    0 #> [3,]    0    0    0    0    0 #> [4,]    0    0    0    0    0 #> [5,]    0    0    0    0    0 #>  #> $F_list[[6]] #>      [,1] [,2] [,3] [,4] [,5] #> [1,]    0    0    4   11   15 #> [2,]    0    0    0    0    0 #> [3,]    0    0    0    0    0 #> [4,]    0    0    0    0    0 #> [5,]    0    0    0    0    0 #>  #> $F_list[[7]] #>      [,1] [,2] [,3] [,4] [,5] #> [1,]    0    0    2    6   13 #> [2,]    0    0    0    0    0 #> [3,]    0    0    0    0    0 #> [4,]    0    0    0    0    0 #> [5,]    0    0    0    0    0 #>  #> $F_list[[8]] #>      [,1] [,2] [,3] [,4] [,5] #> [1,]    0    0    4    6   14 #> [2,]    0    0    0    0    0 #> [3,]    0    0    0    0    0 #> [4,]    0    0    0    0    0 #> [5,]    0    0    0    0    0 #>  #> $F_list[[9]] #>      [,1] [,2] [,3] [,4] [,5] #> [1,]    0    0    6    9    7 #> [2,]    0    0    0    0    0 #> [3,]    0    0    0    0    0 #> [4,]    0    0    0    0    0 #> [5,]    0    0    0    0    0 #>  #> $F_list[[10]] #>      [,1] [,2] [,3] [,4] [,5] #> [1,]    0    0    2    7   14 #> [2,]    0    0    0    0    0 #> [3,]    0    0    0    0    0 #> [4,]    0    0    0    0    0 #> [5,]    0    0    0    0    0 #>  #>   # As above, but using popdemo::eigs function instead of popbio::lambda # to illustrate use of argument library(popdemo) #> Welcome to popdemo! This is version 1.3-0 #> Use ?popdemo for an intro, or browseVignettes('popdemo') for vignettes #> Citation for popdemo is here: doi.org/10.1111/j.2041-210X.2012.00222.x #> Development and legacy versions are here: github.com/iainmstott/popdemo constrain_df <- data.frame(   fun = \"eigs\", arg = \"lambda\", lower = 0.9, upper =     1.1 ) generate_mpm_set(   n = 10, n_stages = 5, fecundity = c(0, 0, 4, 8, 10),   archetype = 4, constraint = constrain_df ) #> $A_list #> $A_list[[1]] #>             [,1]      [,2]       [,3]      [,4]       [,5] #> [1,] 0.007874915 0.0000000 2.00000000 3.0000000 16.0000000 #> [2,] 0.007650961 0.1749329 0.00000000 0.0000000  0.0000000 #> [3,] 0.000000000 0.3340613 0.01670727 0.0000000  0.0000000 #> [4,] 0.000000000 0.0000000 0.87107796 0.5002390  0.0000000 #> [5,] 0.000000000 0.0000000 0.00000000 0.4105957  0.9366168 #>  #> $A_list[[2]] #>            [,1]        [,2]       [,3]      [,4]      [,5] #> [1,] 0.18194573 0.000000000 2.00000000 6.0000000 6.0000000 #> [2,] 0.01738281 0.509414004 0.00000000 0.0000000 0.0000000 #> [3,] 0.00000000 0.001869208 0.58665037 0.0000000 0.0000000 #> [4,] 0.00000000 0.000000000 0.02794871 0.2439485 0.0000000 #> [5,] 0.00000000 0.000000000 0.00000000 0.6009070 0.9336844 #>  #> $A_list[[3]] #>            [,1]       [,2]      [,3]       [,4]       [,5] #> [1,] 0.18766701 0.00000000 4.0000000 4.00000000 10.0000000 #> [2,] 0.06583538 0.35863349 0.0000000 0.00000000  0.0000000 #> [3,] 0.00000000 0.09893181 0.3882112 0.00000000  0.0000000 #> [4,] 0.00000000 0.00000000 0.2392777 0.90508120  0.0000000 #> [5,] 0.00000000 0.00000000 0.0000000 0.07384031  0.9833391 #>  #> $A_list[[4]] #>            [,1]      [,2]       [,3]       [,4]       [,5] #> [1,] 0.04450171 0.0000000 2.00000000 12.0000000 11.0000000 #> [2,] 0.02967342 0.1403584 0.00000000  0.0000000  0.0000000 #> [3,] 0.00000000 0.1518966 0.03907807  0.0000000  0.0000000 #> [4,] 0.00000000 0.0000000 0.43409523  0.1589040  0.0000000 #> [5,] 0.00000000 0.0000000 0.00000000  0.6538104  0.8765643 #>  #> $A_list[[5]] #>            [,1]       [,2]      [,3]        [,4]       [,5] #> [1,] 0.42759639 0.00000000 6.0000000 11.00000000 10.0000000 #> [2,] 0.03622153 0.04718323 0.0000000  0.00000000  0.0000000 #> [3,] 0.00000000 0.45548549 0.1821243  0.00000000  0.0000000 #> [4,] 0.00000000 0.00000000 0.3650009  0.87153157  0.0000000 #> [5,] 0.00000000 0.00000000 0.0000000  0.04666619  0.9370567 #>  #> $A_list[[6]] #>            [,1]      [,2]      [,3]      [,4]      [,5] #> [1,] 0.19690390 0.0000000 4.0000000 5.0000000 9.0000000 #> [2,] 0.09884488 0.1757495 0.0000000 0.0000000 0.0000000 #> [3,] 0.00000000 0.3778564 0.3290832 0.0000000 0.0000000 #> [4,] 0.00000000 0.0000000 0.2322539 0.6126456 0.0000000 #> [5,] 0.00000000 0.0000000 0.0000000 0.3144943 0.9289182 #>  #> $A_list[[7]] #>            [,1]      [,2]        [,3]        [,4]       [,5] #> [1,] 0.07961651 0.0000000 3.000000000 14.00000000 12.0000000 #> [2,] 0.03913764 0.6197591 0.000000000  0.00000000  0.0000000 #> [3,] 0.00000000 0.1255677 0.004200616  0.00000000  0.0000000 #> [4,] 0.00000000 0.0000000 0.820923863  0.83134063  0.0000000 #> [5,] 0.00000000 0.0000000 0.000000000  0.05401238  0.9305837 #>  #> $A_list[[8]] #>           [,1]      [,2]       [,3]        [,4]      [,5] #> [1,] 0.2206521 0.0000000 3.00000000 14.00000000 7.0000000 #> [2,] 0.2052189 0.2987133 0.00000000  0.00000000 0.0000000 #> [3,] 0.0000000 0.1809668 0.52536120  0.00000000 0.0000000 #> [4,] 0.0000000 0.0000000 0.06262531  0.02975681 0.0000000 #> [5,] 0.0000000 0.0000000 0.00000000  0.57502242 0.6554696 #>  #> $A_list[[9]] #>           [,1]      [,2]        [,3]       [,4]      [,5] #> [1,] 0.1152385 0.0000000 5.000000000 8.00000000 8.0000000 #> [2,] 0.2749706 0.2961082 0.000000000 0.00000000 0.0000000 #> [3,] 0.0000000 0.1207265 0.702552288 0.00000000 0.0000000 #> [4,] 0.0000000 0.0000000 0.005673965 0.03578905 0.0000000 #> [5,] 0.0000000 0.0000000 0.000000000 0.90489707 0.9453126 #>  #> $A_list[[10]] #>            [,1]      [,2]      [,3]      [,4]       [,5] #> [1,] 0.33185284 0.0000000 5.0000000 9.0000000 13.0000000 #> [2,] 0.01607329 0.5320239 0.0000000 0.0000000  0.0000000 #> [3,] 0.00000000 0.1973191 0.1952510 0.0000000  0.0000000 #> [4,] 0.00000000 0.0000000 0.7169374 0.1025489  0.0000000 #> [5,] 0.00000000 0.0000000 0.0000000 0.8583364  0.9865513 #>  #>  #> $U_list #> $U_list[[1]] #>             [,1]      [,2]       [,3]      [,4]      [,5] #> [1,] 0.007874915 0.0000000 0.00000000 0.0000000 0.0000000 #> [2,] 0.007650961 0.1749329 0.00000000 0.0000000 0.0000000 #> [3,] 0.000000000 0.3340613 0.01670727 0.0000000 0.0000000 #> [4,] 0.000000000 0.0000000 0.87107796 0.5002390 0.0000000 #> [5,] 0.000000000 0.0000000 0.00000000 0.4105957 0.9366168 #>  #> $U_list[[2]] #>            [,1]        [,2]       [,3]      [,4]      [,5] #> [1,] 0.18194573 0.000000000 0.00000000 0.0000000 0.0000000 #> [2,] 0.01738281 0.509414004 0.00000000 0.0000000 0.0000000 #> [3,] 0.00000000 0.001869208 0.58665037 0.0000000 0.0000000 #> [4,] 0.00000000 0.000000000 0.02794871 0.2439485 0.0000000 #> [5,] 0.00000000 0.000000000 0.00000000 0.6009070 0.9336844 #>  #> $U_list[[3]] #>            [,1]       [,2]      [,3]       [,4]      [,5] #> [1,] 0.18766701 0.00000000 0.0000000 0.00000000 0.0000000 #> [2,] 0.06583538 0.35863349 0.0000000 0.00000000 0.0000000 #> [3,] 0.00000000 0.09893181 0.3882112 0.00000000 0.0000000 #> [4,] 0.00000000 0.00000000 0.2392777 0.90508120 0.0000000 #> [5,] 0.00000000 0.00000000 0.0000000 0.07384031 0.9833391 #>  #> $U_list[[4]] #>            [,1]      [,2]       [,3]      [,4]      [,5] #> [1,] 0.04450171 0.0000000 0.00000000 0.0000000 0.0000000 #> [2,] 0.02967342 0.1403584 0.00000000 0.0000000 0.0000000 #> [3,] 0.00000000 0.1518966 0.03907807 0.0000000 0.0000000 #> [4,] 0.00000000 0.0000000 0.43409523 0.1589040 0.0000000 #> [5,] 0.00000000 0.0000000 0.00000000 0.6538104 0.8765643 #>  #> $U_list[[5]] #>            [,1]       [,2]      [,3]       [,4]      [,5] #> [1,] 0.42759639 0.00000000 0.0000000 0.00000000 0.0000000 #> [2,] 0.03622153 0.04718323 0.0000000 0.00000000 0.0000000 #> [3,] 0.00000000 0.45548549 0.1821243 0.00000000 0.0000000 #> [4,] 0.00000000 0.00000000 0.3650009 0.87153157 0.0000000 #> [5,] 0.00000000 0.00000000 0.0000000 0.04666619 0.9370567 #>  #> $U_list[[6]] #>            [,1]      [,2]      [,3]      [,4]      [,5] #> [1,] 0.19690390 0.0000000 0.0000000 0.0000000 0.0000000 #> [2,] 0.09884488 0.1757495 0.0000000 0.0000000 0.0000000 #> [3,] 0.00000000 0.3778564 0.3290832 0.0000000 0.0000000 #> [4,] 0.00000000 0.0000000 0.2322539 0.6126456 0.0000000 #> [5,] 0.00000000 0.0000000 0.0000000 0.3144943 0.9289182 #>  #> $U_list[[7]] #>            [,1]      [,2]        [,3]       [,4]      [,5] #> [1,] 0.07961651 0.0000000 0.000000000 0.00000000 0.0000000 #> [2,] 0.03913764 0.6197591 0.000000000 0.00000000 0.0000000 #> [3,] 0.00000000 0.1255677 0.004200616 0.00000000 0.0000000 #> [4,] 0.00000000 0.0000000 0.820923863 0.83134063 0.0000000 #> [5,] 0.00000000 0.0000000 0.000000000 0.05401238 0.9305837 #>  #> $U_list[[8]] #>           [,1]      [,2]       [,3]       [,4]      [,5] #> [1,] 0.2206521 0.0000000 0.00000000 0.00000000 0.0000000 #> [2,] 0.2052189 0.2987133 0.00000000 0.00000000 0.0000000 #> [3,] 0.0000000 0.1809668 0.52536120 0.00000000 0.0000000 #> [4,] 0.0000000 0.0000000 0.06262531 0.02975681 0.0000000 #> [5,] 0.0000000 0.0000000 0.00000000 0.57502242 0.6554696 #>  #> $U_list[[9]] #>           [,1]      [,2]        [,3]       [,4]      [,5] #> [1,] 0.1152385 0.0000000 0.000000000 0.00000000 0.0000000 #> [2,] 0.2749706 0.2961082 0.000000000 0.00000000 0.0000000 #> [3,] 0.0000000 0.1207265 0.702552288 0.00000000 0.0000000 #> [4,] 0.0000000 0.0000000 0.005673965 0.03578905 0.0000000 #> [5,] 0.0000000 0.0000000 0.000000000 0.90489707 0.9453126 #>  #> $U_list[[10]] #>            [,1]      [,2]      [,3]      [,4]      [,5] #> [1,] 0.33185284 0.0000000 0.0000000 0.0000000 0.0000000 #> [2,] 0.01607329 0.5320239 0.0000000 0.0000000 0.0000000 #> [3,] 0.00000000 0.1973191 0.1952510 0.0000000 0.0000000 #> [4,] 0.00000000 0.0000000 0.7169374 0.1025489 0.0000000 #> [5,] 0.00000000 0.0000000 0.0000000 0.8583364 0.9865513 #>  #>  #> $F_list #> $F_list[[1]] #>      [,1] [,2] [,3] [,4] [,5] #> [1,]    0    0    2    3   16 #> [2,]    0    0    0    0    0 #> [3,]    0    0    0    0    0 #> [4,]    0    0    0    0    0 #> [5,]    0    0    0    0    0 #>  #> $F_list[[2]] #>      [,1] [,2] [,3] [,4] [,5] #> [1,]    0    0    2    6    6 #> [2,]    0    0    0    0    0 #> [3,]    0    0    0    0    0 #> [4,]    0    0    0    0    0 #> [5,]    0    0    0    0    0 #>  #> $F_list[[3]] #>      [,1] [,2] [,3] [,4] [,5] #> [1,]    0    0    4    4   10 #> [2,]    0    0    0    0    0 #> [3,]    0    0    0    0    0 #> [4,]    0    0    0    0    0 #> [5,]    0    0    0    0    0 #>  #> $F_list[[4]] #>      [,1] [,2] [,3] [,4] [,5] #> [1,]    0    0    2   12   11 #> [2,]    0    0    0    0    0 #> [3,]    0    0    0    0    0 #> [4,]    0    0    0    0    0 #> [5,]    0    0    0    0    0 #>  #> $F_list[[5]] #>      [,1] [,2] [,3] [,4] [,5] #> [1,]    0    0    6   11   10 #> [2,]    0    0    0    0    0 #> [3,]    0    0    0    0    0 #> [4,]    0    0    0    0    0 #> [5,]    0    0    0    0    0 #>  #> $F_list[[6]] #>      [,1] [,2] [,3] [,4] [,5] #> [1,]    0    0    4    5    9 #> [2,]    0    0    0    0    0 #> [3,]    0    0    0    0    0 #> [4,]    0    0    0    0    0 #> [5,]    0    0    0    0    0 #>  #> $F_list[[7]] #>      [,1] [,2] [,3] [,4] [,5] #> [1,]    0    0    3   14   12 #> [2,]    0    0    0    0    0 #> [3,]    0    0    0    0    0 #> [4,]    0    0    0    0    0 #> [5,]    0    0    0    0    0 #>  #> $F_list[[8]] #>      [,1] [,2] [,3] [,4] [,5] #> [1,]    0    0    3   14    7 #> [2,]    0    0    0    0    0 #> [3,]    0    0    0    0    0 #> [4,]    0    0    0    0    0 #> [5,]    0    0    0    0    0 #>  #> $F_list[[9]] #>      [,1] [,2] [,3] [,4] [,5] #> [1,]    0    0    5    8    8 #> [2,]    0    0    0    0    0 #> [3,]    0    0    0    0    0 #> [4,]    0    0    0    0    0 #> [5,]    0    0    0    0    0 #>  #> $F_list[[10]] #>      [,1] [,2] [,3] [,4] [,5] #> [1,]    0    0    5    9   13 #> [2,]    0    0    0    0    0 #> [3,]    0    0    0    0    0 #> [4,]    0    0    0    0    0 #> [5,]    0    0    0    0    0 #>  #>   # Multiple constraints # Constrain outputs to A matrices with lambda between 0.9 and 1.1, generation # time between 3 and 5 and damping ratio between 1 and 7. library(popbio) constrain_df <- data.frame(   fun = c(\"lambda\", \"generation.time\", \"damping.ratio\"),   arg = c(NA, NA, NA),   lower = c(0.9, 3.0, 1.0),   upper = c(1.1, 5.0, 7.0) ) generate_mpm_set(   n = 10, n_stages = 5, fecundity = c(0, 0, 4, 8, 10),   archetype = 4, constraint = constrain_df ) #> $A_list #> $A_list[[1]] #>           [,1]      [,2]       [,3]      [,4]       [,5] #> [1,] 0.2132965 0.0000000 4.00000000 6.0000000 12.0000000 #> [2,] 0.1778327 0.5329060 0.00000000 0.0000000  0.0000000 #> [3,] 0.0000000 0.1099794 0.04235969 0.0000000  0.0000000 #> [4,] 0.0000000 0.0000000 0.71970067 0.7168085  0.0000000 #> [5,] 0.0000000 0.0000000 0.00000000 0.1609096  0.9600961 #>  #> $A_list[[2]] #>            [,1]       [,2]      [,3]      [,4]      [,5] #> [1,] 0.62190475 0.00000000 2.0000000 6.0000000 5.0000000 #> [2,] 0.08912391 0.05969362 0.0000000 0.0000000 0.0000000 #> [3,] 0.00000000 0.69193367 0.6158058 0.0000000 0.0000000 #> [4,] 0.00000000 0.00000000 0.1541629 0.3566483 0.0000000 #> [5,] 0.00000000 0.00000000 0.0000000 0.5375225 0.9620333 #>  #> $A_list[[3]] #>            [,1]       [,2]      [,3]      [,4]      [,5] #> [1,] 0.05674409 0.00000000 3.0000000 5.0000000 6.0000000 #> [2,] 0.12531586 0.28327981 0.0000000 0.0000000 0.0000000 #> [3,] 0.00000000 0.03299347 0.1884972 0.0000000 0.0000000 #> [4,] 0.00000000 0.00000000 0.2776971 0.1772986 0.0000000 #> [5,] 0.00000000 0.00000000 0.0000000 0.4830728 0.7448259 #>  #> $A_list[[4]] #>            [,1]       [,2]      [,3]        [,4]       [,5] #> [1,] 0.44665734 0.00000000 4.0000000 7.000000000 13.0000000 #> [2,] 0.05580094 0.05544291 0.0000000 0.000000000  0.0000000 #> [3,] 0.00000000 0.58806936 0.2956930 0.000000000  0.0000000 #> [4,] 0.00000000 0.00000000 0.3857997 0.002040718  0.0000000 #> [5,] 0.00000000 0.00000000 0.0000000 0.773762602  0.8690791 #>  #> $A_list[[5]] #>            [,1]      [,2]        [,3]      [,4]       [,5] #> [1,] 0.24211557 0.0000000 5.000000000 6.0000000 11.0000000 #> [2,] 0.08827778 0.1851573 0.000000000 0.0000000  0.0000000 #> [3,] 0.00000000 0.1919922 0.407831020 0.0000000  0.0000000 #> [4,] 0.00000000 0.0000000 0.007134864 0.4682320  0.0000000 #> [5,] 0.00000000 0.0000000 0.000000000 0.0560379  0.9668042 #>  #> $A_list[[6]] #>            [,1]       [,2]      [,3]      [,4]      [,5] #> [1,] 0.05373296 0.00000000 1.0000000 9.0000000 7.0000000 #> [2,] 0.02451688 0.10170820 0.0000000 0.0000000 0.0000000 #> [3,] 0.00000000 0.05681361 0.2203045 0.0000000 0.0000000 #> [4,] 0.00000000 0.00000000 0.1642305 0.2003433 0.0000000 #> [5,] 0.00000000 0.00000000 0.0000000 0.2685748 0.9532752 #>  #> $A_list[[7]] #>           [,1]      [,2]      [,3]      [,4]       [,5] #> [1,] 0.0608077 0.0000000 5.0000000 9.0000000 13.0000000 #> [2,] 0.4933830 0.4604336 0.0000000 0.0000000  0.0000000 #> [3,] 0.0000000 0.2315650 0.3848140 0.0000000  0.0000000 #> [4,] 0.0000000 0.0000000 0.4667048 0.1975581  0.0000000 #> [5,] 0.0000000 0.0000000 0.0000000 0.6653989  0.8872771 #>  #> $A_list[[8]] #>            [,1]      [,2]      [,3]       [,4]      [,5] #> [1,] 0.47685793 0.0000000 3.0000000 8.00000000 9.0000000 #> [2,] 0.01248983 0.3794055 0.0000000 0.00000000 0.0000000 #> [3,] 0.00000000 0.2989584 0.4294066 0.00000000 0.0000000 #> [4,] 0.00000000 0.0000000 0.3782046 0.05694344 0.0000000 #> [5,] 0.00000000 0.0000000 0.0000000 0.82013455 0.9702802 #>  #> $A_list[[9]] #>           [,1]      [,2]      [,3]       [,4]       [,5] #> [1,] 0.1240807 0.0000000 4.0000000 4.00000000 16.0000000 #> [2,] 0.2229549 0.6060821 0.0000000 0.00000000  0.0000000 #> [3,] 0.0000000 0.0986676 0.6695799 0.00000000  0.0000000 #> [4,] 0.0000000 0.0000000 0.2749632 0.86313873  0.0000000 #> [5,] 0.0000000 0.0000000 0.0000000 0.09419495  0.9897981 #>  #> $A_list[[10]] #>           [,1]        [,2]      [,3]      [,4]       [,5] #> [1,] 0.3255609 0.000000000 3.0000000 9.0000000 14.0000000 #> [2,] 0.3290727 0.721012443 0.0000000 0.0000000  0.0000000 #> [3,] 0.0000000 0.006760425 0.2381221 0.0000000  0.0000000 #> [4,] 0.0000000 0.000000000 0.5494698 0.4816385  0.0000000 #> [5,] 0.0000000 0.000000000 0.0000000 0.3832743  0.9188889 #>  #>  #> $U_list #> $U_list[[1]] #>           [,1]      [,2]       [,3]      [,4]      [,5] #> [1,] 0.2132965 0.0000000 0.00000000 0.0000000 0.0000000 #> [2,] 0.1778327 0.5329060 0.00000000 0.0000000 0.0000000 #> [3,] 0.0000000 0.1099794 0.04235969 0.0000000 0.0000000 #> [4,] 0.0000000 0.0000000 0.71970067 0.7168085 0.0000000 #> [5,] 0.0000000 0.0000000 0.00000000 0.1609096 0.9600961 #>  #> $U_list[[2]] #>            [,1]       [,2]      [,3]      [,4]      [,5] #> [1,] 0.62190475 0.00000000 0.0000000 0.0000000 0.0000000 #> [2,] 0.08912391 0.05969362 0.0000000 0.0000000 0.0000000 #> [3,] 0.00000000 0.69193367 0.6158058 0.0000000 0.0000000 #> [4,] 0.00000000 0.00000000 0.1541629 0.3566483 0.0000000 #> [5,] 0.00000000 0.00000000 0.0000000 0.5375225 0.9620333 #>  #> $U_list[[3]] #>            [,1]       [,2]      [,3]      [,4]      [,5] #> [1,] 0.05674409 0.00000000 0.0000000 0.0000000 0.0000000 #> [2,] 0.12531586 0.28327981 0.0000000 0.0000000 0.0000000 #> [3,] 0.00000000 0.03299347 0.1884972 0.0000000 0.0000000 #> [4,] 0.00000000 0.00000000 0.2776971 0.1772986 0.0000000 #> [5,] 0.00000000 0.00000000 0.0000000 0.4830728 0.7448259 #>  #> $U_list[[4]] #>            [,1]       [,2]      [,3]        [,4]      [,5] #> [1,] 0.44665734 0.00000000 0.0000000 0.000000000 0.0000000 #> [2,] 0.05580094 0.05544291 0.0000000 0.000000000 0.0000000 #> [3,] 0.00000000 0.58806936 0.2956930 0.000000000 0.0000000 #> [4,] 0.00000000 0.00000000 0.3857997 0.002040718 0.0000000 #> [5,] 0.00000000 0.00000000 0.0000000 0.773762602 0.8690791 #>  #> $U_list[[5]] #>            [,1]      [,2]        [,3]      [,4]      [,5] #> [1,] 0.24211557 0.0000000 0.000000000 0.0000000 0.0000000 #> [2,] 0.08827778 0.1851573 0.000000000 0.0000000 0.0000000 #> [3,] 0.00000000 0.1919922 0.407831020 0.0000000 0.0000000 #> [4,] 0.00000000 0.0000000 0.007134864 0.4682320 0.0000000 #> [5,] 0.00000000 0.0000000 0.000000000 0.0560379 0.9668042 #>  #> $U_list[[6]] #>            [,1]       [,2]      [,3]      [,4]      [,5] #> [1,] 0.05373296 0.00000000 0.0000000 0.0000000 0.0000000 #> [2,] 0.02451688 0.10170820 0.0000000 0.0000000 0.0000000 #> [3,] 0.00000000 0.05681361 0.2203045 0.0000000 0.0000000 #> [4,] 0.00000000 0.00000000 0.1642305 0.2003433 0.0000000 #> [5,] 0.00000000 0.00000000 0.0000000 0.2685748 0.9532752 #>  #> $U_list[[7]] #>           [,1]      [,2]      [,3]      [,4]      [,5] #> [1,] 0.0608077 0.0000000 0.0000000 0.0000000 0.0000000 #> [2,] 0.4933830 0.4604336 0.0000000 0.0000000 0.0000000 #> [3,] 0.0000000 0.2315650 0.3848140 0.0000000 0.0000000 #> [4,] 0.0000000 0.0000000 0.4667048 0.1975581 0.0000000 #> [5,] 0.0000000 0.0000000 0.0000000 0.6653989 0.8872771 #>  #> $U_list[[8]] #>            [,1]      [,2]      [,3]       [,4]      [,5] #> [1,] 0.47685793 0.0000000 0.0000000 0.00000000 0.0000000 #> [2,] 0.01248983 0.3794055 0.0000000 0.00000000 0.0000000 #> [3,] 0.00000000 0.2989584 0.4294066 0.00000000 0.0000000 #> [4,] 0.00000000 0.0000000 0.3782046 0.05694344 0.0000000 #> [5,] 0.00000000 0.0000000 0.0000000 0.82013455 0.9702802 #>  #> $U_list[[9]] #>           [,1]      [,2]      [,3]       [,4]      [,5] #> [1,] 0.1240807 0.0000000 0.0000000 0.00000000 0.0000000 #> [2,] 0.2229549 0.6060821 0.0000000 0.00000000 0.0000000 #> [3,] 0.0000000 0.0986676 0.6695799 0.00000000 0.0000000 #> [4,] 0.0000000 0.0000000 0.2749632 0.86313873 0.0000000 #> [5,] 0.0000000 0.0000000 0.0000000 0.09419495 0.9897981 #>  #> $U_list[[10]] #>           [,1]        [,2]      [,3]      [,4]      [,5] #> [1,] 0.3255609 0.000000000 0.0000000 0.0000000 0.0000000 #> [2,] 0.3290727 0.721012443 0.0000000 0.0000000 0.0000000 #> [3,] 0.0000000 0.006760425 0.2381221 0.0000000 0.0000000 #> [4,] 0.0000000 0.000000000 0.5494698 0.4816385 0.0000000 #> [5,] 0.0000000 0.000000000 0.0000000 0.3832743 0.9188889 #>  #>  #> $F_list #> $F_list[[1]] #>      [,1] [,2] [,3] [,4] [,5] #> [1,]    0    0    4    6   12 #> [2,]    0    0    0    0    0 #> [3,]    0    0    0    0    0 #> [4,]    0    0    0    0    0 #> [5,]    0    0    0    0    0 #>  #> $F_list[[2]] #>      [,1] [,2] [,3] [,4] [,5] #> [1,]    0    0    2    6    5 #> [2,]    0    0    0    0    0 #> [3,]    0    0    0    0    0 #> [4,]    0    0    0    0    0 #> [5,]    0    0    0    0    0 #>  #> $F_list[[3]] #>      [,1] [,2] [,3] [,4] [,5] #> [1,]    0    0    3    5    6 #> [2,]    0    0    0    0    0 #> [3,]    0    0    0    0    0 #> [4,]    0    0    0    0    0 #> [5,]    0    0    0    0    0 #>  #> $F_list[[4]] #>      [,1] [,2] [,3] [,4] [,5] #> [1,]    0    0    4    7   13 #> [2,]    0    0    0    0    0 #> [3,]    0    0    0    0    0 #> [4,]    0    0    0    0    0 #> [5,]    0    0    0    0    0 #>  #> $F_list[[5]] #>      [,1] [,2] [,3] [,4] [,5] #> [1,]    0    0    5    6   11 #> [2,]    0    0    0    0    0 #> [3,]    0    0    0    0    0 #> [4,]    0    0    0    0    0 #> [5,]    0    0    0    0    0 #>  #> $F_list[[6]] #>      [,1] [,2] [,3] [,4] [,5] #> [1,]    0    0    1    9    7 #> [2,]    0    0    0    0    0 #> [3,]    0    0    0    0    0 #> [4,]    0    0    0    0    0 #> [5,]    0    0    0    0    0 #>  #> $F_list[[7]] #>      [,1] [,2] [,3] [,4] [,5] #> [1,]    0    0    5    9   13 #> [2,]    0    0    0    0    0 #> [3,]    0    0    0    0    0 #> [4,]    0    0    0    0    0 #> [5,]    0    0    0    0    0 #>  #> $F_list[[8]] #>      [,1] [,2] [,3] [,4] [,5] #> [1,]    0    0    3    8    9 #> [2,]    0    0    0    0    0 #> [3,]    0    0    0    0    0 #> [4,]    0    0    0    0    0 #> [5,]    0    0    0    0    0 #>  #> $F_list[[9]] #>      [,1] [,2] [,3] [,4] [,5] #> [1,]    0    0    4    4   16 #> [2,]    0    0    0    0    0 #> [3,]    0    0    0    0    0 #> [4,]    0    0    0    0    0 #> [5,]    0    0    0    0    0 #>  #> $F_list[[10]] #>      [,1] [,2] [,3] [,4] [,5] #> [1,]    0    0    3    9   14 #> [2,]    0    0    0    0    0 #> [3,]    0    0    0    0    0 #> [4,]    0    0    0    0    0 #> [5,]    0    0    0    0    0 #>  #>"},{"path":"https://jonesor.github.io/mpmsim/reference/make_leslie_matrix.html","id":null,"dir":"Reference","previous_headings":"","what":"Create a Leslie matrix — make_leslie_matrix","title":"Create a Leslie matrix — make_leslie_matrix","text":"function creates Leslie matrix inputs number stages, fertility (top row matrix), survival probability (value sub-diagonal).","code":""},{"path":"https://jonesor.github.io/mpmsim/reference/make_leslie_matrix.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create a Leslie matrix — make_leslie_matrix","text":"","code":"make_leslie_matrix(survival, fertility, n_stages, split = FALSE)"},{"path":"https://jonesor.github.io/mpmsim/reference/make_leslie_matrix.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Create a Leslie matrix — make_leslie_matrix","text":"survival numeric value representing survival probability stage along lower -diagonal matrix, final value lower-right corner matrix. one value provided, applied survival elements. fertility numeric vector length n_stages representing fertility rate stage. one value provided, applied fertility elements. n_stages numeric value representing number stages matrix split logical argument indicating whether output matrix split separate , U F matrices (= U + F).","code":""},{"path":"https://jonesor.github.io/mpmsim/reference/make_leslie_matrix.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Create a Leslie matrix — make_leslie_matrix","text":"matrix size n_stages x n_stages representing Leslie matrix","code":""},{"path":"https://jonesor.github.io/mpmsim/reference/make_leslie_matrix.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Create a Leslie matrix — make_leslie_matrix","text":"Caswell, H. (2001). Matrix Population Models: Construction, Analysis, Interpretation. Sinauer. Leslie, P. H. (1945). use matrices certain population mathematics. Biometrika, 33 (3), 183–212. Leslie, P. H. (1948). Notes Use Matrices Population Mathematics. Biometrika, 35(3-4), 213–245.","code":""},{"path":[]},{"path":"https://jonesor.github.io/mpmsim/reference/make_leslie_matrix.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Create a Leslie matrix — make_leslie_matrix","text":"Owen Jones jones@biology.sdu.dk","code":""},{"path":"https://jonesor.github.io/mpmsim/reference/make_leslie_matrix.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Create a Leslie matrix — make_leslie_matrix","text":"","code":"make_leslie_matrix(   survival = 0.5, fertility = c(0.1, 0.2, 0.3),   n_stages = 3, split = FALSE ) #>      [,1] [,2] [,3] #> [1,]  0.1  0.2  0.3 #> [2,]  0.5  0.0  0.0 #> [3,]  0.0  0.5  0.5 make_leslie_matrix(   survival = c(0.5, 0.6, 0.7), fertility = c(0.1, 0.2, 0.3),   n_stages = 3 ) #>      [,1] [,2] [,3] #> [1,]  0.1  0.2  0.3 #> [2,]  0.5  0.0  0.0 #> [3,]  0.0  0.6  0.7 make_leslie_matrix(   survival = seq(0.1, 0.7, length.out = 4), fertility = 0.1,   n_stages = 4 ) #>      [,1] [,2] [,3] [,4] #> [1,]  0.1  0.1  0.1  0.1 #> [2,]  0.1  0.0  0.0  0.0 #> [3,]  0.0  0.3  0.0  0.0 #> [4,]  0.0  0.0  0.5  0.7 make_leslie_matrix(   survival = c(0.8, 0.3, 0.2, 0.1, 0.05), fertility = 0.2,   n_stages = 5 ) #>      [,1] [,2] [,3] [,4] [,5] #> [1,]  0.2  0.2  0.2  0.2 0.20 #> [2,]  0.8  0.0  0.0  0.0 0.00 #> [3,]  0.0  0.3  0.0  0.0 0.00 #> [4,]  0.0  0.0  0.2  0.0 0.00 #> [5,]  0.0  0.0  0.0  0.1 0.05"},{"path":"https://jonesor.github.io/mpmsim/reference/make_leslie_mpm.html","id":null,"dir":"Reference","previous_headings":"","what":"Create a Leslie matrix population model — make_leslie_mpm","title":"Create a Leslie matrix population model — make_leslie_mpm","text":"function creates Leslie matrix inputs number stages, fertility (top row matrix), survival probability (value sub-diagonal).","code":""},{"path":"https://jonesor.github.io/mpmsim/reference/make_leslie_mpm.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create a Leslie matrix population model — make_leslie_mpm","text":"","code":"make_leslie_mpm(survival, fertility, n_stages, split = FALSE)"},{"path":"https://jonesor.github.io/mpmsim/reference/make_leslie_mpm.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Create a Leslie matrix population model — make_leslie_mpm","text":"survival numeric value representing survival probability stage along lower -diagonal matrix, final value lower-right corner matrix. one value provided, applied survival elements. fertility numeric vector length n_stages representing fertility rate stage. one value provided, applied fertility elements. n_stages numeric value representing number stages matrix split logical argument indicating whether output matrix split separate , U F matrices (= U + F).","code":""},{"path":"https://jonesor.github.io/mpmsim/reference/make_leslie_mpm.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Create a Leslie matrix population model — make_leslie_mpm","text":"matrix size n_stages x n_stages representing Leslie matrix","code":""},{"path":"https://jonesor.github.io/mpmsim/reference/make_leslie_mpm.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Create a Leslie matrix population model — make_leslie_mpm","text":"Caswell, H. (2001). Matrix Population Models: Construction, Analysis, Interpretation. Sinauer. Leslie, P. H. (1945). use matrices certain population mathematics. Biometrika, 33 (3), 183–212. Leslie, P. H. (1948). Notes Use Matrices Population Mathematics. Biometrika, 35(3-4), 213–245.","code":""},{"path":[]},{"path":"https://jonesor.github.io/mpmsim/reference/make_leslie_mpm.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Create a Leslie matrix population model — make_leslie_mpm","text":"Owen Jones jones@biology.sdu.dk","code":""},{"path":"https://jonesor.github.io/mpmsim/reference/make_leslie_mpm.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Create a Leslie matrix population model — make_leslie_mpm","text":"","code":"make_leslie_mpm(   survival = 0.5, fertility = c(0.1, 0.2, 0.3),   n_stages = 3, split = FALSE ) #>      [,1] [,2] [,3] #> [1,]  0.1  0.2  0.3 #> [2,]  0.5  0.0  0.0 #> [3,]  0.0  0.5  0.5 make_leslie_mpm(   survival = c(0.5, 0.6, 0.7), fertility = c(0.1, 0.2, 0.3),   n_stages = 3 ) #>      [,1] [,2] [,3] #> [1,]  0.1  0.2  0.3 #> [2,]  0.5  0.0  0.0 #> [3,]  0.0  0.6  0.7 make_leslie_mpm(   survival = seq(0.1, 0.7, length.out = 4), fertility = 0.1,   n_stages = 4 ) #>      [,1] [,2] [,3] [,4] #> [1,]  0.1  0.1  0.1  0.1 #> [2,]  0.1  0.0  0.0  0.0 #> [3,]  0.0  0.3  0.0  0.0 #> [4,]  0.0  0.0  0.5  0.7 make_leslie_mpm(   survival = c(0.8, 0.3, 0.2, 0.1, 0.05), fertility = 0.2,   n_stages = 5 ) #>      [,1] [,2] [,3] [,4] [,5] #> [1,]  0.2  0.2  0.2  0.2 0.20 #> [2,]  0.8  0.0  0.0  0.0 0.00 #> [3,]  0.0  0.3  0.0  0.0 0.00 #> [4,]  0.0  0.0  0.2  0.0 0.00 #> [5,]  0.0  0.0  0.0  0.1 0.05"},{"path":"https://jonesor.github.io/mpmsim/reference/model_fertility.html","id":null,"dir":"Reference","previous_headings":"","what":"Model fertility with age using set functional forms — model_fertility","title":"Model fertility with age using set functional forms — model_fertility","text":"function computes fertility based logistic, step, von Bertalanffy, Hadwiger, normal models. logistic model assumes fertility increases sigmoidally age maturity maximum fertility reached. step model assumes fertility zero age maturity remains constant. von Bertalanffy model assumes , maturity, fertility increases asymptotically age maximum fertility reached. formulation, model set fertility 0 'age maturity - 1', increases point. Hadwiger model rather complex intended model human fertility characteristic hump-shaped fertility. models, output ensures fertility zero age maturity.","code":""},{"path":"https://jonesor.github.io/mpmsim/reference/model_fertility.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Model fertility with age using set functional forms — model_fertility","text":"","code":"model_fertility(age = NULL, params, maturity = 0, model = \"logistic\")"},{"path":"https://jonesor.github.io/mpmsim/reference/model_fertility.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Model fertility with age using set functional forms — model_fertility","text":"age numeric vector representing age. params numeric vector parameters selected model. number meaning parameters depend selected model. maturity non-negative numeric value indicating age maturity. Whatever model used, fertility forced 0 age maturity. model character string specifying model use. Must one \"logistic\", \"step\", \"vonbertalanffy\",\"normal\" \"hadwiger\".","code":""},{"path":"https://jonesor.github.io/mpmsim/reference/model_fertility.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Model fertility with age using set functional forms — model_fertility","text":"numeric vector representing computed fertility values.","code":""},{"path":"https://jonesor.github.io/mpmsim/reference/model_fertility.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Model fertility with age using set functional forms — model_fertility","text":"required parameters varies depending fertility model. parameters provided vector parameters must provided order mentioned . Logistic: \\(f(x) = / (1 + exp(-k  (x - x_m)))\\) Step: \\(f(x)=   \\begin{cases}   , x \\geq m \\\\   , x <  m   \\end{cases}\\) von Bertalanffy: \\(f(x) =  (1 - exp(-k  (x - x_0)))\\) Normal: \\(f(x) = \\times \\exp\\left(   -\\frac{1}{2}\\left(\\frac{x-\\mu}{\\sigma}\\right)^{\\!2}\\,\\right)\\) Hadwiger: \\(f(x) = \\frac{ab}{c} \\left (\\frac{c}{x}  \\right )    ^\\frac{3}{2} \\exp \\left \\{ -b^2  \\left ( \\frac{c}{x}+\\frac{x}{c}-2    \\right ) \\right \\}\\)","code":""},{"path":"https://jonesor.github.io/mpmsim/reference/model_fertility.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Model fertility with age using set functional forms — model_fertility","text":"Bertalanffy, L. von (1938) quantitative theory organic growth (inquiries growth laws. II). Human Biology 10:181–213. Peristera, P. & Kostaki, . (2007) Modeling fertility modern populations. Demographic Research. 16. Article 6, 141-194 doi:10.4054/DemRes.2007.16.6","code":""},{"path":[]},{"path":"https://jonesor.github.io/mpmsim/reference/model_fertility.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Model fertility with age using set functional forms — model_fertility","text":"Owen Jones jones@biology.sdu.dk","code":""},{"path":"https://jonesor.github.io/mpmsim/reference/model_fertility.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Model fertility with age using set functional forms — model_fertility","text":"","code":"# Compute fertility using the step model model_fertility(age = 0:20, params = c(A = 10), maturity = 2, model = \"step\") #>  [1]  0  0 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10  # Compute fertility using the logistic model model_fertility(age = 0:20, params = c(A = 10, k = 0.5, x_m = 8), maturity = 0, model = \"logistic\") #>  [1] 0.1798621 0.2931223 0.4742587 0.7585818 1.1920292 1.8242552 2.6894142 #>  [8] 3.7754067 5.0000000 6.2245933 7.3105858 8.1757448 8.8079708 9.2414182 #> [15] 9.5257413 9.7068777 9.8201379 9.8901306 9.9330715 9.9592986 9.9752738  # Compute fertility using the von Bertalanffy model model_fertility(age = 0:20, params = c(A = 10, k = .3), maturity = 2, model = \"vonbertalanffy\") #>  [1] 0.000000 0.000000 2.591818 4.511884 5.934303 6.988058 7.768698 8.347011 #>  [9] 8.775436 9.092820 9.327945 9.502129 9.631168 9.726763 9.797581 9.850044 #> [17] 9.888910 9.917703 9.939033 9.954834 9.966540  # Compute fertility using the normal model model_fertility(age = 0:20, params = c(A = 10, mu = 4, sd = 2), maturity = 0, model = \"normal\") #>  [1] 1.353353e+00 3.246525e+00 6.065307e+00 8.824969e+00 1.000000e+01 #>  [6] 8.824969e+00 6.065307e+00 3.246525e+00 1.353353e+00 4.393693e-01 #> [11] 1.110900e-01 2.187491e-02 3.354626e-03 4.006530e-04 3.726653e-05 #> [16] 2.699579e-06 1.522998e-07 6.691586e-09 2.289735e-10 6.101937e-12 #> [21] 1.266417e-13  # Compute fertility using the Hadwiger model model_fertility(age = 0:50, params = c(a = 0.91, b = 3.85, c = 29.78), maturity = 0, model = \"hadwiger\") #>  [1]           NaN 1.722961e-178  2.632756e-83  7.775444e-52  2.900424e-36 #>  [6]  4.854202e-27  5.511959e-21  9.752061e-17  1.285955e-13  3.012210e-11 #> [11]  2.109246e-09  6.146616e-08  9.291611e-07  8.485057e-06  5.218334e-05 #> [16]  2.340447e-04  8.125653e-04  2.285572e-03  5.396092e-03  1.099593e-02 #> [21]  1.977597e-02  3.196159e-02  4.710896e-02  6.409793e-02  8.132898e-02 #> [26]  9.704998e-02  1.097012e-01  1.181803e-01  1.219739e-01  1.211525e-01 #> [31]  1.162609e-01  1.081542e-01  9.782452e-02  8.625345e-02  7.430620e-02 #> [36]  6.267207e-02  5.184481e-02  4.213231e-02  3.368422e-02  2.652753e-02 #> [41]  2.060288e-02  1.579689e-02  1.196842e-02  8.967956e-03  6.650857e-03 #> [46]  4.885343e-03  3.556515e-03  2.567565e-03  1.839156e-03  1.307766e-03 #> [51]  9.235335e-04"},{"path":"https://jonesor.github.io/mpmsim/reference/model_survival.html","id":null,"dir":"Reference","previous_headings":"","what":"Model survival data using a mortality model — model_survival","title":"Model survival data using a mortality model — model_survival","text":"Model survival data using mortality model","code":""},{"path":"https://jonesor.github.io/mpmsim/reference/model_survival.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Model survival data using a mortality model — model_survival","text":"","code":"model_survival(x = NULL, params, model, truncate = 0.01)"},{"path":"https://jonesor.github.io/mpmsim/reference/model_survival.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Model survival data using a mortality model — model_survival","text":"x Numeric vector representing age. default NULL, whereby survival trajectory modelled age 0 age survivorship synthetic cohort declines threshold defined truncate argument, default 0.01 (.e. 1% cohort remaining alive). params Numeric vector representing parameters mortality model. model Mortality model: Gompertz, GompertzMakeham, Exponential, Siler. truncate value defining life table output truncated. default 0.01, indicating life table truncated survivorship, lx, > 0.01 (.e. age 1% cohort remains alive).","code":""},{"path":"https://jonesor.github.io/mpmsim/reference/model_survival.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Model survival data using a mortality model — model_survival","text":"data frame columns age (x), hazard (hx), survivorship (lx) mortality (qx) survival probability within interval (px).","code":""},{"path":"https://jonesor.github.io/mpmsim/reference/model_survival.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Model survival data using a mortality model — model_survival","text":"required parameters varies depending mortality model. parameters provided vector. Gompertz, parameters b0, b1. GompertzMakeham parameters b0, b1 C. Exponential, parameter C. Siler, parameters a0, a1, C, b0 b1. Note parameters must provided order mentioned . Gompertz: \\(h_x = b_0 \\mathrm{e}^{b_1  x}\\) Gompertz-Makeham: \\(h_x = b_0 \\mathrm{e}^{b_1  x} + c\\) Exponential: \\(h_x = c\\) Siler: \\(h_x = a_0 \\mathrm{e}^{-a_1  x} + c + b_0 \\mathrm{e}^{b_1 x}\\) output, probability survival (px) (death (qx)) represent probability individuals enter age interval \\([x,x+1]\\) survive end interval (die end interval). possible estimate value final row life table (\\(x+1\\) value) therefore input values x may need extended capture final interval.","code":""},{"path":"https://jonesor.github.io/mpmsim/reference/model_survival.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Model survival data using a mortality model — model_survival","text":"Cox, D.R. & Oakes, D. (1984) Analysis Survival Data. Chapman Hall, London, UK. Pinder III, J.E., Wiener, J.G. & Smith, M.H. (1978) Weibull distribution: method summarizing survivorship data. Ecology, 59, 175–179. Pletcher, S. (1999) Model fitting hypothesis testing age-specific mortality data. Journal Evolutionary Biology, 12, 430–439. Siler, W. (1979) competing-risk model animal mortality. Ecology, 60, 750–757. Vaupel, J., Manton, K. & Stallard, E. (1979) impact heterogeneity individual frailty dynamics mortality. Demography, 16, 439–454.","code":""},{"path":[]},{"path":"https://jonesor.github.io/mpmsim/reference/model_survival.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Model survival data using a mortality model — model_survival","text":"Owen Jones jones@biology.sdu.dk","code":""},{"path":"https://jonesor.github.io/mpmsim/reference/model_survival.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Model survival data using a mortality model — model_survival","text":"","code":"model_survival(params = c(b_0 = 0.1, b_1 = 0.2), model = \"Gompertz\") #>     x        hx         lx        qx        px #> 1   0 0.1000000 1.00000000 0.1051240 0.8948760 #> 2   1 0.1221403 0.89487598 0.1268617 0.8731383 #> 3   2 0.1491825 0.78135045 0.1526972 0.8473028 #> 4   3 0.1822119 0.66204041 0.1832179 0.8167821 #> 5   4 0.2225541 0.54074272 0.2190086 0.7809914 #> 6   5 0.2718282 0.42231542 0.2606027 0.7393973 #> 7   6 0.3320117 0.31225886 0.3084127 0.6915873 #> 8   7 0.4055200 0.21595427 0.3626343 0.6373657 #> 9   8 0.4953032 0.13764186 0.4231275 0.5768725 #> 10  9 0.6049647 0.07940180 0.4892807 0.5107193 #> 11 10 0.7389056 0.04055203 0.5598781 0.4401219 #> 12 11 0.9025013 0.01784784 0.6330059 0.3669941  model_survival(   params = c(b_0 = 0.1, b_1 = 0.2, C = 0.1), model = \"GompertzMakeham\",   truncate = 0.1 ) #>   x        hx        lx        qx        px #> 1 0 0.2000000 1.0000000 0.1902827 0.8097173 #> 2 1 0.2221403 0.8097173 0.2099518 0.7900482 #> 3 2 0.2491825 0.6397156 0.2333287 0.7666713 #> 4 3 0.2822119 0.4904516 0.2609450 0.7390550 #> 5 4 0.3225541 0.3624707 0.2933298 0.7066702 #> 6 5 0.3718282 0.2561472 0.3309657 0.6690343 #> 7 6 0.4320117 0.1713713 0.3742259 0.6257741 #> 8 7 0.5055200 0.1072397 0.4232876 0.5767124  model_survival(0:10, c(c = 0.2), \"Exponential\") #>     x  hx        lx        qx        px #> 1   0 0.2 1.0000000 0.1812692 0.8187308 #> 2   1 0.2 0.8187308 0.1812692 0.8187308 #> 3   2 0.2 0.6703200 0.1812692 0.8187308 #> 4   3 0.2 0.5488116 0.1812692 0.8187308 #> 5   4 0.2 0.4493290 0.1812692 0.8187308 #> 6   5 0.2 0.3678794 0.1812692 0.8187308 #> 7   6 0.2 0.3011942 0.1812692 0.8187308 #> 8   7 0.2 0.2465970 0.1812692 0.8187308 #> 9   8 0.2 0.2018965 0.1812692 0.8187308 #> 10  9 0.2 0.1652989 0.1812692 0.8187308 #> 11 10 0.2 0.1353353        NA        NA  model_survival(0:10, c(a_0 = 0.1, a_1 = 0.2, C = 0.1, b_0 = 0.1, b_1 = 0.2), \"Siler\") #>    x        hx         lx        qx        px #> 1  0 0.3000000 1.00000000 0.2606669 0.7393331 #> 2  1 0.3040134 0.73933313 0.2666366 0.7333634 #> 3  2 0.3162145 0.54219987 0.2786665 0.7213335 #> 4  3 0.3370930 0.39110690 0.2969238 0.7030762 #> 5  4 0.3674870 0.27497795 0.3216226 0.6783774 #> 6  5 0.4086161 0.18653882 0.3529771 0.6470229 #> 7  6 0.4621311 0.12069488 0.3911330 0.6088670 #> 8  7 0.5301797 0.07348713 0.4360763 0.5639237 #> 9  8 0.6154929 0.04144114 0.4875201 0.5124799 #> 10 9 0.7214946 0.02123775 0.5447766 0.4552234"},{"path":"https://jonesor.github.io/mpmsim/reference/mpmsim.html","id":null,"dir":"Reference","previous_headings":"","what":"mpmsim — mpmsim","title":"mpmsim — mpmsim","text":"Simulates Matrix Population Models Particular Life History Characteristics","code":""},{"path":"https://jonesor.github.io/mpmsim/reference/mpmsim.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"mpmsim — mpmsim","text":"Owen Jones jones@biology.sdu.dk","code":""},{"path":"https://jonesor.github.io/mpmsim/reference/plot_matrix.html","id":null,"dir":"Reference","previous_headings":"","what":"Plot a matrix as a heatmap — plot_matrix","title":"Plot a matrix as a heatmap — plot_matrix","text":"Visualise matrix, matrix population model (MPM), heatmap.","code":""},{"path":"https://jonesor.github.io/mpmsim/reference/plot_matrix.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Plot a matrix as a heatmap — plot_matrix","text":"","code":"plot_matrix(mat, zero_na = FALSE, legend = FALSE, na_colour = NA, ...)"},{"path":"https://jonesor.github.io/mpmsim/reference/plot_matrix.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Plot a matrix as a heatmap — plot_matrix","text":"mat matrix, matrix matrix population model zero_na Logical indicating whether zero values treated NA legend Logical indicating whether include legend na_colour Colour NA values ... Additional arguments passed ggplot","code":""},{"path":"https://jonesor.github.io/mpmsim/reference/plot_matrix.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Plot a matrix as a heatmap — plot_matrix","text":"ggplot object","code":""},{"path":"https://jonesor.github.io/mpmsim/reference/plot_matrix.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Plot a matrix as a heatmap — plot_matrix","text":"Owen Jones jones@biology.sdu.dk","code":""},{"path":"https://jonesor.github.io/mpmsim/reference/plot_matrix.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Plot a matrix as a heatmap — plot_matrix","text":"","code":"matDim <- 10 A1 <- make_leslie_mpm(   survival = seq(0.1, 0.7, length.out = matDim),   fertility = seq(0.1, 0.7, length.out = matDim),   n_stages = matDim ) plot_matrix(A1, zero_na = TRUE, na_colour = \"black\")  plot_matrix(A1, zero_na = TRUE, na_colour = NA)"},{"path":"https://jonesor.github.io/mpmsim/reference/random_mpm.html","id":null,"dir":"Reference","previous_headings":"","what":"Generate random Lefkovitch matrix population models (MPMs) based on life\nhistory archetypes — random_mpm","title":"Generate random Lefkovitch matrix population models (MPMs) based on life\nhistory archetypes — random_mpm","text":"Generates random matrix population model (MPM) element values based defined life history archetypes. Survival transition/growth probabilities particular stage restricted less equal 1 drawing Dirichlet distribution. user can specify archetypes (Takada et al. 2018) restrict MPMs ways: Archetype 1: elements positive, although may small. Therefore, transition /stage possible. model describes life history individuals can progress retrogress rapidly. Archetype 2: form archetype 1 (transition /stage possible), survival probability (column sums survival matrix) increases monotonously individuals advance later stages. model, one first archetype, also allows rapid progression retrogression, realistic stage-specific survival probability increases stage advancement. Archetype 3: positive non-zero elements survival allowed diagonal lower sub-diagonal matrix model represents life cycle species retrogression allowed, progression can happen immediately larger/developed stage (slow progression, e.g., trees). Archetype 4: archetype general form archetype 3, assumption stage-specific survival increases individuals increase size/developmental stage. respect similar archetype 2.","code":""},{"path":"https://jonesor.github.io/mpmsim/reference/random_mpm.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Generate random Lefkovitch matrix population models (MPMs) based on life\nhistory archetypes — random_mpm","text":"","code":"random_mpm(n_stages, fecundity, archetype = 1, split = FALSE)"},{"path":"https://jonesor.github.io/mpmsim/reference/random_mpm.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Generate random Lefkovitch matrix population models (MPMs) based on life\nhistory archetypes — random_mpm","text":"n_stages integer defining number stages MPM. fecundity Mean fecundity. value lambda value Poisson distribution value fecundity drawn. integer length 1 vector integers length equal number stages. reproduction particular age class, use value 0. archetype Indication life history archetype used, based Takada et al. 2018. integer 1 4. split TRUE/FALSE, indicating whether matrix produced split survival matrix fertility matrix. Yeah true, output becomes list matrix element. Otherwise, output single matrix.","code":""},{"path":"https://jonesor.github.io/mpmsim/reference/random_mpm.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Generate random Lefkovitch matrix population models (MPMs) based on life\nhistory archetypes — random_mpm","text":"Returns random matrix population model characteristics determined archetype selected fecundity vector. split = TRUE, matrix split separate fertility growth/survival matrices, returned list.","code":""},{"path":"https://jonesor.github.io/mpmsim/reference/random_mpm.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Generate random Lefkovitch matrix population models (MPMs) based on life\nhistory archetypes — random_mpm","text":"4 Archetypes, fecundity placed single element top right matrix, single value. vector length n_stages fertility vector spans entire top row matrix. function constrained output ergodic matrices.","code":""},{"path":"https://jonesor.github.io/mpmsim/reference/random_mpm.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Generate random Lefkovitch matrix population models (MPMs) based on life\nhistory archetypes — random_mpm","text":"Caswell, H. (2001). Matrix Population Models: Construction, Analysis, Interpretation. Sinauer. Lefkovitch, L. P. (1965). study population growth organisms grouped stages. Biometrics, 21(1), 1. Takada, T., Kawai, Y., & Salguero-Gómez, R. (2018). cautionary note elasticity analyses ternary plot using randomly generated population matrices. Population Ecology, 60(1), 37–47.","code":""},{"path":[]},{"path":"https://jonesor.github.io/mpmsim/reference/random_mpm.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Generate random Lefkovitch matrix population models (MPMs) based on life\nhistory archetypes — random_mpm","text":"Owen Jones jones@biology.sdu.dk","code":""},{"path":"https://jonesor.github.io/mpmsim/reference/random_mpm.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Generate random Lefkovitch matrix population models (MPMs) based on life\nhistory archetypes — random_mpm","text":"","code":"random_mpm(n_stages = 2, fecundity = 20, archetype = 1, split = FALSE) #>           [,1]      [,2] #> [1,] 0.5183897 17.094766 #> [2,] 0.1840986  0.534606 random_mpm(n_stages = 2, fecundity = 20, archetype = 2, split = TRUE) #> $mat_A #>           [,1]       [,2] #> [1,] 0.0342049 25.2712103 #> [2,] 0.2535926  0.6338812 #>  #> $mat_U #>           [,1]      [,2] #> [1,] 0.0342049 0.2712103 #> [2,] 0.2535926 0.6338812 #>  #> $mat_F #>      [,1] [,2] #> [1,]    0   25 #> [2,]    0    0 #>  random_mpm(n_stages = 3, fecundity = 20, archetype = 3, split = FALSE) #>           [,1]      [,2]       [,3] #> [1,] 0.3668081 0.0000000 19.0000000 #> [2,] 0.1291016 0.1846680  0.0000000 #> [3,] 0.0000000 0.8096678  0.9879701 random_mpm(n_stages = 4, fecundity = 20, archetype = 4, split = TRUE) #> $mat_A #>            [,1]        [,2]      [,3]       [,4] #> [1,] 0.11057716 0.000000000 0.0000000 21.0000000 #> [2,] 0.03381633 0.160102867 0.0000000  0.0000000 #> [3,] 0.00000000 0.009978182 0.1369367  0.0000000 #> [4,] 0.00000000 0.000000000 0.1865850  0.7131303 #>  #> $mat_U #>            [,1]        [,2]      [,3]      [,4] #> [1,] 0.11057716 0.000000000 0.0000000 0.0000000 #> [2,] 0.03381633 0.160102867 0.0000000 0.0000000 #> [3,] 0.00000000 0.009978182 0.1369367 0.0000000 #> [4,] 0.00000000 0.000000000 0.1865850 0.7131303 #>  #> $mat_F #>      [,1] [,2] [,3] [,4] #> [1,]    0    0    0   21 #> [2,]    0    0    0    0 #> [3,]    0    0    0    0 #> [4,]    0    0    0    0 #>  random_mpm(   n_stages = 5, fecundity = c(0, 0, 4, 8, 10), archetype = 4,   split = TRUE ) #> $mat_A #>           [,1]      [,2]       [,3]        [,4]      [,5] #> [1,] 0.4695327 0.0000000 4.00000000 8.000000000 9.0000000 #> [2,] 0.2990908 0.3733970 0.00000000 0.000000000 0.0000000 #> [3,] 0.0000000 0.4288858 0.75857723 0.000000000 0.0000000 #> [4,] 0.0000000 0.0000000 0.07883895 0.972933083 0.0000000 #> [5,] 0.0000000 0.0000000 0.00000000 0.007032142 0.9934526 #>  #> $mat_U #>           [,1]      [,2]       [,3]        [,4]      [,5] #> [1,] 0.4695327 0.0000000 0.00000000 0.000000000 0.0000000 #> [2,] 0.2990908 0.3733970 0.00000000 0.000000000 0.0000000 #> [3,] 0.0000000 0.4288858 0.75857723 0.000000000 0.0000000 #> [4,] 0.0000000 0.0000000 0.07883895 0.972933083 0.0000000 #> [5,] 0.0000000 0.0000000 0.00000000 0.007032142 0.9934526 #>  #> $mat_F #>      [,1] [,2] [,3] [,4] [,5] #> [1,]    0    0    4    8    9 #> [2,]    0    0    0    0    0 #> [3,]    0    0    0    0    0 #> [4,]    0    0    0    0    0 #> [5,]    0    0    0    0    0 #>"},{"path":"https://jonesor.github.io/mpmsim/reference/simulate_mpm.html","id":null,"dir":"Reference","previous_headings":"","what":"Simulate a matrix population model (MPM) with sampling error based on\nexpected values of transition rates and sample sizes — simulate_mpm","title":"Simulate a matrix population model (MPM) with sampling error based on\nexpected values of transition rates and sample sizes — simulate_mpm","text":"Simulates matrix population model based expected values transition matrix. expected values provided two matrices mat_U growth/development survival transitions mat_F fecundity transitions. mat_U values simulated based expected probabilities, assuming binomial process sample size defined sample_size. mat_F values simulated using Poisson process sample size defined sample_size.Thus users can expect large sample sizes result simulated matrices match closely expectations, simulated matrices small sample sizes variable.","code":""},{"path":"https://jonesor.github.io/mpmsim/reference/simulate_mpm.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Simulate a matrix population model (MPM) with sampling error based on\nexpected values of transition rates and sample sizes — simulate_mpm","text":"","code":"simulate_mpm(mat_U, mat_F, sample_size, split = TRUE)"},{"path":"https://jonesor.github.io/mpmsim/reference/simulate_mpm.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Simulate a matrix population model (MPM) with sampling error based on\nexpected values of transition rates and sample sizes — simulate_mpm","text":"mat_U matrix mean survival/growth probabilities mat_F matrix mean fecundity values sample_size either (1) single matrix sample sizes element MPM, (2) list two named matrices (\"mat_F_ss\", \"mat_U_ss\") containing sample sizes survival fertility submatrices MPM (3) single value applied whole matrix split logical, whether split output survival fecundity matrices ","code":""},{"path":"https://jonesor.github.io/mpmsim/reference/simulate_mpm.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Simulate a matrix population model (MPM) with sampling error based on\nexpected values of transition rates and sample sizes — simulate_mpm","text":"list matrices survival fecundity split = TRUE, otherwise single matrix sum survival fecundity","code":""},{"path":"https://jonesor.github.io/mpmsim/reference/simulate_mpm.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Simulate a matrix population model (MPM) with sampling error based on\nexpected values of transition rates and sample sizes — simulate_mpm","text":"sample_size input 0, assumed estimate element(s) concerned known without error.","code":""},{"path":[]},{"path":"https://jonesor.github.io/mpmsim/reference/simulate_mpm.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Simulate a matrix population model (MPM) with sampling error based on\nexpected values of transition rates and sample sizes — simulate_mpm","text":"Owen Jones jones@biology.sdu.dk","code":""},{"path":"https://jonesor.github.io/mpmsim/reference/simulate_mpm.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Simulate a matrix population model (MPM) with sampling error based on\nexpected values of transition rates and sample sizes — simulate_mpm","text":"","code":"mats <- make_leslie_mpm(   survival = c(0.1, 0.2, 0.5),   fertility = c(0, 1.2, 2.4),   n_stages = 3, split = TRUE ) ssMat <- matrix(10, nrow = 3, ncol = 3)  # Sample size is a single matrix simulate_mpm(   mat_U = mats$mat_U, mat_F = mats$mat_F,   sample_size = ssMat, split = TRUE ) #> $mat_U #>      [,1] [,2] [,3] #> [1,]  0.0  0.0  0.0 #> [2,]  0.1  0.0  0.0 #> [3,]  0.0  0.2  0.4 #>  #> $mat_F #>      [,1] [,2] [,3] #> [1,]    0  1.6  2.3 #> [2,]    0  0.0  0.0 #> [3,]    0  0.0  0.0 #>   # Sample size is a single value simulate_mpm(   mat_U = mats$mat_U, mat_F = mats$mat_F,   sample_size = 50, split = TRUE ) #> $mat_U #>      [,1] [,2] [,3] #> [1,]  0.0  0.0  0.0 #> [2,]  0.1  0.0  0.0 #> [3,]  0.0  0.2  0.5 #>  #> $mat_F #>      [,1] [,2] [,3] #> [1,]    0 1.26 2.14 #> [2,]    0 0.00 0.00 #> [3,]    0 0.00 0.00 #>   # Sample size is a list of two matrices ssMats <- list(   \"mat_F_ss\" = matrix(10, nrow = 3, ncol = 3),   \"mat_U_ss\" = matrix(10, nrow = 3, ncol = 3) )  simulate_mpm(   mat_U = mats$mat_U, mat_F = mats$mat_F,   sample_size = ssMats, split = TRUE ) #> $mat_U #>      [,1] [,2] [,3] #> [1,]  0.0  0.0  0.0 #> [2,]  0.1  0.0  0.0 #> [3,]  0.0  0.1  0.2 #>  #> $mat_F #>      [,1] [,2] [,3] #> [1,]    0  1.6  2.4 #> [2,]    0  0.0  0.0 #> [3,]    0  0.0  0.0 #>"},{"path":"https://jonesor.github.io/mpmsim/news/index.html","id":"mpmsim-development-version","dir":"Changelog","previous_headings":"","what":"mpmsim (development version)","title":"mpmsim (development version)","text":"added plot_matrix function plot matrix heatmap","code":""},{"path":"https://jonesor.github.io/mpmsim/news/index.html","id":"mpmsim-010","dir":"Changelog","previous_headings":"","what":"mpmsim 0.1.0","title":"mpmsim 0.1.0","text":"Added site improved documentation","code":""},{"path":"https://jonesor.github.io/mpmsim/news/index.html","id":"mpmsim-0009000","dir":"Changelog","previous_headings":"","what":"mpmsim 0.0.0.9000","title":"mpmsim 0.0.0.9000","text":"Added NEWS.md file track changes package. Added unit tests.","code":""}]
