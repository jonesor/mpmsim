[{"path":"https://jonesor.github.io/mpmsim/articles/age_from_stage.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"The robustness of age from stage methods","text":"Stage-classified matrix population models (Lefkovitch models), valuable tools studying population dynamics, especially cases organism demography dependent ontogenetic stage populations age determination difficult. analysis models often adequate, situations age-related information desired, Leslie matrix life table. Cochran Ellner (1992) developed methods obtain age-related life history traits breaking transition matrix birth, survival, fission matrices. methods allow calculation discrete survivorship maternity functions. two fundamental trajectories, various life history metrics can calculated including mean age maturity, generation time, age-specific reproductive value, senescence measures. well methods really perform? example, perform equally well functional forms mortality? Can capture differences senescence rate? following vignette illustrates mpmsim can used address one questions.","code":""},{"path":"https://jonesor.github.io/mpmsim/articles/age_from_stage.html","id":"age-from-stage","dir":"Articles","previous_headings":"","what":"Age-from-stage","title":"The robustness of age from stage methods","text":"First load required packages. Next use model_survival() function create list age-specific survival trajectories based Gompertz mortality function senescence rates (b_1_values) varying 0.1 0.9. values basis life tables. analysis want convert age-based trajectories stage-based matrix models. divide yearly age entries stages. arbitrary way dividing age vector 3 parts: quarter juveniles, half adult, another quarter old individuals. Next ’ll add fertility life tables. Let’s take look one life tables data preparation far clear. important columns age (x), survival (px), fertility (fert) stage (see ?mpm_to_table explanation columns life table). next step turn life tables matching pairs (1) Leslie matrices (2) stage-based matrices.","code":"library(mpmsim) library(dplyr) library(Rage) b_1_values <- seq(0.1, 0.9, 0.1) lifeTables <- list() for (i in seq_along(b_1_values)) {   lifeTables[[i]] <- model_survival(     params = c(b_0 = 0.1, b_1 = b_1_values[i]),     model = \"Gompertz\"   ) } for (i in seq_along(lifeTables)) {   lifeTables[[i]] <- lifeTables[[i]] |>     mutate(stage = case_when(       x <= round(max(x) * 0.25) ~ 1,       x <= round(max(x) * 0.75) ~ 2,       TRUE ~ 3     )) } for (i in seq_along(lifeTables)) {   lifeTables[[i]] <- lifeTables[[i]] |>     mutate(fert = model_fertility(       age = x, params = c(A = 3),       maturity = min(x[stage == 2]),       model = \"step\"     )) } lifeTables[[5]] #>   x        hx         lx        qx         px stage fert #> 1 0 0.1000000 1.00000000 0.1240411 0.87595894     1    0 #> 2 1 0.1648721 0.87595894 0.1961561 0.80384392     1    0 #> 3 2 0.2718282 0.70413427 0.3023227 0.69767734     1    0 #> 4 3 0.4481689 0.49125852 0.4476301 0.55236995     2    3 #> 5 4 0.7389056 0.27135645 0.6241546 0.37584536     2    3 #> 6 5 1.2182494 0.10198806 0.8007912 0.19920884     3    3 #> 7 6 2.0085537 0.02031692 0.9300552 0.06994476     3    3"},{"path":"https://jonesor.github.io/mpmsim/articles/age_from_stage.html","id":"leslie-matrices","dir":"Articles","previous_headings":"Age-from-stage","what":"Leslie matrices","title":"The robustness of age from stage methods","text":"First Now can turn life tables containing age-specific survival fertility trajectories Leslie matrices using make_leslie_mpm function. matrix models can large small depending maximum life span population: life tables , default, constrained extend age survivorship function falls 0.01. Let’s examine Leslie matrix matches life table previous section.","code":"leslie_matrices <- list() for (i in seq_along(lifeTables)) {   leslie_matrices[[i]] <- make_leslie_mpm(     survival = lifeTables[[i]]$px,     fertility = lifeTables[[i]]$fert,     n_stages = nrow(lifeTables[[i]]), split = TRUE   ) } leslie_matrices[[5]]$mat_A #>           [,1]      [,2]      [,3]      [,4]      [,5]      [,6]       [,7] #> [1,] 0.0000000 0.0000000 0.0000000 3.0000000 3.0000000 3.0000000 3.00000000 #> [2,] 0.8759589 0.0000000 0.0000000 0.0000000 0.0000000 0.0000000 0.00000000 #> [3,] 0.0000000 0.8038439 0.0000000 0.0000000 0.0000000 0.0000000 0.00000000 #> [4,] 0.0000000 0.0000000 0.6976773 0.0000000 0.0000000 0.0000000 0.00000000 #> [5,] 0.0000000 0.0000000 0.0000000 0.5523699 0.0000000 0.0000000 0.00000000 #> [6,] 0.0000000 0.0000000 0.0000000 0.0000000 0.3758454 0.0000000 0.00000000 #> [7,] 0.0000000 0.0000000 0.0000000 0.0000000 0.0000000 0.1992088 0.06994476"},{"path":"https://jonesor.github.io/mpmsim/articles/age_from_stage.html","id":"lefkovitch-matrices","dir":"Articles","previous_headings":"Age-from-stage","what":"Lefkovitch matrices","title":"The robustness of age from stage methods","text":"Leslie matrices can now construct stage-structured matrix models (Lefkovitch models) using mpm_collapse() function Rage. Let’s examine Lefkovitch matrix matches Leslie matrix life table previous sections:","code":"collapsed_matrices <- list() for (i in seq_along(lifeTables)) {   stages <- lifeTables[[i]]$stage   matrices <- leslie_matrices[[i]]   collapse_list <- split(stages, stages)   # get the indices of each element in the original vector   collapse_list <- lapply(collapse_list, function(x) which(stages %in% x))    collapsed_matrices[[i]] <- Rage::mpm_collapse(     matU = matrices$mat_U,     matF = matrices$mat_F, collapse = collapse_list   ) } collapsed_matrices[[5]]$matA #>           1         2        3 #> 1 0.6670591 3.0000000 3.000000 #> 2 0.1476356 0.3821296 0.000000 #> 3 0.0000000 0.1158355 0.180401"},{"path":"https://jonesor.github.io/mpmsim/articles/age_from_stage.html","id":"recovering-age-specific-trajectories-from-the-stage-based-model","dir":"Articles","previous_headings":"","what":"Recovering age-specific trajectories from the stage-based model","title":"The robustness of age from stage methods","text":"Next can use age-stage-approximation see well can recover “true” values original Leslie matrix/life table. plot, red curve represents “true” values survivorship life table black curve represents estimation survivorship using age--stage approximation.","code":"recovered_life_tables <- list() for (i in seq_along(lifeTables)) {   m1 <- collapsed_matrices[[i]]   recovered_life_tables[[i]] <- Rage::mpm_to_table(     matU = m1$matU, matF = m1$matF,     remove_final = TRUE   ) } i <- 5 recovered_lt <- recovered_life_tables[[i]]  plot(0:(length(recovered_lt$lx) - 1),   recovered_lt$lx,   type = \"l\",   xlab = \"age\", ylab = \"survivorship\", main = \"Survivorship\" ) lines(lifeTables[[i]]$x, lifeTables[[i]]$lx, type = \"l\", col = \"red\")"},{"path":"https://jonesor.github.io/mpmsim/articles/age_from_stage.html","id":"mortality-and-longevity","dir":"Articles","previous_headings":"","what":"Mortality and longevity","title":"The robustness of age from stage methods","text":"also look life table trajectories mortality (hazard).  plot clearly shows mortality (hazard) underestimated across life course trajectory markedly different underlying Gompertz trajectory. caused known issue population structure reaching stationary state: population reaches state, rate change mortality/survival trajectory asymptote zero. can now examine -estimation life span using age--stage methods related Gompertz parameter like .","code":"plot(0:(length(recovered_lt$lx) - 1),   recovered_lt$hx,   type = \"l\",   xlab = \"age\", ylab = \"mortality\", main = \"mortality\", ylim = c(0, 2) ) lines(lifeTables[[i]]$x, lifeTables[[i]]$hx, type = \"l\", col = \"red\") df1 <- data.frame(b_1_values, lifespan_lt = NA, lifespan_afs = NA) for (i in seq_along(lifeTables)) {   df1$lifespan_lt[i] <- max(lifeTables[[i]]$x)   df1$lifespan_afs[i] <- max(recovered_life_tables[[i]]$x) }  df1 <- df1 %>%   mutate(lifespan_diff = lifespan_afs - lifespan_lt) %>%   mutate(lifespan_diff_perc = 100 * (lifespan_diff / lifespan_lt))  plot(df1$b_1_values, df1$lifespan_diff_perc,   type = \"b\",   ylab = \"Lifespan overestimation (%)\", xlab = \"Gompertz parameter\" )"},{"path":"https://jonesor.github.io/mpmsim/articles/age_from_stage.html","id":"further-questions","dir":"Articles","previous_headings":"","what":"Further questions?","title":"The robustness of age from stage methods","text":"explained elsewhere, issue can ameliorated examining convergence quasi-stationary state (QSD) (see ?Rage::qsd_converge()) affects mortality/survival fertility. One use methods outlined explore issues thoroughly (example) checking age--stage methods perform different life histories different functional forms mortality (see ?mpmsim::model_survival()) fertility. (?mpmsim::model_fertility()).","code":""},{"path":"https://jonesor.github.io/mpmsim/articles/error_propagation.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"Sampling error and its propagation","text":"Uncertainty individual matrix elements matrix population model can lead sampling errors, propagate affect accuracy estimates MPM-derived metrics. metrics include population growth rate, generation time, reactivity many others. One way estimate uncertainty using bootstrapping approach whereby sampling distribution matrix model generated, based assumptions underlying processes matrix model uncertainties individual matrix elements. example, can assume fertility component matrix mean multiple Poisson processes, survival can modelled binomial process. compute_ci() function allows users estimate 95% confidence interval metric can derived matrix population model (). function generates sampling distribution resampling based assumptions calculates posterior distribution metric interest. lower upper bounds 95% CI estimated distribution. width CI reflects precision estimate; narrower CI indicates greater precision, wider CI indicates less precision. Various factors can influence width shape CI, sample size used estimate individual matrix elements, structure matrix model, underlying assumptions made compute_ci() function, distribution uncertainties individual matrix elements. crucial consider factors interpreting results matrix population model assessing precision resulting estimates.","code":""},{"path":"https://jonesor.github.io/mpmsim/articles/error_propagation.html","id":"estimate-95-ci-of-lambda","dir":"Articles","previous_headings":"","what":"Estimate 95% CI of lambda","title":"Sampling error and its propagation","text":"estimate 95% CI metric can calculated matrix model. example focus population growth rate, lambda. Let’s consider matrix model composed submatrices U F. need “split” matrix underlying processes governed distributions different statistical properties. assumed individual’s survival binary (0 = dies, 1 = survives) individual’s reproduction assumed Poisson process. example, matrix simple, top right element represents reproduction, elements represent survival /growth. \\[ \\mathbf{} = \\begin{bmatrix} 0.1 & 3.0 \\\\ 0.2 & 0.4 \\ \\end{bmatrix} \\] Thus: know sample size used estimate element matrix 20 individuals, can estimate downstream 95% confidence intervals , say lambda, follows: Note necessary use sample size element: sample size information can provided matrix integers can vary across matrix. can examine posterior distribution lambda estimates estimates using argument dist.= TRUE.","code":"matU <- matrix(c(   0.1, 0.0,   0.2, 0.4 ), byrow = TRUE, nrow = 2)  matF <- matrix(c(   0.0, 3.0,   0.0, 0.0 ), byrow = TRUE, nrow = 2) compute_ci(   mat_U = matU, mat_F = matF, sample_size = 20,   FUN = popdemo::eigs, what = \"lambda\" ) #>      2.5%     97.5%  #> 0.5998425 1.4022317 distLambda_20 <- compute_ci(   mat_U = matU, mat_F = matF,   sample_size = 20, FUN = popdemo::eigs, what = \"lambda\",   dist.out = TRUE ) hist(distLambda_20$estimates)"},{"path":"https://jonesor.github.io/mpmsim/articles/error_propagation.html","id":"exploring-the-impact-of-sample-size","dir":"Articles","previous_headings":"","what":"Exploring the impact of sample size","title":"Sampling error and its propagation","text":"sample size considerably larger, 100? Comparing two distributions, unsurprising posterior distribution large sample size narrower small sample size.  One use approach conduct power analysis simulation. example one ask, “sample size require order detect 20% change population growth rate?”  sample size higher elements others? problem, sample_size argument accepts matrix sample sizes (list matrices labelled mat_U_ss mat_F_ss).","code":"distLambda_100 <- compute_ci(   mat_U = matU, mat_F = matF,   sample_size = 100, FUN = popdemo::eigs, what = \"lambda\",   dist.out = TRUE ) par(mfrow = c(2, 1)) hist(distLambda_20$estimates, xlim = c(0, 1.75)) hist(distLambda_100$estimates, xlim = c(0, 1.75)) observedLambda <- popdemo::eigs(matU + matF, what = \"lambda\") reducedLambda <- observedLambda * 0.8   simDist <- compute_ci(   mat_U = matU, mat_F = matF,   sample_size = 50, FUN = popdemo::eigs, what = \"lambda\",   dist.out = TRUE )$estimates hist(simDist) abline(v = observedLambda, lty = 2, lwd = 2) abline(v = reducedLambda, lty = 2, lwd = 2, col = \"red\") sum(simDist < observedLambda) / length(simDist) #> [1] 0.542 sample_size_mat <- matrix(c(   20, 100,   20, 20 ), byrow = TRUE, nrow = 2)  distLambda_variable <- compute_ci(   mat_U = matU, mat_F = matF,   sample_size = sample_size_mat,   FUN = popdemo::eigs, what = \"lambda\",   dist.out = TRUE ) #> Warning in FUN(X[[i]], ...): More than one eigenvalues have equal absolute #> magnitude hist(distLambda_variable$estimates) par(mfrow = c(3, 1)) hist(distLambda_20$estimates, xlim = c(0, 1.75)) hist(distLambda_100$estimates, xlim = c(0, 1.75)) hist(distLambda_variable$estimates, xlim = c(0, 1.75))"},{"path":"https://jonesor.github.io/mpmsim/articles/pca.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"Exploring PCA space","text":"Several interesting analyses used MPMs many species explore life history strategies using principal components analysis (PCA). potential criticism studies underlying data biased towards certain taxa, life histories, biomes. unclear much bias influence observed patterns. therefore useful simulate realistic MPMs explore potential artefactual patterns emerge biased data. show mpmsim can help task enable exploration PCA space aid understanding life history strategies.","code":""},{"path":"https://jonesor.github.io/mpmsim/articles/pca.html","id":"simulating-data-for-a-pca","dir":"Articles","previous_headings":"","what":"Simulating data for a PCA","title":"Exploring PCA space","text":"Load required packages First use generate_mpm_set() simulate 50 matrices archetype 1 life history Takada et al. (2018). life history archetype one transition /stage possible individuals can progress retrogress rapidly. function generate_mpm_set returns CompadreDB object default. matrices reducible, leads analytical problems calculations. can filtered using cdb_flag() followed filter(). convenience, matrices can added compadreDB object like , turned regular data frame (tibble) like . proceeding calculation life history traits make new function, gt_lt, calculate generation time life table. Now can use combination sapply mapply calculate life history traits matrix model. Now added variables data set can extract dataset PCA. can run PCA, add first two principle components data frame plotting purposes. plot can made using autoplot, ggfortify package.  PCA loadings show two strong axes. One evolutionary entropy, longevity, generation time life expectancy aligned, one R0 . Life table entropy aligned less equally . rather different pattern can observed real data. ?","code":"library(mpmsim) library(Rage) library(Rcompadre) library(dplyr) library(popbio) library(ggfortify) set.seed(42) constrain_df <- data.frame(fun = \"lambda\", arg = NA, lower = 0.9, upper = 1.1) sim_life_hist_1 <- generate_mpm_set(   n = 50, n_stages = 3, fecundity = c(0, 6, 6), archetype = 1, split = TRUE,   max_surv = 0.95, constraint = constrain_df ) #> Warning in cdb_build_cdb(mat_u = U_list, mat_f = F_list): Metadata does not include a `SpeciesAccepted` column, so number #>               of species not provided when viewing object. sim_life_hist_1 <- cdb_flag(sim_life_hist_1, checks = \"check_irreducible\") %>%   filter(check_irreducible == TRUE) # Put the matrices into the metadata sim_life_hist_1$matA <- matA(sim_life_hist_1) sim_life_hist_1$matU <- matU(sim_life_hist_1) sim_life_hist_1$matF <- matF(sim_life_hist_1)  # Use cdb_metadata to turn this into a data frame sim_life_hist_1 <- cdb_metadata(sim_life_hist_1) # New functions to calculate generation time from life table. # Function to calculate generation time from the life table gt_lt <- function(matU, matF, start = 1, ...) {   tempLT <- mpm_to_table(matU, matF, start = start, ...)   return(sum(tempLT$x * tempLT$lxmx) / sum(tempLT$lxmx)) } sim_life_hist_1$gt_lt <- mapply(   gt_lt, sim_life_hist_1$matU,   sim_life_hist_1$matF ) sim_life_hist_1$longevity <- sapply(sim_life_hist_1$matU,   Rage::longevity,   x_max = 1000, lx_crit = 0.01 ) sim_life_hist_1$lifeExpect <- sapply(   sim_life_hist_1$matU,   Rage::life_expect_mean ) sim_life_hist_1$entropy_d <- mapply(   entropy_d,   sim_life_hist_1$matU,   sim_life_hist_1$matF )  sim_life_hist_1$entropy_k <- mapply(entropy_k, sim_life_hist_1$matU) sim_life_hist_1$nrr_R0 <- mapply(   net_repro_rate, sim_life_hist_1$matU,   sim_life_hist_1$matF ) pcData <- sim_life_hist_1 %>%   select(gt_lt, longevity, lifeExpect, entropy_d, entropy_k, nrr_R0) %>%   na.omit() PCA <- prcomp(pcData, scale = TRUE, center = TRUE)  # Add the PC data to the raw data. pcData <- pcData %>%   cbind(PCA$x[, 1:2]) PCA_plot <- autoplot(   object = PCA, alpha = 0, size = 4, fill = \"#55616D60\",   loadings.colour = \"#0072B2\", shape = 16,   loadings = TRUE, loadings.label = TRUE, loadings.label.colour = \"red\",   loadings.label.size = 3, loadings.label.repel = TRUE,   frame = FALSE, frame.type = \"norm\", scale = 0 )  PCA_plot$layers <- c(   geom_point(     aes_(       x = pcData$PC1,       y = pcData$PC2     ),     size = 2, alpha = 0.5   ),   PCA_plot$layers )  PCA_plot"},{"path":"https://jonesor.github.io/mpmsim/articles/pca.html","id":"repeating-with-a-different-archetype","dir":"Articles","previous_headings":"","what":"Repeating with a different archetype","title":"Exploring PCA space","text":"repeat whole analysis different archetype (4) get following plot.","code":""},{"path":"https://jonesor.github.io/mpmsim/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Owen Jones. Author, maintainer.","code":""},{"path":"https://jonesor.github.io/mpmsim/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Jones O (2024). mpmsim: Simulation Matrix Population Models Defined Life History Characteristics. R package version 2.0.0.9000, https://github.com/jonesor/mpmsim.","code":"@Manual{,   title = {mpmsim: Simulation of Matrix Population Models with Defined Life History Characteristics},   author = {Owen Jones},   year = {2024},   note = {R package version 2.0.0.9000},   url = {https://github.com/jonesor/mpmsim}, }"},{"path":"https://jonesor.github.io/mpmsim/index.html","id":"mpmsim-","dir":"","previous_headings":"","what":"Simulation of Matrix Population Models with Defined Life History Characteristics","title":"Simulation of Matrix Population Models with Defined Life History Characteristics","text":"mpmsim contains tools generating random semi-random matrix population models (MPMs) given particular life history archetype. also facilitates generation Leslie matrices, simulation MPMs based expected transition rates sample sizes. can useful exploring uncertainty inferences sample sizes small (unknown).","code":""},{"path":"https://jonesor.github.io/mpmsim/index.html","id":"installation","dir":"","previous_headings":"","what":"Installation","title":"Simulation of Matrix Population Models with Defined Life History Characteristics","text":"can install latest stable version mpmsim CRAN like :","code":"install.packages(\"mpmsim\")"},{"path":"https://jonesor.github.io/mpmsim/index.html","id":"development-versions","dir":"","previous_headings":"Installation","what":"Development version(s)","title":"Simulation of Matrix Population Models with Defined Life History Characteristics","text":"package developed () GitHub. can install latest development version mpmsim like : development may versions, additional functionality, available different GitHub “branches”. install one branches, use following syntax:","code":"# install package 'remotes' if necessary # will already be installed if 'devtools' is installed install.packages(\"remotes\")  # argument 'build_opts = NULL' only needed if you want to build vignettes remotes::install_github(\"jonesor/mpmsim\", build_opts = NULL) # install from the 'dev' branch remotes::install_github(\"jonesor/mpmsim\", ref = \"dev\")"},{"path":"https://jonesor.github.io/mpmsim/index.html","id":"usage","dir":"","previous_headings":"","what":"Usage","title":"Simulation of Matrix Population Models with Defined Life History Characteristics","text":"First, load package.","code":"library(mpmsim)"},{"path":"https://jonesor.github.io/mpmsim/index.html","id":"generate-a-leslie-matrix","dir":"","previous_headings":"Usage","what":"Generate a Leslie matrix","title":"Simulation of Matrix Population Models with Defined Life History Characteristics","text":"make_leslie_mpm function can used generate Leslie matrix, stages represent discrete age classes. Leslie matrix, survival represented lower sub-diagonal lower-right-hand corner element, fertility shown top row. survival fertility length equal number stages model. Users can specify survival fertility either single value vector values, length equal dimensions matrix model. arguments single values, value repeated along survival/fertility sequence.","code":"make_leslie_mpm(   survival = seq(0.1, 0.45, length.out = 4),   fertility = c(0, 0, 2.4, 5), n_stages = 4, split = FALSE ) #>      [,1]      [,2]      [,3] [,4] #> [1,]  0.0 0.0000000 2.4000000 5.00 #> [2,]  0.1 0.0000000 0.0000000 0.00 #> [3,]  0.0 0.2166667 0.0000000 0.00 #> [4,]  0.0 0.0000000 0.3333333 0.45"},{"path":"https://jonesor.github.io/mpmsim/index.html","id":"using-a-functional-form-for-mortality","dir":"","previous_headings":"Usage","what":"Using a functional form for mortality","title":"Simulation of Matrix Population Models with Defined Life History Characteristics","text":"Users can generate Leslie matrices particular functional forms mortality first making data frame simplified life table includes age survival probability within age interval. Age-specific survival probability given px column output model_survival. Users can also use functional form fertility (see model_fertility) simple step function assumed. Subsequently, survival fertility values can applied Leslie matrix follows.","code":"(surv_prob <- model_survival(params = c(0.2, 0.4), model = \"Gompertz\")) #>   x        hx         lx        qx        px #> 1 0 0.2000000 1.00000000 0.2205623 0.7794377 #> 2 1 0.2983649 0.77943774 0.3104641 0.6895359 #> 3 2 0.4451082 0.53745028 0.4256784 0.5743216 #> 4 3 0.6640234 0.30866930 0.5627783 0.4372217 #> 5 4 0.9906065 0.13495691 0.7089351 0.2910649 #> 6 5 1.4778112 0.03928123 0.8413767 0.1586233 survival <- surv_prob$px fertility <- model_fertility(   age = 0:(length(survival) - 1),   params = c(A = 5), maturity = 2, model = \"step\" ) make_leslie_mpm(   survival = survival, fertility = fertility,   n_stages = length(survival), split = FALSE ) #>           [,1]      [,2]      [,3]      [,4]      [,5]      [,6] #> [1,] 0.0000000 0.0000000 5.0000000 5.0000000 5.0000000 5.0000000 #> [2,] 0.7794377 0.0000000 0.0000000 0.0000000 0.0000000 0.0000000 #> [3,] 0.0000000 0.6895359 0.0000000 0.0000000 0.0000000 0.0000000 #> [4,] 0.0000000 0.0000000 0.5743216 0.0000000 0.0000000 0.0000000 #> [5,] 0.0000000 0.0000000 0.0000000 0.4372217 0.0000000 0.0000000 #> [6,] 0.0000000 0.0000000 0.0000000 0.0000000 0.2910649 0.1586233"},{"path":"https://jonesor.github.io/mpmsim/index.html","id":"sets-of-leslie-matrices","dir":"","previous_headings":"Usage","what":"Sets of Leslie matrices","title":"Simulation of Matrix Population Models with Defined Life History Characteristics","text":"Users can generate large numbers plausible Leslie matrices repeating make_leslie_mpm command loop. example, following code produces list five Leslie matrices increasing survival age. ’s one way similar thing uncertainty applied Gompertz mortality.","code":"sample_size <- 5 juvSurv <- runif(n = sample_size, min = 0.0, max = 0.1) adultSurv <- runif(n = sample_size, min = 0.4, max = 0.8) adultFert <- rpois(sample_size, 6)  outputMPMs <- NULL for (i in 1:sample_size) {   outputMPMs[[i]] <- make_leslie_mpm(     survival = seq(juvSurv[i], adultSurv[i], length.out = 6),     fertility = c(0, 0, rep(adultFert[i], 4)), n_stages = 6, split = FALSE   ) }  outputMPMs #> [[1]] #>           [,1]      [,2]      [,3]      [,4]      [,5]      [,6] #> [1,] 0.0000000 0.0000000 6.0000000 6.0000000 6.0000000 6.0000000 #> [2,] 0.0914806 0.0000000 0.0000000 0.0000000 0.0000000 0.0000000 #> [3,] 0.0000000 0.1947122 0.0000000 0.0000000 0.0000000 0.0000000 #> [4,] 0.0000000 0.0000000 0.2979437 0.0000000 0.0000000 0.0000000 #> [5,] 0.0000000 0.0000000 0.0000000 0.4011753 0.0000000 0.0000000 #> [6,] 0.0000000 0.0000000 0.0000000 0.0000000 0.5044068 0.6076384 #>  #> [[2]] #>            [,1]      [,2]      [,3]      [,4]      [,5]      [,6] #> [1,] 0.00000000 0.0000000 7.0000000 7.0000000 7.0000000 7.0000000 #> [2,] 0.09370754 0.0000000 0.0000000 0.0000000 0.0000000 0.0000000 #> [3,] 0.00000000 0.2138931 0.0000000 0.0000000 0.0000000 0.0000000 #> [4,] 0.00000000 0.0000000 0.3340787 0.0000000 0.0000000 0.0000000 #> [5,] 0.00000000 0.0000000 0.0000000 0.4542642 0.0000000 0.0000000 #> [6,] 0.00000000 0.0000000 0.0000000 0.0000000 0.5744498 0.6946353 #>  #> [[3]] #>            [,1]      [,2]      [,3]       [,4]       [,5]       [,6] #> [1,] 0.00000000 0.0000000 10.000000 10.0000000 10.0000000 10.0000000 #> [2,] 0.02861395 0.0000000  0.000000  0.0000000  0.0000000  0.0000000 #> [3,] 0.00000000 0.1136645  0.000000  0.0000000  0.0000000  0.0000000 #> [4,] 0.00000000 0.0000000  0.198715  0.0000000  0.0000000  0.0000000 #> [5,] 0.00000000 0.0000000  0.000000  0.2837656  0.0000000  0.0000000 #> [6,] 0.00000000 0.0000000  0.000000  0.0000000  0.3688161  0.4538666 #>  #> [[4]] #>            [,1]      [,2]      [,3]      [,4]      [,5]      [,6] #> [1,] 0.00000000 0.0000000 4.0000000 4.0000000 4.0000000 4.0000000 #> [2,] 0.08304476 0.0000000 0.0000000 0.0000000 0.0000000 0.0000000 #> [3,] 0.00000000 0.1989952 0.0000000 0.0000000 0.0000000 0.0000000 #> [4,] 0.00000000 0.0000000 0.3149456 0.0000000 0.0000000 0.0000000 #> [5,] 0.00000000 0.0000000 0.0000000 0.4308961 0.0000000 0.0000000 #> [6,] 0.00000000 0.0000000 0.0000000 0.0000000 0.5468465 0.6627969 #>  #> [[5]] #>            [,1]      [,2]      [,3]      [,4]      [,5]      [,6] #> [1,] 0.00000000 0.0000000 6.0000000 6.0000000 6.0000000 6.0000000 #> [2,] 0.06417455 0.0000000 0.0000000 0.0000000 0.0000000 0.0000000 #> [3,] 0.00000000 0.1877448 0.0000000 0.0000000 0.0000000 0.0000000 #> [4,] 0.00000000 0.0000000 0.3113151 0.0000000 0.0000000 0.0000000 #> [5,] 0.00000000 0.0000000 0.0000000 0.4348854 0.0000000 0.0000000 #> [6,] 0.00000000 0.0000000 0.0000000 0.0000000 0.5584556 0.6820259 sample_size <- 5 b0_values <- rnorm(n = sample_size, mean = 0.3, sd = 0.1) b1_values <- rnorm(n = sample_size, mean = 0.4, sd = 0.1) fertility_values <- rnorm(n = sample_size, mean = 3, sd = 1)  outputMPMs <- NULL for (i in 1:sample_size) {   surv_prob <- model_survival(     params = c(b0_values[i], b1_values[i]),     model = \"Gompertz\"   )   survival <- surv_prob$px    maturity <- 2   fertility <- c(     rep(0, maturity),     rep(fertility_values[i], length(survival) - maturity)   )    outputMPMs[[i]] <- make_leslie_mpm(     survival = survival, fertility = fertility,     n_stages = length(survival), split = FALSE   ) }  outputMPMs #> [[1]] #>           [,1]      [,2]      [,3]      [,4]       [,5] #> [1,] 0.0000000 0.0000000 3.9657529 3.9657529 3.96575288 #> [2,] 0.5662538 0.0000000 0.0000000 0.0000000 0.00000000 #> [3,] 0.0000000 0.4267964 0.0000000 0.0000000 0.00000000 #> [4,] 0.0000000 0.0000000 0.2795021 0.0000000 0.00000000 #> [5,] 0.0000000 0.0000000 0.0000000 0.1483049 0.05742431 #>  #> [[2]] #>           [,1]      [,2]      [,3]      [,4]      [,5] #> [1,] 0.0000000 0.0000000 2.1854291 2.1854291 2.1854291 #> [2,] 0.7828594 0.0000000 0.0000000 0.0000000 0.0000000 #> [3,] 0.0000000 0.6593341 0.0000000 0.0000000 0.0000000 #> [4,] 0.0000000 0.0000000 0.4922804 0.0000000 0.0000000 #> [5,] 0.0000000 0.0000000 0.0000000 0.2994381 0.1285137 #>  #> [[3]] #>           [,1]      [,2]      [,3]      [,4]       [,5] #> [1,] 0.0000000 0.0000000 3.2839578 3.2839578 3.28395781 #> [2,] 0.6591217 0.0000000 0.0000000 0.0000000 0.00000000 #> [3,] 0.0000000 0.5037044 0.0000000 0.0000000 0.00000000 #> [4,] 0.0000000 0.0000000 0.3236247 0.0000000 0.00000000 #> [5,] 0.0000000 0.0000000 0.0000000 0.1562993 0.04720172 #>  #> [[4]] #>           [,1]      [,2]      [,3]      [,4]      [,5]       [,6] #> [1,] 0.0000000 0.0000000 2.8383014 2.8383014 2.8383014 2.83830135 #> [2,] 0.7775471 0.0000000 0.0000000 0.0000000 0.0000000 0.00000000 #> [3,] 0.0000000 0.6636757 0.0000000 0.0000000 0.0000000 0.00000000 #> [4,] 0.0000000 0.0000000 0.5127486 0.0000000 0.0000000 0.00000000 #> [5,] 0.0000000 0.0000000 0.0000000 0.3367703 0.0000000 0.00000000 #> [6,] 0.0000000 0.0000000 0.0000000 0.0000000 0.1697708 0.05561344 #>  #> [[5]] #>           [,1]      [,2]      [,3]      [,4] #> [1,] 0.0000000 0.0000000 4.9355718 4.9355718 #> [2,] 0.5533382 0.0000000 0.0000000 0.0000000 #> [3,] 0.0000000 0.3959549 0.0000000 0.0000000 #> [4,] 0.0000000 0.0000000 0.2344795 0.1032486"},{"path":"https://jonesor.github.io/mpmsim/index.html","id":"simulate-sampling-error-for-an-mpm","dir":"","previous_headings":"Usage","what":"Simulate sampling error for an MPM","title":"Simulation of Matrix Population Models with Defined Life History Characteristics","text":"function add_mpm_error can used simulate MPM sampling error, based expected transition rates (survival fecundity) sample sizes. expected transition rates must provided matrices. sample size(s) can given either matrix sample sizes element matrix single value applied elements matrix. function uses binomial process simulate survival/growth elements Poisson process simulate fecundity elements. result, sample sizes large, simulated MPM closely reflect expected transition rates. contrast, sample sizes small, simulated matrices become variable. illustrate use function, following code first generates 3-stage Leslie matrix using make_leslie_mpm function. passes U F matrices Leslie matrix add_mpm_error function. , two matrices simulated, first sample size 1000, sample size seven. list arbitrary number matrices can generated easily using replicate, follows.","code":"mats <- make_leslie_mpm(   survival = c(0.3, 0.5, 0.8),   fertility = c(0, 2.2, 4.4),   n_stages = 3, split = TRUE )  add_mpm_error(   mat_U = mats$mat_U, mat_F = mats$mat_F,   sample_size = 1000, split = FALSE, by_type = FALSE ) #>       [,1]  [,2]  [,3] #> [1,] 0.000 2.255 4.482 #> [2,] 0.287 0.000 0.000 #> [3,] 0.000 0.507 0.794  add_mpm_error(   mat_U = mats$mat_U, mat_F = mats$mat_F,   sample_size = 7, split = FALSE, by_type = FALSE ) #>           [,1]      [,2]     [,3] #> [1,] 0.0000000 1.8571429 4.714286 #> [2,] 0.4285714 0.0000000 0.000000 #> [3,] 0.0000000 0.7142857 1.000000 replicate(   n = 5,   add_mpm_error(     mat_U = mats$mat_U, mat_F = mats$mat_F,     sample_size = 7, split = FALSE, by_type = FALSE   ) ) #> , , 1 #>  #>      [,1]      [,2]      [,3] #> [1,]    0 1.5714286 4.1428571 #> [2,]    0 0.0000000 0.0000000 #> [3,]    0 0.4285714 0.7142857 #>  #> , , 2 #>  #>           [,1]      [,2]      [,3] #> [1,] 0.0000000 2.2857143 5.5714286 #> [2,] 0.7142857 0.0000000 0.0000000 #> [3,] 0.0000000 0.5714286 0.7142857 #>  #> , , 3 #>  #>           [,1]      [,2]      [,3] #> [1,] 0.0000000 2.1428571 4.4285714 #> [2,] 0.1428571 0.0000000 0.0000000 #> [3,] 0.0000000 0.5714286 0.5714286 #>  #> , , 4 #>  #>           [,1]      [,2]      [,3] #> [1,] 0.0000000 1.7142857 4.0000000 #> [2,] 0.7142857 0.0000000 0.0000000 #> [3,] 0.0000000 0.5714286 0.8571429 #>  #> , , 5 #>  #>           [,1]      [,2]      [,3] #> [1,] 0.0000000 2.5714286 4.5714286 #> [2,] 0.4285714 0.0000000 0.0000000 #> [3,] 0.0000000 0.4285714 0.7142857"},{"path":"https://jonesor.github.io/mpmsim/index.html","id":"generate-single-random-lefkovitch-mpms","dir":"","previous_headings":"Usage","what":"Generate single random Lefkovitch MPMs","title":"Simulation of Matrix Population Models with Defined Life History Characteristics","text":"random_mpm function can used generate random Lefkovitch matrix population model (MPM) element values based defined life history archetypes. function draws survival transition/growth probabilities Dirichlet distribution ensure column totals, including death, less equal 1. Fecundity can specified single value vector length equal dimensions matrix. specified single value, placed top-right corner matrix. specified vector length n_stages, spans entire top row matrix. archetype argument can used constrain MPMs, example, archetype = 2 constraints survival probability increase monotonically individuals advance later stages. information, see documentation random_mpm Takada et al. (2018). following example, split output matrices U F matrices, summed create matrix.","code":"(rMPM <- random_mpm(   n_stages = 3, fecundity = 20,   archetype = 2, split = TRUE )) #> $mat_A #>            [,1]        [,2]       [,3] #> [1,] 0.01566286 0.003962617 20.2372038 #> [2,] 0.19165445 0.447044844  0.1369993 #> [3,] 0.25834510 0.111258159  0.3916082 #>  #> $mat_U #>            [,1]        [,2]      [,3] #> [1,] 0.01566286 0.003962617 0.2372038 #> [2,] 0.19165445 0.447044844 0.1369993 #> [3,] 0.25834510 0.111258159 0.3916082 #>  #> $mat_F #>      [,1] [,2] [,3] #> [1,]    0    0   20 #> [2,]    0    0    0 #> [3,]    0    0    0"},{"path":"https://jonesor.github.io/mpmsim/index.html","id":"generate-a-set-of-random-lefkovitch-mpms","dir":"","previous_headings":"Usage","what":"Generate a set of random Lefkovitch MPMs","title":"Simulation of Matrix Population Models with Defined Life History Characteristics","text":"generate_mpm_set function can used quickly generate large numbers Lefkovitch MPMs using approach. example, following code generates five MPMs archetype 1. using constraint argument, users can specify acceptable characteristics set matrices. case, population growth rate range, can useful life history analyses might assume life histories lambda values close 1 can persist nature. set argument as_compadre = FALSE ensure function returns list object rather CompadreDB object.","code":"library(popbio) constrain_df <- data.frame(fun = \"lambda\", arg = NA, lower = 0.9, upper = 1.1) generate_mpm_set(   n = 5, n_stages = 4, fecundity = 8, archetype = 1, constraint = constrain_df,   as_compadre = FALSE ) #> $A_list #> $A_list[[1]] #>            [,1]       [,2]       [,3]       [,4] #> [1,] 0.18613484 0.05056112 0.60606250 8.03563397 #> [2,] 0.06525489 0.23191129 0.02425596 0.15026015 #> [3,] 0.30463553 0.08240703 0.08948712 0.02062413 #> [4,] 0.01236183 0.14045978 0.04548197 0.18125603 #>  #> $A_list[[2]] #>            [,1]       [,2]      [,3]       [,4] #> [1,] 0.24550383 0.17451532 0.3054684 8.31033310 #> [2,] 0.19319756 0.35861915 0.1851036 0.44100809 #> [3,] 0.11691720 0.28889696 0.1836001 0.08302706 #> [4,] 0.02694353 0.05514741 0.1076480 0.15043028 #>  #> $A_list[[3]] #>             [,1]       [,2]       [,3]       [,4] #> [1,] 0.027883153 0.28550192 0.18463803 8.18854957 #> [2,] 0.497257332 0.12466879 0.12901066 0.36556709 #> [3,] 0.000321996 0.12822913 0.07978954 0.03463416 #> [4,] 0.012942131 0.08459218 0.03693279 0.18702167 #>  #> $A_list[[4]] #>            [,1]        [,2]       [,3]       [,4] #> [1,] 0.45535069 0.079556357 0.01573857 8.44687525 #> [2,] 0.12608798 0.809470988 0.13932014 0.16388405 #> [3,] 0.35947604 0.063327966 0.26672277 0.04283801 #> [4,] 0.02558323 0.004365279 0.08267203 0.08580600 #>  #> $A_list[[5]] #>            [,1]       [,2]      [,3]       [,4] #> [1,] 0.05029395 0.33485342 0.2077841 8.06016689 #> [2,] 0.12684505 0.01529961 0.1784790 0.62796386 #> [3,] 0.19514844 0.40393834 0.3428090 0.03261264 #> [4,] 0.02243209 0.10121339 0.1090846 0.07553934 #>  #>  #> $U_list #> $U_list[[1]] #>            [,1]       [,2]       [,3]       [,4] #> [1,] 0.18613484 0.05056112 0.60606250 0.03563397 #> [2,] 0.06525489 0.23191129 0.02425596 0.15026015 #> [3,] 0.30463553 0.08240703 0.08948712 0.02062413 #> [4,] 0.01236183 0.14045978 0.04548197 0.18125603 #>  #> $U_list[[2]] #>            [,1]       [,2]      [,3]       [,4] #> [1,] 0.24550383 0.17451532 0.3054684 0.31033310 #> [2,] 0.19319756 0.35861915 0.1851036 0.44100809 #> [3,] 0.11691720 0.28889696 0.1836001 0.08302706 #> [4,] 0.02694353 0.05514741 0.1076480 0.15043028 #>  #> $U_list[[3]] #>             [,1]       [,2]       [,3]       [,4] #> [1,] 0.027883153 0.28550192 0.18463803 0.18854957 #> [2,] 0.497257332 0.12466879 0.12901066 0.36556709 #> [3,] 0.000321996 0.12822913 0.07978954 0.03463416 #> [4,] 0.012942131 0.08459218 0.03693279 0.18702167 #>  #> $U_list[[4]] #>            [,1]        [,2]       [,3]       [,4] #> [1,] 0.45535069 0.079556357 0.01573857 0.44687525 #> [2,] 0.12608798 0.809470988 0.13932014 0.16388405 #> [3,] 0.35947604 0.063327966 0.26672277 0.04283801 #> [4,] 0.02558323 0.004365279 0.08267203 0.08580600 #>  #> $U_list[[5]] #>            [,1]       [,2]      [,3]       [,4] #> [1,] 0.05029395 0.33485342 0.2077841 0.06016689 #> [2,] 0.12684505 0.01529961 0.1784790 0.62796386 #> [3,] 0.19514844 0.40393834 0.3428090 0.03261264 #> [4,] 0.02243209 0.10121339 0.1090846 0.07553934 #>  #>  #> $F_list #> $F_list[[1]] #>      [,1] [,2] [,3] [,4] #> [1,]    0    0    0    8 #> [2,]    0    0    0    0 #> [3,]    0    0    0    0 #> [4,]    0    0    0    0 #>  #> $F_list[[2]] #>      [,1] [,2] [,3] [,4] #> [1,]    0    0    0    8 #> [2,]    0    0    0    0 #> [3,]    0    0    0    0 #> [4,]    0    0    0    0 #>  #> $F_list[[3]] #>      [,1] [,2] [,3] [,4] #> [1,]    0    0    0    8 #> [2,]    0    0    0    0 #> [3,]    0    0    0    0 #> [4,]    0    0    0    0 #>  #> $F_list[[4]] #>      [,1] [,2] [,3] [,4] #> [1,]    0    0    0    8 #> [2,]    0    0    0    0 #> [3,]    0    0    0    0 #> [4,]    0    0    0    0 #>  #> $F_list[[5]] #>      [,1] [,2] [,3] [,4] #> [1,]    0    0    0    8 #> [2,]    0    0    0    0 #> [3,]    0    0    0    0 #> [4,]    0    0    0    0"},{"path":"https://jonesor.github.io/mpmsim/index.html","id":"plot-a-matrix","dir":"","previous_headings":"Usage","what":"Plot a matrix","title":"Simulation of Matrix Population Models with Defined Life History Characteristics","text":"can helpful visualise matrices. can accomplished function plot_matrix. output plot_matrix class ggplot colour scheme can modified usual way , example, scale_fill_gradient similar. ’s matrix: ’s plot:","code":"rMPM$mat_U #>            [,1]        [,2]      [,3] #> [1,] 0.01566286 0.003962617 0.2372038 #> [2,] 0.19165445 0.447044844 0.1369993 #> [3,] 0.25834510 0.111258159 0.3916082 p <- plot_matrix(rMPM$mat_U) p + ggplot2::scale_fill_gradient(low = \"black\", high = \"yellow\")"},{"path":"https://jonesor.github.io/mpmsim/index.html","id":"contributions","dir":"","previous_headings":"","what":"Contributions","title":"Simulation of Matrix Population Models with Defined Life History Characteristics","text":"contributions welcome. Please note project released Contributor Code Conduct. participating project agree abide terms. numerous ways contributing. can submit bug reports, suggestions etc. opening issue. can copy fork repository, make code edits send us pull request. ’s . also welcome email .","code":""},{"path":"https://jonesor.github.io/mpmsim/reference/add_mpm_error.html","id":null,"dir":"Reference","previous_headings":"","what":"Add sampling error to matrix population models (MPMs) based on expected values of transition rates and sample sizes — add_mpm_error","title":"Add sampling error to matrix population models (MPMs) based on expected values of transition rates and sample sizes — add_mpm_error","text":"Produces list matrix population models based expected values transition matrix sample size. expected values provided lists two submatrices: mat_U growth/development survival transitions mat_F fecundity transitions. output mat_U values simulated based expected probabilities, assuming binomial process sample size defined sample_size. output mat_F values simulated using Poisson process sample size defined sample_size.Thus users can expect large sample sizes result simulated matrices match closely expectations, simulated matrices small sample sizes variable.","code":""},{"path":"https://jonesor.github.io/mpmsim/reference/add_mpm_error.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Add sampling error to matrix population models (MPMs) based on expected values of transition rates and sample sizes — add_mpm_error","text":"","code":"add_mpm_error(mat_U, mat_F, sample_size, split = TRUE, by_type = TRUE)"},{"path":"https://jonesor.github.io/mpmsim/reference/add_mpm_error.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Add sampling error to matrix population models (MPMs) based on expected values of transition rates and sample sizes — add_mpm_error","text":"mat_U list U submatrices, single U submatrix. mat_F list F submatrices, single F submatrix. sample_size either (1) single matrix sample sizes element every MPM, (2) list two named matrices (\"mat_F_ss\", \"mat_U_ss\") containing sample sizes survival fertility submatrices every MPM (3) single value applied every element every matrix. split logical, whether split output survival fecundity matrices . Defaults TRUE. by_type logical indicating whether matrices returned list type (, U, F, C). split FALSE, by_type must also FALSE. Defaults TRUE.","code":""},{"path":"https://jonesor.github.io/mpmsim/reference/add_mpm_error.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Add sampling error to matrix population models (MPMs) based on expected values of transition rates and sample sizes — add_mpm_error","text":"list matrices survival fecundity split = TRUE, otherwise single matrix sum survival fecundity.","code":""},{"path":"https://jonesor.github.io/mpmsim/reference/add_mpm_error.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Add sampling error to matrix population models (MPMs) based on expected values of transition rates and sample sizes — add_mpm_error","text":"sample_size input 0, assumed estimate element(s) concerned known without error.","code":""},{"path":[]},{"path":"https://jonesor.github.io/mpmsim/reference/add_mpm_error.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Add sampling error to matrix population models (MPMs) based on expected values of transition rates and sample sizes — add_mpm_error","text":"Owen Jones jones@biology.sdu.dk","code":""},{"path":"https://jonesor.github.io/mpmsim/reference/add_mpm_error.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Add sampling error to matrix population models (MPMs) based on expected values of transition rates and sample sizes — add_mpm_error","text":"","code":"set.seed(42) # set seed for repeatability  # First generate a set of MPMs mpm_set <- generate_mpm_set(n = 5, n_stages = 5, fecundity = c(   0, 0, 4, 8, 10 ), archetype = 4, split = TRUE, by_type = TRUE, as_compadre = FALSE)  # Now apply sampling error to this set add_mpm_error(   mat_U = mpm_set$U_list, mat_F = mpm_set$F_list, sample_size =     50 ) #> $A_list #> $A_list[[1]] #>      [,1] [,2] [,3] [,4] [,5] #> [1,] 0.04 0.00 4.16 7.36 9.92 #> [2,] 0.40 0.38 0.00 0.00 0.00 #> [3,] 0.00 0.00 0.20 0.00 0.00 #> [4,] 0.00 0.00 0.44 0.42 0.00 #> [5,] 0.00 0.00 0.00 0.32 0.94 #>  #> $A_list[[2]] #>      [,1] [,2] [,3] [,4]  [,5] #> [1,] 0.02 0.00 3.88 8.14 11.38 #> [2,] 0.32 0.38 0.00 0.00  0.00 #> [3,] 0.00 0.02 0.64 0.00  0.00 #> [4,] 0.00 0.00 0.04 0.38  0.00 #> [5,] 0.00 0.00 0.00 0.32  0.76 #>  #> $A_list[[3]] #>      [,1] [,2] [,3] [,4] [,5] #> [1,]  0.5 0.00 4.34 8.06 9.58 #> [2,]  0.0 0.56 0.00 0.00 0.00 #> [3,]  0.0 0.20 0.38 0.00 0.00 #> [4,]  0.0 0.00 0.38 0.20 0.00 #> [5,]  0.0 0.00 0.00 0.68 1.00 #>  #> $A_list[[4]] #>      [,1] [,2] [,3] [,4] [,5] #> [1,] 0.26 0.00 3.66 8.24 9.34 #> [2,] 0.00 0.00 0.00 0.00 0.00 #> [3,] 0.00 0.38 0.06 0.00 0.00 #> [4,] 0.00 0.00 0.36 0.14 0.00 #> [5,] 0.00 0.00 0.00 0.58 0.88 #>  #> $A_list[[5]] #>      [,1] [,2] [,3] [,4] [,5] #> [1,] 0.20 0.00 4.24 7.44 9.80 #> [2,] 0.26 0.46 0.00 0.00 0.00 #> [3,] 0.00 0.08 0.70 0.00 0.00 #> [4,] 0.00 0.00 0.04 0.10 0.00 #> [5,] 0.00 0.00 0.00 0.58 0.78 #>  #>  #> $U_list #> $U_list[[1]] #>      [,1] [,2] [,3] [,4] [,5] #> [1,] 0.04 0.00 0.00 0.00 0.00 #> [2,] 0.40 0.38 0.00 0.00 0.00 #> [3,] 0.00 0.00 0.20 0.00 0.00 #> [4,] 0.00 0.00 0.44 0.42 0.00 #> [5,] 0.00 0.00 0.00 0.32 0.94 #>  #> $U_list[[2]] #>      [,1] [,2] [,3] [,4] [,5] #> [1,] 0.02 0.00 0.00 0.00 0.00 #> [2,] 0.32 0.38 0.00 0.00 0.00 #> [3,] 0.00 0.02 0.64 0.00 0.00 #> [4,] 0.00 0.00 0.04 0.38 0.00 #> [5,] 0.00 0.00 0.00 0.32 0.76 #>  #> $U_list[[3]] #>      [,1] [,2] [,3] [,4] [,5] #> [1,]  0.5 0.00 0.00 0.00    0 #> [2,]  0.0 0.56 0.00 0.00    0 #> [3,]  0.0 0.20 0.38 0.00    0 #> [4,]  0.0 0.00 0.38 0.20    0 #> [5,]  0.0 0.00 0.00 0.68    1 #>  #> $U_list[[4]] #>      [,1] [,2] [,3] [,4] [,5] #> [1,] 0.26 0.00 0.00 0.00 0.00 #> [2,] 0.00 0.00 0.00 0.00 0.00 #> [3,] 0.00 0.38 0.06 0.00 0.00 #> [4,] 0.00 0.00 0.36 0.14 0.00 #> [5,] 0.00 0.00 0.00 0.58 0.88 #>  #> $U_list[[5]] #>      [,1] [,2] [,3] [,4] [,5] #> [1,] 0.20 0.00 0.00 0.00 0.00 #> [2,] 0.26 0.46 0.00 0.00 0.00 #> [3,] 0.00 0.08 0.70 0.00 0.00 #> [4,] 0.00 0.00 0.04 0.10 0.00 #> [5,] 0.00 0.00 0.00 0.58 0.78 #>  #>  #> $F_list #> $F_list[[1]] #>      [,1] [,2] [,3] [,4] [,5] #> [1,]    0    0 4.16 7.36 9.92 #> [2,]    0    0 0.00 0.00 0.00 #> [3,]    0    0 0.00 0.00 0.00 #> [4,]    0    0 0.00 0.00 0.00 #> [5,]    0    0 0.00 0.00 0.00 #>  #> $F_list[[2]] #>      [,1] [,2] [,3] [,4]  [,5] #> [1,]    0    0 3.88 8.14 11.38 #> [2,]    0    0 0.00 0.00  0.00 #> [3,]    0    0 0.00 0.00  0.00 #> [4,]    0    0 0.00 0.00  0.00 #> [5,]    0    0 0.00 0.00  0.00 #>  #> $F_list[[3]] #>      [,1] [,2] [,3] [,4] [,5] #> [1,]    0    0 4.34 8.06 9.58 #> [2,]    0    0 0.00 0.00 0.00 #> [3,]    0    0 0.00 0.00 0.00 #> [4,]    0    0 0.00 0.00 0.00 #> [5,]    0    0 0.00 0.00 0.00 #>  #> $F_list[[4]] #>      [,1] [,2] [,3] [,4] [,5] #> [1,]    0    0 3.66 8.24 9.34 #> [2,]    0    0 0.00 0.00 0.00 #> [3,]    0    0 0.00 0.00 0.00 #> [4,]    0    0 0.00 0.00 0.00 #> [5,]    0    0 0.00 0.00 0.00 #>  #> $F_list[[5]] #>      [,1] [,2] [,3] [,4] [,5] #> [1,]    0    0 4.24 7.44  9.8 #> [2,]    0    0 0.00 0.00  0.0 #> [3,]    0    0 0.00 0.00  0.0 #> [4,]    0    0 0.00 0.00  0.0 #> [5,]    0    0 0.00 0.00  0.0 #>  #>   # Also works with a single matrix. mats <- make_leslie_mpm(   survival = c(0.1, 0.2, 0.5),   fertility = c(0, 1.2, 2.4),   n_stages = 3, split = TRUE )  # Sample size is a single value add_mpm_error(mat_U = mats$mat_U, mat_F = mats$mat_F, sample_size = 20) #> $mat_A #>      [,1] [,2] [,3] #> [1,]  0.0  1.0 2.50 #> [2,]  0.1  0.0 0.00 #> [3,]  0.0  0.2 0.45 #>  #> $mat_U #>      [,1] [,2] [,3] #> [1,]  0.0  0.0 0.00 #> [2,]  0.1  0.0 0.00 #> [3,]  0.0  0.2 0.45 #>  #> $mat_F #>      [,1] [,2] [,3] #> [1,]    0    1  2.5 #> [2,]    0    0  0.0 #> [3,]    0    0  0.0 #>   # Sample size is a list of two matrices # here with a sample size of 20 for reproduction and 10 for growth/survival. mpm_set <- generate_mpm_set(   n = 5, n_stages = 3, fecundity = c(0, 2, 4),   archetype = 4, split = TRUE, by_type = TRUE,   as_compadre = FALSE )  ssMats <- list(   \"mat_F_ss\" = matrix(20, nrow = 3, ncol = 3),   \"mat_U_ss\" = matrix(10, nrow = 3, ncol = 3) )  # Add sampling error to the matrix models output <- add_mpm_error(   mat_U = mpm_set$U_list, mat_F = mpm_set$F_list,   sample_size = ssMats )  # Examine the outputs names(output) #> [1] \"A_list\" \"U_list\" \"F_list\" output #> $A_list #> $A_list[[1]] #>      [,1] [,2] [,3] #> [1,]  0.3  1.5  4.1 #> [2,]  0.1  0.3  0.0 #> [3,]  0.0  0.5  1.0 #>  #> $A_list[[2]] #>      [,1] [,2] [,3] #> [1,]  0.5  2.2 4.25 #> [2,]  0.2  0.5 0.00 #> [3,]  0.0  0.3 0.70 #>  #> $A_list[[3]] #>      [,1] [,2] [,3] #> [1,]  0.0  1.9 4.15 #> [2,]  0.9  0.7 0.00 #> [3,]  0.0  0.0 1.00 #>  #> $A_list[[4]] #>      [,1] [,2] [,3] #> [1,]  0.5 1.45  3.7 #> [2,]  0.2 0.40  0.0 #> [3,]  0.0 0.40  1.0 #>  #> $A_list[[5]] #>      [,1] [,2] [,3] #> [1,]  0.7  1.9  3.8 #> [2,]  0.1  0.6  0.0 #> [3,]  0.0  0.4  1.0 #>  #>  #> $U_list #> $U_list[[1]] #>      [,1] [,2] [,3] #> [1,]  0.3  0.0    0 #> [2,]  0.1  0.3    0 #> [3,]  0.0  0.5    1 #>  #> $U_list[[2]] #>      [,1] [,2] [,3] #> [1,]  0.5  0.0  0.0 #> [2,]  0.2  0.5  0.0 #> [3,]  0.0  0.3  0.7 #>  #> $U_list[[3]] #>      [,1] [,2] [,3] #> [1,]  0.0  0.0    0 #> [2,]  0.9  0.7    0 #> [3,]  0.0  0.0    1 #>  #> $U_list[[4]] #>      [,1] [,2] [,3] #> [1,]  0.5  0.0    0 #> [2,]  0.2  0.4    0 #> [3,]  0.0  0.4    1 #>  #> $U_list[[5]] #>      [,1] [,2] [,3] #> [1,]  0.7  0.0    0 #> [2,]  0.1  0.6    0 #> [3,]  0.0  0.4    1 #>  #>  #> $F_list #> $F_list[[1]] #>      [,1] [,2] [,3] #> [1,]    0  1.5  4.1 #> [2,]    0  0.0  0.0 #> [3,]    0  0.0  0.0 #>  #> $F_list[[2]] #>      [,1] [,2] [,3] #> [1,]    0  2.2 4.25 #> [2,]    0  0.0 0.00 #> [3,]    0  0.0 0.00 #>  #> $F_list[[3]] #>      [,1] [,2] [,3] #> [1,]    0  1.9 4.15 #> [2,]    0  0.0 0.00 #> [3,]    0  0.0 0.00 #>  #> $F_list[[4]] #>      [,1] [,2] [,3] #> [1,]    0 1.45  3.7 #> [2,]    0 0.00  0.0 #> [3,]    0 0.00  0.0 #>  #> $F_list[[5]] #>      [,1] [,2] [,3] #> [1,]    0  1.9  3.8 #> [2,]    0  0.0  0.0 #> [3,]    0  0.0  0.0 #>  #>"},{"path":"https://jonesor.github.io/mpmsim/reference/calculate_errors.html","id":null,"dir":"Reference","previous_headings":"","what":"Calculate error (standard error or 95%CI) in elements of a matrix population model. — calculate_errors","title":"Calculate error (standard error or 95%CI) in elements of a matrix population model. — calculate_errors","text":"Given two submatrices matrix population model (mat_U mat_F, growth/survival matrix reproduction matrix respectively) sample size, matrix/matrices sample sizes, function calculates standard error 95% confidence interval (95%CI) element matrix. calculations assume mat_U result binomial processes (.e., survival (0/1) sample n individuals), mat_F result Poisson processes (.e., counts offspring n individuals), n sample size.","code":""},{"path":"https://jonesor.github.io/mpmsim/reference/calculate_errors.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Calculate error (standard error or 95%CI) in elements of a matrix population model. — calculate_errors","text":"","code":"calculate_errors(mat_U, mat_F, sample_size, type = \"sem\", calculate_A = TRUE)"},{"path":"https://jonesor.github.io/mpmsim/reference/calculate_errors.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Calculate error (standard error or 95%CI) in elements of a matrix population model. — calculate_errors","text":"mat_U matrix mean survival probabilities mat_F matrix mean fecundity values sample_size either (1) single matrix sample sizes element MPM, (2) list two named matrices (\"mat_F_ss\", \"mat_U_ss\") containing sample sizes survival fertility submatrices MPM (3) single value applied whole matrix type character string indicating type error calculate. Must one \"sem\" (standard error), \"CI95\" (95% confidence interval). calculate_A logical argument indicating whether returned error information include matrix error. Defaults TRUE.","code":""},{"path":"https://jonesor.github.io/mpmsim/reference/calculate_errors.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Calculate error (standard error or 95%CI) in elements of a matrix population model. — calculate_errors","text":"list containing original matrices error estimates (upper lower confidence intervals) U, F (optionally) matrices.","code":""},{"path":"https://jonesor.github.io/mpmsim/reference/calculate_errors.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Calculate error (standard error or 95%CI) in elements of a matrix population model. — calculate_errors","text":"output list containing original matrices matrices showing error estimates confidence intervals.","code":""},{"path":[]},{"path":"https://jonesor.github.io/mpmsim/reference/calculate_errors.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Calculate error (standard error or 95%CI) in elements of a matrix population model. — calculate_errors","text":"Owen Jones jones@biology.sdu.dk","code":""},{"path":"https://jonesor.github.io/mpmsim/reference/calculate_errors.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Calculate error (standard error or 95%CI) in elements of a matrix population model. — calculate_errors","text":"","code":"# Set up two submatrices matU <- matrix(c(   0.1, 0,   0.2, 0.4 ), byrow = TRUE, nrow = 2) matF <- matrix(c(   0, 4,   0., 0. ), byrow = TRUE, nrow = 2)  # errors as 95% CI, with a sample size of 20 for all elements calculate_errors(mat_U = matU, mat_F = matF, sample_size = 20, type = \"CI95\") #> $mat_F #>      [,1] [,2] #> [1,]    0    4 #> [2,]    0    0 #>  #> $mat_F_lowerCI #>      [,1]     [,2] #> [1,]    0 3.123461 #> [2,]    0 0.000000 #>  #> $mat_F_upperCI #>      [,1]     [,2] #> [1,]    0 4.876539 #> [2,]    0 0.000000 #>  #> $mat_U #>      [,1] [,2] #> [1,]  0.1  0.0 #> [2,]  0.2  0.4 #>  #> $mat_U_lowerCI #>            [,1]      [,2] #> [1,] 0.00000000 0.0000000 #> [2,] 0.02469227 0.1852928 #>  #> $mat_U_upperCI #>           [,1]      [,2] #> [1,] 0.2314808 0.0000000 #> [2,] 0.3753077 0.6147072 #>  #> $mat_A #>      [,1] [,2] #> [1,]  0.1  4.0 #> [2,]  0.2  0.4 #>  #> $mat_A_lowerCI #>            [,1]      [,2] #> [1,] 0.00000000 3.1234614 #> [2,] 0.02469227 0.1852928 #>  #> $mat_A_upperCI #>           [,1]      [,2] #> [1,] 0.2314808 4.8765386 #> [2,] 0.3753077 0.6147072 #>   # errors as sem, with a sample size of 20 for all elements calculate_errors(mat_U = matU, mat_F = matF, sample_size = 20, type = \"sem\") #> $mat_U #>      [,1] [,2] #> [1,]  0.1  0.0 #> [2,]  0.2  0.4 #>  #> $`,mat_U_error` #>            [,1]      [,2] #> [1,] 0.06708204 0.0000000 #> [2,] 0.08944272 0.1095445 #>  #> $mat_F #>      [,1] [,2] #> [1,]    0    4 #> [2,]    0    0 #>  #> $mat_F_error #>      [,1]      [,2] #> [1,]    0 0.4472136 #> [2,]    0 0.0000000 #>  #> $mat_A #>      [,1] [,2] #> [1,]    0    4 #> [2,]    0    0 #>  #> $mat_A_error #>            [,1]      [,2] #> [1,] 0.06708204 0.4472136 #> [2,] 0.08944272 0.1095445 #>   # Sample size is a single matrix applied to both F and U matrices ssMat <- matrix(10, nrow = 2, ncol = 2)  calculate_errors(   mat_U = matU, mat_F = matF, sample_size = ssMat, type =     \"sem\" ) #> $mat_U #>      [,1] [,2] #> [1,]  0.1  0.0 #> [2,]  0.2  0.4 #>  #> $`,mat_U_error` #>            [,1]      [,2] #> [1,] 0.09486833 0.0000000 #> [2,] 0.12649111 0.1549193 #>  #> $mat_F #>      [,1] [,2] #> [1,]    0    4 #> [2,]    0    0 #>  #> $mat_F_error #>      [,1]      [,2] #> [1,]    0 0.6324555 #> [2,]    0 0.0000000 #>  #> $mat_A #>      [,1] [,2] #> [1,]    0    4 #> [2,]    0    0 #>  #> $mat_A_error #>            [,1]      [,2] #> [1,] 0.09486833 0.6324555 #> [2,] 0.12649111 0.1549193 #>   # Sample size is a list of two matrices, one for F and one for U. ssMats <- list(   \"mat_F_ss\" = matrix(10, nrow = 2, ncol = 2),   \"mat_U_ss\" = matrix(10, nrow = 2, ncol = 2) ) calculate_errors(   mat_U = matU, mat_F = matF, sample_size = ssMats, type =     \"sem\" ) #> $mat_U #>      [,1] [,2] #> [1,]  0.1  0.0 #> [2,]  0.2  0.4 #>  #> $`,mat_U_error` #>            [,1]      [,2] #> [1,] 0.09486833 0.0000000 #> [2,] 0.12649111 0.1549193 #>  #> $mat_F #>      [,1] [,2] #> [1,]    0    4 #> [2,]    0    0 #>  #> $mat_F_error #>      [,1]      [,2] #> [1,]    0 0.6324555 #> [2,]    0 0.0000000 #>  #> $mat_A #>      [,1] [,2] #> [1,]    0    4 #> [2,]    0    0 #>  #> $mat_A_error #>            [,1]      [,2] #> [1,] 0.09486833 0.6324555 #> [2,] 0.12649111 0.1549193 #>"},{"path":"https://jonesor.github.io/mpmsim/reference/compute_ci.html","id":null,"dir":"Reference","previous_headings":"","what":"Compute 95% confidence intervals for derived estimates from a matrix population model — compute_ci","title":"Compute 95% confidence intervals for derived estimates from a matrix population model — compute_ci","text":"function computes 95% confidence interval measures derived matrix population model using parametric bootstrapping. approach sampling distribution matrix population model (MPM) generated taking large number random independent draws using sampling distribution underlying transition rate. approach rests assumption survival-related processes binomial, reproduction Poisson process (see function add_mpm_error() details).","code":""},{"path":"https://jonesor.github.io/mpmsim/reference/compute_ci.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Compute 95% confidence intervals for derived estimates from a matrix population model — compute_ci","text":"","code":"compute_ci(mat_U, mat_F, sample_size, FUN, ..., n_sim = 1000, dist.out = FALSE)"},{"path":"https://jonesor.github.io/mpmsim/reference/compute_ci.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Compute 95% confidence intervals for derived estimates from a matrix population model — compute_ci","text":"mat_U matrix describes growth survival process. mat_F matrix describes reproduction. sample_size either (1) single matrix sample sizes element MPM, (2) list two named matrices (\"mat_F_ss\", \"mat_U_ss\") containing sample sizes survival fertility submatrices MPM (3) single value applied whole matrix FUN function apply simulated matrix population model. function must take, input, single matrix population model (.e., matrix). functions require U matrix, use compute_ci_U. ... Additional arguments passed FUN. n_sim integer indicating number simulations run. Default 1000. dist.Logical. TRUE, returns list quantiles simulated estimates. Default FALSE.","code":""},{"path":"https://jonesor.github.io/mpmsim/reference/compute_ci.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Compute 95% confidence intervals for derived estimates from a matrix population model — compute_ci","text":"dist.FALSE, numeric vector 2.5th 97.5th quantiles estimated measures. dist.= TRUE, list two elements: quantiles estimates. quantiles numeric vector 2.5th 97.5th quantiles estimated measures, estimates numeric vector estimated measures.","code":""},{"path":"https://jonesor.github.io/mpmsim/reference/compute_ci.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Compute 95% confidence intervals for derived estimates from a matrix population model — compute_ci","text":"inputs U matrix, describes survival-related processes, F matrix describes reproduction. underlying assumption U matrix average binomial process F matrix average Poisson process . confidence interval depend largely sample size used.","code":""},{"path":"https://jonesor.github.io/mpmsim/reference/compute_ci.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Compute 95% confidence intervals for derived estimates from a matrix population model — compute_ci","text":"Chapter 12 Caswell, H. (2001). Matrix Population Models. Sinauer Associates Incorporated.","code":""},{"path":[]},{"path":"https://jonesor.github.io/mpmsim/reference/compute_ci.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Compute 95% confidence intervals for derived estimates from a matrix population model — compute_ci","text":"Owen Jones jones@biology.sdu.dk","code":""},{"path":"https://jonesor.github.io/mpmsim/reference/compute_ci.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Compute 95% confidence intervals for derived estimates from a matrix population model — compute_ci","text":"","code":"set.seed(42) # set seed for repeatability  # Data for use in example matU <- matrix(c(   0.1, 0.0,   0.2, 0.4 ), byrow = TRUE, nrow = 2)  matF <- matrix(c(   0.0, 5.0,   0.0, 0.0 ), byrow = TRUE, nrow = 2)  set.seed(42)  # Example of use to calculate 95% CI of lambda compute_ci(   mat_U = matU, mat_F = matF, sample_size = 10, FUN =     popbio::lambda ) #>     2.5%    97.5%  #> 0.300000 1.824895   # Example of use to calculate 95% CI of generation time compute_ci(   mat_U = matU, mat_F = matF, sample_size = 40, FUN =     popbio::generation.time ) #>     2.5%    97.5%  #> 2.386966 3.072293   # Example of use to calculate 95% CI of generation time and show the # distribution of those bootstrapped estimates xx <- compute_ci(   mat_U = matU, mat_F = matF, sample_size = 100, FUN =     popbio::generation.time, dist.out = TRUE ) summary(xx$quantiles) #>    Min. 1st Qu.  Median    Mean 3rd Qu.    Max.  #>   2.476   2.581   2.686   2.686   2.791   2.896  hist(xx$estimates)"},{"path":"https://jonesor.github.io/mpmsim/reference/compute_ci_U.html","id":null,"dir":"Reference","previous_headings":"","what":"Compute 95% confidence intervals for derived estimates from the U submatrix of a matrix population model — compute_ci_U","title":"Compute 95% confidence intervals for derived estimates from the U submatrix of a matrix population model — compute_ci_U","text":"function computes 95% confidence interval measures derived U submatrix matrix population model using parametric bootstrapping. approach sampling distribution U submatrix generated taking large number random independent draws using sampling distribution underlying transition rate. approach rests assumption survival-related processes binomial (see function add_mpm_error() details).","code":""},{"path":"https://jonesor.github.io/mpmsim/reference/compute_ci_U.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Compute 95% confidence intervals for derived estimates from the U submatrix of a matrix population model — compute_ci_U","text":"","code":"compute_ci_U(mat_U, sample_size, FUN, ..., n_sim = 1000, dist.out = FALSE)"},{"path":"https://jonesor.github.io/mpmsim/reference/compute_ci_U.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Compute 95% confidence intervals for derived estimates from the U submatrix of a matrix population model — compute_ci_U","text":"mat_U matrix describes growth survival process. sample_size either (1) single matrix sample sizes element U matrix, (2) single value applied whole matrix FUN function apply simulated matrix population model. function must take, input, single U submatrix matrix population model (.e., U matrix). functions require matrix, use compute_ci. ... Additional arguments passed FUN. n_sim integer indicating number simulations run. Default 1000. dist.Logical. TRUE, returns list quantiles simulated estimates. Default FALSE.","code":""},{"path":"https://jonesor.github.io/mpmsim/reference/compute_ci_U.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Compute 95% confidence intervals for derived estimates from the U submatrix of a matrix population model — compute_ci_U","text":"dist.FALSE, numeric vector 2.5th 97.5th quantiles estimated measures. dist.= TRUE, list two elements: quantiles estimates. quantiles numeric vector 2.5th 97.5th quantiles estimated measures, estimates numeric vector estimated measures.","code":""},{"path":"https://jonesor.github.io/mpmsim/reference/compute_ci_U.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Compute 95% confidence intervals for derived estimates from the U submatrix of a matrix population model — compute_ci_U","text":"main inputs U matrix, describes survival-related processes. underlying assumption U matrix average binomial process. confidence interval depend largely sample size used.","code":""},{"path":"https://jonesor.github.io/mpmsim/reference/compute_ci_U.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Compute 95% confidence intervals for derived estimates from the U submatrix of a matrix population model — compute_ci_U","text":"Chapter 12 Caswell, H. (2001). Matrix Population Models. Sinauer Associates Incorporated.","code":""},{"path":[]},{"path":"https://jonesor.github.io/mpmsim/reference/compute_ci_U.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Compute 95% confidence intervals for derived estimates from the U submatrix of a matrix population model — compute_ci_U","text":"Owen Jones jones@biology.sdu.dk","code":""},{"path":"https://jonesor.github.io/mpmsim/reference/compute_ci_U.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Compute 95% confidence intervals for derived estimates from the U submatrix of a matrix population model — compute_ci_U","text":"","code":"set.seed(42) # set seed for repeatability  # Data for use in example matU <- matrix(c(   0.1, 0.0,   0.2, 0.4 ), byrow = TRUE, nrow = 2)   # Example of use to calculate 95% CI of life expectancy compute_ci_U(   mat_U = matU, sample_size = 10, FUN =     Rage::life_expect_mean ) #>     2.5%    97.5%  #> 1.000000 2.334524   # Example of use to calculate 95% CI of generation time and show the # distribution of those bootstrapped estimates xx <- compute_ci_U(   mat_U = matU, sample_size = 100, FUN =     Rage::life_expect_mean, dist.out = TRUE )  summary(xx$quantiles) #>    Min. 1st Qu.  Median    Mean 3rd Qu.    Max.  #>   1.314   1.405   1.495   1.495   1.586   1.676  hist(xx$estimates)"},{"path":"https://jonesor.github.io/mpmsim/reference/driven_vital_rate.html","id":null,"dir":"Reference","previous_headings":"","what":"Calculate driven vital rates — driven_vital_rate","title":"Calculate driven vital rates — driven_vital_rate","text":"function calculates new values vital rate, survival fecundity influenced driver (e.g., weather). using driver variable baseline value, along specified slope relationship driver variable vital rate. function works linearised scale, using logit survival log fecundity, takes account error standard deviation.","code":""},{"path":"https://jonesor.github.io/mpmsim/reference/driven_vital_rate.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Calculate driven vital rates — driven_vital_rate","text":"","code":"driven_vital_rate(   driver,   baseline_value = NULL,   slope = NULL,   baseline_driver = NULL,   error_sd = 0,   link = \"logit\" )"},{"path":"https://jonesor.github.io/mpmsim/reference/driven_vital_rate.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Calculate driven vital rates — driven_vital_rate","text":"driver vector driver values. baseline_value vector matrix baseline values vital rate (e.g., survival) influenced (\"driven\") another variable (e.g. climatic variable). slope vector matrix slopes relationship driver variable vital rate driven. baseline_driver baseline_driver parameter single value representing baseline driver value. driver value greater value slope positive, resulting vital rate higher. Conversely, driver value less variable slope positive, resulting vital rate less baseline value. error_sd vector matrix error standard deviations random normal error added driven value vital rate modelled. set 0 (default), error added. link character string indicating type link function use. Valid values \"logit\" (default) \"log\", appropriate survival (U submatrix) reproduction (F submatrix) respectively.","code":""},{"path":"https://jonesor.github.io/mpmsim/reference/driven_vital_rate.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Calculate driven vital rates — driven_vital_rate","text":"Depending input types, either single value, vector list matrices driven values vital rate(s) modelled. list length equal length driver input parameter.","code":""},{"path":"https://jonesor.github.io/mpmsim/reference/driven_vital_rate.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Calculate driven vital rates — driven_vital_rate","text":"relationship driver variable vital rate assumed linear: $$V = * (d - d_b) + x + E$$ $$V$$ new vital rate (scale linear predictor), $$$$ slope, $$x$$ baseline vital rate, $$d$$ driver, $$d_b$$ baseline driver $$E$$ error. input vital rate(s) (baseline_value) can single-element vector representing single vital rate (e.g., survival probability fecundity), longer vector representing series vital rates (e.g., several survival probabilities fecundity values), matrix values (e.g., U F submatrix matrix population model). slopes relationship vital rate (baseline_value) driver can provided single value, applied elements input vital rates, matrix values map onto matrix vital rates. allows users simulate cases different vital rates matrix model affected different ways weather driver. example, juvenile survival might affected driver adult survival. baseline_driver value represents \"normal\" state driver. driver greater baseline_driver slope positive, outcome vital rate higher. driver less baseline_driver variable slope positive, outcome vital rate less baseline_value. error_sd represents error linear relationship driver vital rate.","code":""},{"path":"https://jonesor.github.io/mpmsim/reference/driven_vital_rate.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Calculate driven vital rates — driven_vital_rate","text":"Owen Jones jones@biology.sdu.dk","code":""},{"path":"https://jonesor.github.io/mpmsim/reference/driven_vital_rate.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Calculate driven vital rates — driven_vital_rate","text":"","code":"set.seed(42) # set seed for repeatability  # A single vital rate and a single driver driven_vital_rate(   driver = 14,   baseline_value = 0.5,   slope = .4,   baseline_driver = 10,   error_sd = 0,   link = \"logit\" ) #> [1] 0.8320184  # A single vital rate and a time series of drivers driven_vital_rate(   driver = runif(10, 5, 15),   baseline_value = 0.5,   slope = .4,   baseline_driver = 10,   error_sd = 0,   link = \"logit\" ) #> [[1]] #> [1] 0.8401338 #>  #> [[2]] #> [1] 0.8517385 #>  #> [[3]] #> [1] 0.2982926 #>  #> [[4]] #> [1] 0.7894794 #>  #> [[5]] #> [1] 0.6380665 #>  #> [[6]] #> [1] 0.5190867 #>  #> [[7]] #> [1] 0.7203812 #>  #> [[8]] #> [1] 0.1882634 #>  #> [[9]] #> [1] 0.6520288 #>  #> [[10]] #> [1] 0.6942913 #>   # A matrix of survival values (U submatrix of a Leslie model) # with a series of drivers, and matrices of slopes and errors  lt1 <- model_survival(params = c(b_0 = 0.4, b_1 = 0.5), model = \"Gompertz\") lt1$fert <- model_fertility(   age = 0:max(lt1$x), params = c(A = 10),   maturity = 3, model = \"step\" )  mats <- make_leslie_mpm(   survival = lt1$px, fertility = lt1$fert, n_stages =     nrow(lt1), split = TRUE ) mats$mat_U #>           [,1]      [,2]      [,3]       [,4] #> [1,] 0.0000000 0.0000000 0.0000000 0.00000000 #> [2,] 0.5887555 0.0000000 0.0000000 0.00000000 #> [3,] 0.0000000 0.4175293 0.0000000 0.00000000 #> [4,] 0.0000000 0.0000000 0.2369291 0.09309368 mat_dim <- nrow(mats$mat_U)  driven_vital_rate(   driver = runif(5, 5, 15),   baseline_value = mats$mat_U,   slope = matrix(.4,     nrow = mat_dim,     ncol = mat_dim   ),   baseline_driver = 10,   error_sd = matrix(1, nrow = mat_dim, ncol = mat_dim),   link = \"logit\" ) #> [[1]] #>           [,1]      [,2]      [,3]     [,4] #> [1,] 0.0000000 0.0000000 0.0000000 0.000000 #> [2,] 0.2693641 0.0000000 0.0000000 0.000000 #> [3,] 0.0000000 0.6927488 0.0000000 0.000000 #> [4,] 0.0000000 0.0000000 0.1040332 0.326901 #>  #> [[2]] #>           [,1]      [,2]      [,3]      [,4] #> [1,] 0.0000000 0.0000000 0.0000000 0.0000000 #> [2,] 0.8231306 0.0000000 0.0000000 0.0000000 #> [3,] 0.0000000 0.6409893 0.0000000 0.0000000 #> [4,] 0.0000000 0.0000000 0.2693954 0.1522152 #>  #> [[3]] #>           [,1]      [,2]      [,3]       [,4] #> [1,] 0.0000000 0.0000000 0.0000000 0.00000000 #> [2,] 0.7492108 0.0000000 0.0000000 0.00000000 #> [3,] 0.0000000 0.1103529 0.0000000 0.00000000 #> [4,] 0.0000000 0.0000000 0.4470173 0.03307616 #>  #> [[4]] #>           [,1]     [,2]     [,3]        [,4] #> [1,] 0.0000000 0.000000 0.000000 0.000000000 #> [2,] 0.3233925 0.000000 0.000000 0.000000000 #> [3,] 0.0000000 0.252657 0.000000 0.000000000 #> [4,] 0.0000000 0.000000 0.350992 0.009396171 #>  #> [[5]] #>          [,1]      [,2]       [,3]       [,4] #> [1,] 0.000000 0.0000000 0.00000000 0.00000000 #> [2,] 0.752661 0.0000000 0.00000000 0.00000000 #> [3,] 0.000000 0.5681767 0.00000000 0.00000000 #> [4,] 0.000000 0.0000000 0.09643508 0.07751234 #>"},{"path":"https://jonesor.github.io/mpmsim/reference/generate_mpm_set.html","id":null,"dir":"Reference","previous_headings":"","what":"Generate lists of Lefkovitch matrix population models (MPMs) based on life history archetypes — generate_mpm_set","title":"Generate lists of Lefkovitch matrix population models (MPMs) based on life history archetypes — generate_mpm_set","text":"function generates list n MPMs according specified criteria. Criteria include archetype, acceptable constraining criteria, include lambda, generation time metric derived matrix. function attempts find matrices fulfil criteria, discarding unacceptable matrices. default, takes 1000 attempts find suitable matrix model, error produced. However, number attempts can altered attempts parameter.","code":""},{"path":"https://jonesor.github.io/mpmsim/reference/generate_mpm_set.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Generate lists of Lefkovitch matrix population models (MPMs) based on life history archetypes — generate_mpm_set","text":"","code":"generate_mpm_set(   n = 10,   n_stages = 3,   archetype = 1,   fecundity = 1.5,   split = TRUE,   by_type = TRUE,   as_compadre = TRUE,   max_surv = 0.99,   constraint = NULL,   attempts = 1000 )"},{"path":"https://jonesor.github.io/mpmsim/reference/generate_mpm_set.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Generate lists of Lefkovitch matrix population models (MPMs) based on life history archetypes — generate_mpm_set","text":"n number MPMs generate. Default 10. n_stages number stages MPMs. Default 3. archetype archetype MPMs. Default 1. fecundity vector fecundities MPMs. Default 1.5. split logical indicating whether split submatrices. Default TRUE. by_type logical indicating whether matrices returned list type (, U, F, C). split FALSE, by_type must coerced FALSE. Defaults TRUE. as_compadre logical indicating whether matrices returned CompadreDB object. Default TRUE. FALSE, function returns list. max_surv maximum acceptable survival value, calculated across transitions stage. Defaults 0.99. used split = TRUE. constraint optional data frame 4 columns named fun, arg, lower upper. columns specify (1) function outputs metric derived matrix (2) argument function (NA, argument supplied) (3) lower acceptable bound metric (4) upper acceptable bound metric. used specify attempts integer indicating number attempts made simulating matrix model. default 1000. takes 1000 attempts make matrix satisfies conditions set arguments, warning produced.","code":""},{"path":"https://jonesor.github.io/mpmsim/reference/generate_mpm_set.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Generate lists of Lefkovitch matrix population models (MPMs) based on life history archetypes — generate_mpm_set","text":"list MPMs meet specified criteria.","code":""},{"path":[]},{"path":"https://jonesor.github.io/mpmsim/reference/generate_mpm_set.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Generate lists of Lefkovitch matrix population models (MPMs) based on life history archetypes — generate_mpm_set","text":"Owen Jones jones@biology.sdu.dk","code":""},{"path":"https://jonesor.github.io/mpmsim/reference/generate_mpm_set.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Generate lists of Lefkovitch matrix population models (MPMs) based on life history archetypes — generate_mpm_set","text":"","code":"set.seed(42) # set seed for repeatability  # Basic operation, without splitting matrices and with no constraints generate_mpm_set(   n = 10, n_stages = 5, fecundity = c(0, 0, 4, 8, 10),   archetype = 4, split = FALSE, by_type = FALSE, as_compadre = FALSE ) #> [[1]] #>            [,1]       [,2]      [,3]      [,4]       [,5] #> [1,] 0.04028499 0.00000000 4.0000000 8.0000000 10.0000000 #> [2,] 0.71907852 0.73066610 0.0000000 0.0000000  0.0000000 #> [3,] 0.00000000 0.06797628 0.5129277 0.0000000  0.0000000 #> [4,] 0.00000000 0.00000000 0.2895418 0.8589953  0.0000000 #> [5,] 0.00000000 0.00000000 0.0000000 0.1331578  0.9997924 #>  #> [[2]] #>            [,1]       [,2]      [,3]      [,4]       [,5] #> [1,] 0.04993404 0.00000000 4.0000000 8.0000000 10.0000000 #> [2,] 0.35213116 0.38662704 0.0000000 0.0000000  0.0000000 #> [3,] 0.00000000 0.04413311 0.2022055 0.0000000  0.0000000 #> [4,] 0.00000000 0.00000000 0.4116914 0.4473679  0.0000000 #> [5,] 0.00000000 0.00000000 0.0000000 0.4300040  0.9673925 #>  #> [[3]] #>           [,1]      [,2]      [,3]      [,4]       [,5] #> [1,] 0.3908713 0.0000000 4.0000000 8.0000000 10.0000000 #> [2,] 0.1593942 0.3008004 0.0000000 0.0000000  0.0000000 #> [3,] 0.0000000 0.4611680 0.5792468 0.0000000  0.0000000 #> [4,] 0.0000000 0.0000000 0.2741919 0.2238051  0.0000000 #> [5,] 0.0000000 0.0000000 0.0000000 0.6835265  0.9941976 #>  #> [[4]] #>            [,1]       [,2]       [,3]      [,4]       [,5] #> [1,] 0.01338708 0.00000000 4.00000000 8.0000000 10.0000000 #> [2,] 0.46380038 0.47987890 0.00000000 0.0000000  0.0000000 #> [3,] 0.00000000 0.03799584 0.64886531 0.0000000  0.0000000 #> [4,] 0.00000000 0.00000000 0.01000717 0.3753701  0.0000000 #> [5,] 0.00000000 0.00000000 0.00000000 0.3401858  0.7684915 #>  #> [[5]] #>            [,1]      [,2]      [,3]      [,4]       [,5] #> [1,] 0.67478475 0.0000000 4.0000000 8.0000000 10.0000000 #> [2,] 0.04733024 0.4311501 0.0000000 0.0000000  0.0000000 #> [3,] 0.00000000 0.4961576 0.3634766 0.0000000  0.0000000 #> [4,] 0.00000000 0.0000000 0.5725528 0.7279782  0.0000000 #> [5,] 0.00000000 0.0000000 0.0000000 0.2540920  0.9967819 #>  #> [[6]] #>           [,1]      [,2]      [,3]      [,4]       [,5] #> [1,] 0.3819523 0.0000000 4.0000000 8.0000000 10.0000000 #> [2,] 0.2431420 0.3941680 0.0000000 0.0000000  0.0000000 #> [3,] 0.0000000 0.4929144 0.2382274 0.0000000  0.0000000 #> [4,] 0.0000000 0.0000000 0.7382744 0.7182629  0.0000000 #> [5,] 0.0000000 0.0000000 0.0000000 0.2756301  0.9947253 #>  #> [[7]] #>            [,1]      [,2]       [,3]       [,4]       [,5] #> [1,] 0.16074427 0.0000000 4.00000000 8.00000000 10.0000000 #> [2,] 0.03843446 0.1920300 0.00000000 0.00000000  0.0000000 #> [3,] 0.00000000 0.5599534 0.83063495 0.00000000  0.0000000 #> [4,] 0.00000000 0.0000000 0.01691095 0.06976802  0.0000000 #> [5,] 0.00000000 0.0000000 0.00000000 0.92957038  0.9997121 #>  #> [[8]] #>            [,1]      [,2]      [,3]      [,4]       [,5] #> [1,] 0.11547275 0.0000000 4.0000000 8.0000000 10.0000000 #> [2,] 0.09164534 0.3982819 0.0000000 0.0000000  0.0000000 #> [3,] 0.00000000 0.1783419 0.4565705 0.0000000  0.0000000 #> [4,] 0.00000000 0.0000000 0.3108012 0.7438372  0.0000000 #> [5,] 0.00000000 0.0000000 0.0000000 0.2286126  0.9994464 #>  #> [[9]] #>            [,1]      [,2]      [,3]      [,4]       [,5] #> [1,] 0.40726303 0.0000000 4.0000000 8.0000000 10.0000000 #> [2,] 0.02472534 0.5507259 0.0000000 0.0000000  0.0000000 #> [3,] 0.00000000 0.1762418 0.4303426 0.0000000  0.0000000 #> [4,] 0.00000000 0.0000000 0.3952927 0.1772480  0.0000000 #> [5,] 0.00000000 0.0000000 0.0000000 0.7574622  0.9818421 #>  #> [[10]] #>             [,1]       [,2]      [,3]      [,4]       [,5] #> [1,] 0.195267196 0.00000000 4.0000000 8.0000000 10.0000000 #> [2,] 0.009539193 0.01108828 0.0000000 0.0000000  0.0000000 #> [3,] 0.000000000 0.40598266 0.1292108 0.0000000  0.0000000 #> [4,] 0.000000000 0.00000000 0.3215483 0.2109751  0.0000000 #> [5,] 0.000000000 0.00000000 0.0000000 0.4432477  0.8537529 #>   # Constrain outputs to A matrices with lambda between 0.9 and 1.1 library(popbio) constrain_df <- data.frame(   fun = \"lambda\", arg = NA, lower = 0.9, upper =     1.1 ) generate_mpm_set(   n = 10, n_stages = 5, fecundity = c(0, 0, 4, 8, 10),   archetype = 4, constraint = constrain_df, as_compadre = FALSE ) #> $A_list #> $A_list[[1]] #>           [,1]       [,2]       [,3]      [,4]      [,5] #> [1,] 0.2025021 0.00000000 4.00000000 8.0000000 10.000000 #> [2,] 0.1808410 0.51560726 0.00000000 0.0000000  0.000000 #> [3,] 0.0000000 0.05938074 0.69893955 0.0000000  0.000000 #> [4,] 0.0000000 0.00000000 0.04270201 0.1153077  0.000000 #> [5,] 0.0000000 0.00000000 0.00000000 0.6563415  0.905483 #>  #> $A_list[[2]] #>           [,1]       [,2]       [,3]      [,4]       [,5] #> [1,] 0.3492059 0.00000000 4.00000000 8.0000000 10.0000000 #> [2,] 0.2623854 0.59588086 0.00000000 0.0000000  0.0000000 #> [3,] 0.0000000 0.02204176 0.03327729 0.0000000  0.0000000 #> [4,] 0.0000000 0.00000000 0.64881290 0.1459793  0.0000000 #> [5,] 0.0000000 0.00000000 0.00000000 0.6109135  0.9411863 #>  #> $A_list[[3]] #>           [,1]      [,2]       [,3]      [,4]      [,5] #> [1,] 0.0100986 0.0000000 4.00000000 8.0000000 10.000000 #> [2,] 0.2816060 0.3421699 0.00000000 0.0000000  0.000000 #> [3,] 0.0000000 0.2403473 0.60176000 0.0000000  0.000000 #> [4,] 0.0000000 0.0000000 0.01202352 0.5052573  0.000000 #> [5,] 0.0000000 0.0000000 0.00000000 0.2482741  0.975591 #>  #> $A_list[[4]] #>            [,1]       [,2]      [,3]      [,4]       [,5] #> [1,] 0.05277117 0.00000000 4.0000000 8.0000000 10.0000000 #> [2,] 0.14635732 0.14395871 0.0000000 0.0000000  0.0000000 #> [3,] 0.00000000 0.09478692 0.2766104 0.0000000  0.0000000 #> [4,] 0.00000000 0.00000000 0.6115977 0.1849629  0.0000000 #> [5,] 0.00000000 0.00000000 0.0000000 0.7926018  0.9830451 #>  #> $A_list[[5]] #>           [,1]       [,2]      [,3]      [,4]      [,5] #> [1,] 0.2695917 0.00000000 4.0000000 8.0000000 10.000000 #> [2,] 0.2267870 0.45112437 0.0000000 0.0000000  0.000000 #> [3,] 0.0000000 0.05989263 0.3118949 0.0000000  0.000000 #> [4,] 0.0000000 0.00000000 0.3091554 0.2289075  0.000000 #> [5,] 0.0000000 0.00000000 0.0000000 0.6927089  0.956369 #>  #> $A_list[[6]] #>           [,1]      [,2]      [,3]       [,4]       [,5] #> [1,] 0.2788292 0.0000000 4.0000000 8.00000000 10.0000000 #> [2,] 0.0816387 0.2433186 0.0000000 0.00000000  0.0000000 #> [3,] 0.0000000 0.3089479 0.1000315 0.00000000  0.0000000 #> [4,] 0.0000000 0.0000000 0.4670093 0.73745701  0.0000000 #> [5,] 0.0000000 0.0000000 0.0000000 0.04978961  0.8887938 #>  #> $A_list[[7]] #>           [,1]      [,2]       [,3]      [,4]       [,5] #> [1,] 0.2772425 0.0000000 4.00000000 8.0000000 10.0000000 #> [2,] 0.1276093 0.4284850 0.00000000 0.0000000  0.0000000 #> [3,] 0.0000000 0.1104893 0.05017521 0.0000000  0.0000000 #> [4,] 0.0000000 0.0000000 0.60407149 0.1454031  0.0000000 #> [5,] 0.0000000 0.0000000 0.00000000 0.7206787  0.8721605 #>  #> $A_list[[8]] #>            [,1]      [,2]      [,3]       [,4]       [,5] #> [1,] 0.00794897 0.0000000 4.0000000 8.00000000 10.0000000 #> [2,] 0.10589532 0.2360636 0.0000000 0.00000000  0.0000000 #> [3,] 0.00000000 0.1030530 0.2807865 0.00000000  0.0000000 #> [4,] 0.00000000 0.0000000 0.1883105 0.62282892  0.0000000 #> [5,] 0.00000000 0.0000000 0.0000000 0.08604455  0.9653569 #>  #> $A_list[[9]] #>           [,1]     [,2]       [,3]      [,4]       [,5] #> [1,] 0.1495233 0.000000 4.00000000 8.0000000 10.0000000 #> [2,] 0.1741336 0.426369 0.00000000 0.0000000  0.0000000 #> [3,] 0.0000000 0.136707 0.62072487 0.0000000  0.0000000 #> [4,] 0.0000000 0.000000 0.06783148 0.1980795  0.0000000 #> [5,] 0.0000000 0.000000 0.00000000 0.5218206  0.7994516 #>  #> $A_list[[10]] #>            [,1]       [,2]       [,3]       [,4]       [,5] #> [1,] 0.04831774 0.00000000 4.00000000 8.00000000 10.0000000 #> [2,] 0.06775510 0.03037236 0.00000000 0.00000000  0.0000000 #> [3,] 0.00000000 0.37177964 0.09800894 0.00000000  0.0000000 #> [4,] 0.00000000 0.00000000 0.33187578 0.74345426  0.0000000 #> [5,] 0.00000000 0.00000000 0.00000000 0.01656937  0.7731065 #>  #>  #> $U_list #> $U_list[[1]] #>           [,1]       [,2]       [,3]      [,4]     [,5] #> [1,] 0.2025021 0.00000000 0.00000000 0.0000000 0.000000 #> [2,] 0.1808410 0.51560726 0.00000000 0.0000000 0.000000 #> [3,] 0.0000000 0.05938074 0.69893955 0.0000000 0.000000 #> [4,] 0.0000000 0.00000000 0.04270201 0.1153077 0.000000 #> [5,] 0.0000000 0.00000000 0.00000000 0.6563415 0.905483 #>  #> $U_list[[2]] #>           [,1]       [,2]       [,3]      [,4]      [,5] #> [1,] 0.3492059 0.00000000 0.00000000 0.0000000 0.0000000 #> [2,] 0.2623854 0.59588086 0.00000000 0.0000000 0.0000000 #> [3,] 0.0000000 0.02204176 0.03327729 0.0000000 0.0000000 #> [4,] 0.0000000 0.00000000 0.64881290 0.1459793 0.0000000 #> [5,] 0.0000000 0.00000000 0.00000000 0.6109135 0.9411863 #>  #> $U_list[[3]] #>           [,1]      [,2]       [,3]      [,4]     [,5] #> [1,] 0.0100986 0.0000000 0.00000000 0.0000000 0.000000 #> [2,] 0.2816060 0.3421699 0.00000000 0.0000000 0.000000 #> [3,] 0.0000000 0.2403473 0.60176000 0.0000000 0.000000 #> [4,] 0.0000000 0.0000000 0.01202352 0.5052573 0.000000 #> [5,] 0.0000000 0.0000000 0.00000000 0.2482741 0.975591 #>  #> $U_list[[4]] #>            [,1]       [,2]      [,3]      [,4]      [,5] #> [1,] 0.05277117 0.00000000 0.0000000 0.0000000 0.0000000 #> [2,] 0.14635732 0.14395871 0.0000000 0.0000000 0.0000000 #> [3,] 0.00000000 0.09478692 0.2766104 0.0000000 0.0000000 #> [4,] 0.00000000 0.00000000 0.6115977 0.1849629 0.0000000 #> [5,] 0.00000000 0.00000000 0.0000000 0.7926018 0.9830451 #>  #> $U_list[[5]] #>           [,1]       [,2]      [,3]      [,4]     [,5] #> [1,] 0.2695917 0.00000000 0.0000000 0.0000000 0.000000 #> [2,] 0.2267870 0.45112437 0.0000000 0.0000000 0.000000 #> [3,] 0.0000000 0.05989263 0.3118949 0.0000000 0.000000 #> [4,] 0.0000000 0.00000000 0.3091554 0.2289075 0.000000 #> [5,] 0.0000000 0.00000000 0.0000000 0.6927089 0.956369 #>  #> $U_list[[6]] #>           [,1]      [,2]      [,3]       [,4]      [,5] #> [1,] 0.2788292 0.0000000 0.0000000 0.00000000 0.0000000 #> [2,] 0.0816387 0.2433186 0.0000000 0.00000000 0.0000000 #> [3,] 0.0000000 0.3089479 0.1000315 0.00000000 0.0000000 #> [4,] 0.0000000 0.0000000 0.4670093 0.73745701 0.0000000 #> [5,] 0.0000000 0.0000000 0.0000000 0.04978961 0.8887938 #>  #> $U_list[[7]] #>           [,1]      [,2]       [,3]      [,4]      [,5] #> [1,] 0.2772425 0.0000000 0.00000000 0.0000000 0.0000000 #> [2,] 0.1276093 0.4284850 0.00000000 0.0000000 0.0000000 #> [3,] 0.0000000 0.1104893 0.05017521 0.0000000 0.0000000 #> [4,] 0.0000000 0.0000000 0.60407149 0.1454031 0.0000000 #> [5,] 0.0000000 0.0000000 0.00000000 0.7206787 0.8721605 #>  #> $U_list[[8]] #>            [,1]      [,2]      [,3]       [,4]      [,5] #> [1,] 0.00794897 0.0000000 0.0000000 0.00000000 0.0000000 #> [2,] 0.10589532 0.2360636 0.0000000 0.00000000 0.0000000 #> [3,] 0.00000000 0.1030530 0.2807865 0.00000000 0.0000000 #> [4,] 0.00000000 0.0000000 0.1883105 0.62282892 0.0000000 #> [5,] 0.00000000 0.0000000 0.0000000 0.08604455 0.9653569 #>  #> $U_list[[9]] #>           [,1]     [,2]       [,3]      [,4]      [,5] #> [1,] 0.1495233 0.000000 0.00000000 0.0000000 0.0000000 #> [2,] 0.1741336 0.426369 0.00000000 0.0000000 0.0000000 #> [3,] 0.0000000 0.136707 0.62072487 0.0000000 0.0000000 #> [4,] 0.0000000 0.000000 0.06783148 0.1980795 0.0000000 #> [5,] 0.0000000 0.000000 0.00000000 0.5218206 0.7994516 #>  #> $U_list[[10]] #>            [,1]       [,2]       [,3]       [,4]      [,5] #> [1,] 0.04831774 0.00000000 0.00000000 0.00000000 0.0000000 #> [2,] 0.06775510 0.03037236 0.00000000 0.00000000 0.0000000 #> [3,] 0.00000000 0.37177964 0.09800894 0.00000000 0.0000000 #> [4,] 0.00000000 0.00000000 0.33187578 0.74345426 0.0000000 #> [5,] 0.00000000 0.00000000 0.00000000 0.01656937 0.7731065 #>  #>  #> $F_list #> $F_list[[1]] #>      [,1] [,2] [,3] [,4] [,5] #> [1,]    0    0    4    8   10 #> [2,]    0    0    0    0    0 #> [3,]    0    0    0    0    0 #> [4,]    0    0    0    0    0 #> [5,]    0    0    0    0    0 #>  #> $F_list[[2]] #>      [,1] [,2] [,3] [,4] [,5] #> [1,]    0    0    4    8   10 #> [2,]    0    0    0    0    0 #> [3,]    0    0    0    0    0 #> [4,]    0    0    0    0    0 #> [5,]    0    0    0    0    0 #>  #> $F_list[[3]] #>      [,1] [,2] [,3] [,4] [,5] #> [1,]    0    0    4    8   10 #> [2,]    0    0    0    0    0 #> [3,]    0    0    0    0    0 #> [4,]    0    0    0    0    0 #> [5,]    0    0    0    0    0 #>  #> $F_list[[4]] #>      [,1] [,2] [,3] [,4] [,5] #> [1,]    0    0    4    8   10 #> [2,]    0    0    0    0    0 #> [3,]    0    0    0    0    0 #> [4,]    0    0    0    0    0 #> [5,]    0    0    0    0    0 #>  #> $F_list[[5]] #>      [,1] [,2] [,3] [,4] [,5] #> [1,]    0    0    4    8   10 #> [2,]    0    0    0    0    0 #> [3,]    0    0    0    0    0 #> [4,]    0    0    0    0    0 #> [5,]    0    0    0    0    0 #>  #> $F_list[[6]] #>      [,1] [,2] [,3] [,4] [,5] #> [1,]    0    0    4    8   10 #> [2,]    0    0    0    0    0 #> [3,]    0    0    0    0    0 #> [4,]    0    0    0    0    0 #> [5,]    0    0    0    0    0 #>  #> $F_list[[7]] #>      [,1] [,2] [,3] [,4] [,5] #> [1,]    0    0    4    8   10 #> [2,]    0    0    0    0    0 #> [3,]    0    0    0    0    0 #> [4,]    0    0    0    0    0 #> [5,]    0    0    0    0    0 #>  #> $F_list[[8]] #>      [,1] [,2] [,3] [,4] [,5] #> [1,]    0    0    4    8   10 #> [2,]    0    0    0    0    0 #> [3,]    0    0    0    0    0 #> [4,]    0    0    0    0    0 #> [5,]    0    0    0    0    0 #>  #> $F_list[[9]] #>      [,1] [,2] [,3] [,4] [,5] #> [1,]    0    0    4    8   10 #> [2,]    0    0    0    0    0 #> [3,]    0    0    0    0    0 #> [4,]    0    0    0    0    0 #> [5,]    0    0    0    0    0 #>  #> $F_list[[10]] #>      [,1] [,2] [,3] [,4] [,5] #> [1,]    0    0    4    8   10 #> [2,]    0    0    0    0    0 #> [3,]    0    0    0    0    0 #> [4,]    0    0    0    0    0 #> [5,]    0    0    0    0    0 #>  #>   # As above, but using popdemo::eigs function instead of popbio::lambda # to illustrate use of argument library(popdemo) #> Welcome to popdemo! This is version 1.3-0 #> Use ?popdemo for an intro, or browseVignettes('popdemo') for vignettes #> Citation for popdemo is here: doi.org/10.1111/j.2041-210X.2012.00222.x #> Development and legacy versions are here: github.com/iainmstott/popdemo constrain_df <- data.frame(   fun = \"eigs\", arg = \"lambda\", lower = 0.9, upper =     1.1 ) generate_mpm_set(   n = 10, n_stages = 5, fecundity = c(0, 0, 4, 8, 10),   archetype = 4, constraint = constrain_df, as_compadre = FALSE ) #> $A_list #> $A_list[[1]] #>            [,1]      [,2]      [,3]      [,4]       [,5] #> [1,] 0.33328577 0.0000000 4.0000000 8.0000000 10.0000000 #> [2,] 0.06377826 0.2498128 0.0000000 0.0000000  0.0000000 #> [3,] 0.00000000 0.3337334 0.5963528 0.0000000  0.0000000 #> [4,] 0.00000000 0.0000000 0.1693849 0.5795012  0.0000000 #> [5,] 0.00000000 0.0000000 0.0000000 0.2212670  0.8103362 #>  #> $A_list[[2]] #>           [,1]       [,2]       [,3]       [,4]       [,5] #> [1,] 0.0239377 0.00000000 4.00000000 8.00000000 10.0000000 #> [2,] 0.0366482 0.04343731 0.00000000 0.00000000  0.0000000 #> [3,] 0.0000000 0.68395612 0.68478775 0.00000000  0.0000000 #> [4,] 0.0000000 0.00000000 0.08214221 0.06041167  0.0000000 #> [5,] 0.0000000 0.00000000 0.00000000 0.82870382  0.9361283 #>  #> $A_list[[3]] #>            [,1]      [,2]      [,3]       [,4]       [,5] #> [1,] 0.03354061 0.0000000 4.0000000 8.00000000 10.0000000 #> [2,] 0.24257199 0.1737578 0.0000000 0.00000000  0.0000000 #> [3,] 0.00000000 0.1323195 0.2086060 0.00000000  0.0000000 #> [4,] 0.00000000 0.0000000 0.3520131 0.61162941  0.0000000 #> [5,] 0.00000000 0.0000000 0.0000000 0.06355464  0.7634507 #>  #> $A_list[[4]] #>            [,1]      [,2]      [,3]      [,4]       [,5] #> [1,] 0.18298502 0.0000000 4.0000000 8.0000000 10.0000000 #> [2,] 0.05516901 0.0637293 0.0000000 0.0000000  0.0000000 #> [3,] 0.00000000 0.3666609 0.3365942 0.0000000  0.0000000 #> [4,] 0.00000000 0.0000000 0.3601747 0.2711895  0.0000000 #> [5,] 0.00000000 0.0000000 0.0000000 0.4848073  0.9864156 #>  #> $A_list[[5]] #>            [,1]      [,2]       [,3]      [,4]       [,5] #> [1,] 0.00572345 0.0000000 4.00000000 8.0000000 10.0000000 #> [2,] 0.25867680 0.1849481 0.00000000 0.0000000  0.0000000 #> [3,] 0.00000000 0.2763296 0.47875737 0.0000000  0.0000000 #> [4,] 0.00000000 0.0000000 0.04194771 0.2885805  0.0000000 #> [5,] 0.00000000 0.0000000 0.00000000 0.5292559  0.8627223 #>  #> $A_list[[6]] #>           [,1]       [,2]      [,3]       [,4]       [,5] #> [1,] 0.1689392 0.00000000 4.0000000 8.00000000 10.0000000 #> [2,] 0.2063822 0.30596227 0.0000000 0.00000000  0.0000000 #> [3,] 0.0000000 0.07818665 0.1925666 0.00000000  0.0000000 #> [4,] 0.0000000 0.00000000 0.3427810 0.01826475  0.0000000 #> [5,] 0.0000000 0.00000000 0.0000000 0.63827242  0.9756126 #>  #> $A_list[[7]] #>            [,1]      [,2]       [,3]      [,4]       [,5] #> [1,] 0.00652138 0.0000000 4.00000000 8.0000000 10.0000000 #> [2,] 0.00545548 0.2302399 0.00000000 0.0000000  0.0000000 #> [3,] 0.00000000 0.3754500 0.65618224 0.0000000  0.0000000 #> [4,] 0.00000000 0.0000000 0.01014227 0.6273468  0.0000000 #> [5,] 0.00000000 0.0000000 0.00000000 0.3247017  0.9748711 #>  #> $A_list[[8]] #>           [,1]      [,2]      [,3]      [,4]       [,5] #> [1,] 0.1884203 0.0000000 4.0000000 8.0000000 10.0000000 #> [2,] 0.1412555 0.5157395 0.0000000 0.0000000  0.0000000 #> [3,] 0.0000000 0.1011372 0.3102842 0.0000000  0.0000000 #> [4,] 0.0000000 0.0000000 0.3591664 0.6594515  0.0000000 #> [5,] 0.0000000 0.0000000 0.0000000 0.1373212  0.8799535 #>  #> $A_list[[9]] #>            [,1]       [,2]      [,3]      [,4]       [,5] #> [1,] 0.09476255 0.00000000 4.0000000 8.0000000 10.0000000 #> [2,] 0.07831552 0.54792290 0.0000000 0.0000000  0.0000000 #> [3,] 0.00000000 0.09611724 0.5001257 0.0000000  0.0000000 #> [4,] 0.00000000 0.00000000 0.1557204 0.5926258  0.0000000 #> [5,] 0.00000000 0.00000000 0.0000000 0.1258167  0.8132592 #>  #> $A_list[[10]] #>            [,1]      [,2]     [,3]       [,4]       [,5] #> [1,] 0.05344835 0.0000000 4.000000 8.00000000 10.0000000 #> [2,] 0.19325338 0.1600322 0.000000 0.00000000  0.0000000 #> [3,] 0.00000000 0.1377219 0.301253 0.00000000  0.0000000 #> [4,] 0.00000000 0.0000000 0.336472 0.65045350  0.0000000 #> [5,] 0.00000000 0.0000000 0.000000 0.08209705  0.8151836 #>  #>  #> $U_list #> $U_list[[1]] #>            [,1]      [,2]      [,3]      [,4]      [,5] #> [1,] 0.33328577 0.0000000 0.0000000 0.0000000 0.0000000 #> [2,] 0.06377826 0.2498128 0.0000000 0.0000000 0.0000000 #> [3,] 0.00000000 0.3337334 0.5963528 0.0000000 0.0000000 #> [4,] 0.00000000 0.0000000 0.1693849 0.5795012 0.0000000 #> [5,] 0.00000000 0.0000000 0.0000000 0.2212670 0.8103362 #>  #> $U_list[[2]] #>           [,1]       [,2]       [,3]       [,4]      [,5] #> [1,] 0.0239377 0.00000000 0.00000000 0.00000000 0.0000000 #> [2,] 0.0366482 0.04343731 0.00000000 0.00000000 0.0000000 #> [3,] 0.0000000 0.68395612 0.68478775 0.00000000 0.0000000 #> [4,] 0.0000000 0.00000000 0.08214221 0.06041167 0.0000000 #> [5,] 0.0000000 0.00000000 0.00000000 0.82870382 0.9361283 #>  #> $U_list[[3]] #>            [,1]      [,2]      [,3]       [,4]      [,5] #> [1,] 0.03354061 0.0000000 0.0000000 0.00000000 0.0000000 #> [2,] 0.24257199 0.1737578 0.0000000 0.00000000 0.0000000 #> [3,] 0.00000000 0.1323195 0.2086060 0.00000000 0.0000000 #> [4,] 0.00000000 0.0000000 0.3520131 0.61162941 0.0000000 #> [5,] 0.00000000 0.0000000 0.0000000 0.06355464 0.7634507 #>  #> $U_list[[4]] #>            [,1]      [,2]      [,3]      [,4]      [,5] #> [1,] 0.18298502 0.0000000 0.0000000 0.0000000 0.0000000 #> [2,] 0.05516901 0.0637293 0.0000000 0.0000000 0.0000000 #> [3,] 0.00000000 0.3666609 0.3365942 0.0000000 0.0000000 #> [4,] 0.00000000 0.0000000 0.3601747 0.2711895 0.0000000 #> [5,] 0.00000000 0.0000000 0.0000000 0.4848073 0.9864156 #>  #> $U_list[[5]] #>            [,1]      [,2]       [,3]      [,4]      [,5] #> [1,] 0.00572345 0.0000000 0.00000000 0.0000000 0.0000000 #> [2,] 0.25867680 0.1849481 0.00000000 0.0000000 0.0000000 #> [3,] 0.00000000 0.2763296 0.47875737 0.0000000 0.0000000 #> [4,] 0.00000000 0.0000000 0.04194771 0.2885805 0.0000000 #> [5,] 0.00000000 0.0000000 0.00000000 0.5292559 0.8627223 #>  #> $U_list[[6]] #>           [,1]       [,2]      [,3]       [,4]      [,5] #> [1,] 0.1689392 0.00000000 0.0000000 0.00000000 0.0000000 #> [2,] 0.2063822 0.30596227 0.0000000 0.00000000 0.0000000 #> [3,] 0.0000000 0.07818665 0.1925666 0.00000000 0.0000000 #> [4,] 0.0000000 0.00000000 0.3427810 0.01826475 0.0000000 #> [5,] 0.0000000 0.00000000 0.0000000 0.63827242 0.9756126 #>  #> $U_list[[7]] #>            [,1]      [,2]       [,3]      [,4]      [,5] #> [1,] 0.00652138 0.0000000 0.00000000 0.0000000 0.0000000 #> [2,] 0.00545548 0.2302399 0.00000000 0.0000000 0.0000000 #> [3,] 0.00000000 0.3754500 0.65618224 0.0000000 0.0000000 #> [4,] 0.00000000 0.0000000 0.01014227 0.6273468 0.0000000 #> [5,] 0.00000000 0.0000000 0.00000000 0.3247017 0.9748711 #>  #> $U_list[[8]] #>           [,1]      [,2]      [,3]      [,4]      [,5] #> [1,] 0.1884203 0.0000000 0.0000000 0.0000000 0.0000000 #> [2,] 0.1412555 0.5157395 0.0000000 0.0000000 0.0000000 #> [3,] 0.0000000 0.1011372 0.3102842 0.0000000 0.0000000 #> [4,] 0.0000000 0.0000000 0.3591664 0.6594515 0.0000000 #> [5,] 0.0000000 0.0000000 0.0000000 0.1373212 0.8799535 #>  #> $U_list[[9]] #>            [,1]       [,2]      [,3]      [,4]      [,5] #> [1,] 0.09476255 0.00000000 0.0000000 0.0000000 0.0000000 #> [2,] 0.07831552 0.54792290 0.0000000 0.0000000 0.0000000 #> [3,] 0.00000000 0.09611724 0.5001257 0.0000000 0.0000000 #> [4,] 0.00000000 0.00000000 0.1557204 0.5926258 0.0000000 #> [5,] 0.00000000 0.00000000 0.0000000 0.1258167 0.8132592 #>  #> $U_list[[10]] #>            [,1]      [,2]     [,3]       [,4]      [,5] #> [1,] 0.05344835 0.0000000 0.000000 0.00000000 0.0000000 #> [2,] 0.19325338 0.1600322 0.000000 0.00000000 0.0000000 #> [3,] 0.00000000 0.1377219 0.301253 0.00000000 0.0000000 #> [4,] 0.00000000 0.0000000 0.336472 0.65045350 0.0000000 #> [5,] 0.00000000 0.0000000 0.000000 0.08209705 0.8151836 #>  #>  #> $F_list #> $F_list[[1]] #>      [,1] [,2] [,3] [,4] [,5] #> [1,]    0    0    4    8   10 #> [2,]    0    0    0    0    0 #> [3,]    0    0    0    0    0 #> [4,]    0    0    0    0    0 #> [5,]    0    0    0    0    0 #>  #> $F_list[[2]] #>      [,1] [,2] [,3] [,4] [,5] #> [1,]    0    0    4    8   10 #> [2,]    0    0    0    0    0 #> [3,]    0    0    0    0    0 #> [4,]    0    0    0    0    0 #> [5,]    0    0    0    0    0 #>  #> $F_list[[3]] #>      [,1] [,2] [,3] [,4] [,5] #> [1,]    0    0    4    8   10 #> [2,]    0    0    0    0    0 #> [3,]    0    0    0    0    0 #> [4,]    0    0    0    0    0 #> [5,]    0    0    0    0    0 #>  #> $F_list[[4]] #>      [,1] [,2] [,3] [,4] [,5] #> [1,]    0    0    4    8   10 #> [2,]    0    0    0    0    0 #> [3,]    0    0    0    0    0 #> [4,]    0    0    0    0    0 #> [5,]    0    0    0    0    0 #>  #> $F_list[[5]] #>      [,1] [,2] [,3] [,4] [,5] #> [1,]    0    0    4    8   10 #> [2,]    0    0    0    0    0 #> [3,]    0    0    0    0    0 #> [4,]    0    0    0    0    0 #> [5,]    0    0    0    0    0 #>  #> $F_list[[6]] #>      [,1] [,2] [,3] [,4] [,5] #> [1,]    0    0    4    8   10 #> [2,]    0    0    0    0    0 #> [3,]    0    0    0    0    0 #> [4,]    0    0    0    0    0 #> [5,]    0    0    0    0    0 #>  #> $F_list[[7]] #>      [,1] [,2] [,3] [,4] [,5] #> [1,]    0    0    4    8   10 #> [2,]    0    0    0    0    0 #> [3,]    0    0    0    0    0 #> [4,]    0    0    0    0    0 #> [5,]    0    0    0    0    0 #>  #> $F_list[[8]] #>      [,1] [,2] [,3] [,4] [,5] #> [1,]    0    0    4    8   10 #> [2,]    0    0    0    0    0 #> [3,]    0    0    0    0    0 #> [4,]    0    0    0    0    0 #> [5,]    0    0    0    0    0 #>  #> $F_list[[9]] #>      [,1] [,2] [,3] [,4] [,5] #> [1,]    0    0    4    8   10 #> [2,]    0    0    0    0    0 #> [3,]    0    0    0    0    0 #> [4,]    0    0    0    0    0 #> [5,]    0    0    0    0    0 #>  #> $F_list[[10]] #>      [,1] [,2] [,3] [,4] [,5] #> [1,]    0    0    4    8   10 #> [2,]    0    0    0    0    0 #> [3,]    0    0    0    0    0 #> [4,]    0    0    0    0    0 #> [5,]    0    0    0    0    0 #>  #>   # Multiple constraints # Constrain outputs to A matrices with lambda between 0.9 and 1.1, generation # time between 3 and 5 and damping ratio between 1 and 7. library(popbio) constrain_df <- data.frame(   fun = c(\"lambda\", \"generation.time\", \"damping.ratio\"),   arg = c(NA, NA, NA),   lower = c(0.9, 3.0, 1.0),   upper = c(1.1, 5.0, 7.0) ) generate_mpm_set(   n = 10, n_stages = 5, fecundity = c(0, 0, 4, 8, 10),   archetype = 4, constraint = constrain_df, as_compadre = FALSE ) #> $A_list #> $A_list[[1]] #>           [,1]      [,2]      [,3]      [,4]       [,5] #> [1,] 0.2215161 0.0000000 4.0000000 8.0000000 10.0000000 #> [2,] 0.1628780 0.2398348 0.0000000 0.0000000  0.0000000 #> [3,] 0.0000000 0.4176027 0.5451896 0.0000000  0.0000000 #> [4,] 0.0000000 0.0000000 0.2235974 0.2776922  0.0000000 #> [5,] 0.0000000 0.0000000 0.0000000 0.5255625  0.9682391 #>  #> $A_list[[2]] #>           [,1]        [,2]      [,3]      [,4]       [,5] #> [1,] 0.2633244 0.000000000 4.0000000 8.0000000 10.0000000 #> [2,] 0.2108113 0.532344404 0.0000000 0.0000000  0.0000000 #> [3,] 0.0000000 0.004494054 0.1274034 0.0000000  0.0000000 #> [4,] 0.0000000 0.000000000 0.5361963 0.1105499  0.0000000 #> [5,] 0.0000000 0.000000000 0.0000000 0.5715804  0.8004599 #>  #> $A_list[[3]] #>             [,1]      [,2]      [,3]      [,4]       [,5] #> [1,] 0.036019608 0.0000000 4.0000000 8.0000000 10.0000000 #> [2,] 0.007165058 0.1339785 0.0000000 0.0000000  0.0000000 #> [3,] 0.000000000 0.4912836 0.7179049 0.0000000  0.0000000 #> [4,] 0.000000000 0.0000000 0.1357687 0.4106779  0.0000000 #> [5,] 0.000000000 0.0000000 0.0000000 0.5146034  0.9286131 #>  #> $A_list[[4]] #>           [,1]      [,2]      [,3]      [,4]       [,5] #> [1,] 0.2242099 0.0000000 4.0000000 8.0000000 10.0000000 #> [2,] 0.4212880 0.2347628 0.0000000 0.0000000  0.0000000 #> [3,] 0.0000000 0.4932071 0.5667867 0.0000000  0.0000000 #> [4,] 0.0000000 0.0000000 0.3834741 0.4861952  0.0000000 #> [5,] 0.0000000 0.0000000 0.0000000 0.4657886  0.9670306 #>  #> $A_list[[5]] #>            [,1]       [,2]      [,3]      [,4]       [,5] #> [1,] 0.01632312 0.00000000 4.0000000 8.0000000 10.0000000 #> [2,] 0.16488654 0.21741849 0.0000000 0.0000000  0.0000000 #> [3,] 0.00000000 0.04855655 0.3199929 0.0000000  0.0000000 #> [4,] 0.00000000 0.00000000 0.1293828 0.3595308  0.0000000 #> [5,] 0.00000000 0.00000000 0.0000000 0.4448042  0.8932768 #>  #> $A_list[[6]] #>           [,1]      [,2]       [,3]      [,4]       [,5] #> [1,] 0.4144249 0.0000000 4.00000000 8.0000000 10.0000000 #> [2,] 0.1257273 0.3536676 0.00000000 0.0000000  0.0000000 #> [3,] 0.0000000 0.2470648 0.73727607 0.0000000  0.0000000 #> [4,] 0.0000000 0.0000000 0.06073812 0.1518907  0.0000000 #> [5,] 0.0000000 0.0000000 0.00000000 0.6807092  0.8370672 #>  #> $A_list[[7]] #>           [,1]       [,2]      [,3]       [,4]       [,5] #> [1,] 0.1172182 0.00000000 4.0000000 8.00000000 10.0000000 #> [2,] 0.2959306 0.58901722 0.0000000 0.00000000  0.0000000 #> [3,] 0.0000000 0.04150199 0.1807843 0.00000000  0.0000000 #> [4,] 0.0000000 0.00000000 0.6355638 0.07568457  0.0000000 #> [5,] 0.0000000 0.00000000 0.0000000 0.90359482  0.9831803 #>  #> $A_list[[8]] #>           [,1]      [,2]      [,3]      [,4]       [,5] #> [1,] 0.2851186 0.0000000 4.0000000 8.0000000 10.0000000 #> [2,] 0.4914640 0.5399783 0.0000000 0.0000000  0.0000000 #> [3,] 0.0000000 0.3387130 0.2868371 0.0000000  0.0000000 #> [4,] 0.0000000 0.0000000 0.6329236 0.6625216  0.0000000 #> [5,] 0.0000000 0.0000000 0.0000000 0.3037399  0.9721035 #>  #> $A_list[[9]] #>           [,1]      [,2]       [,3]      [,4]       [,5] #> [1,] 0.2791730 0.0000000 4.00000000 8.0000000 10.0000000 #> [2,] 0.2425753 0.3766383 0.00000000 0.0000000  0.0000000 #> [3,] 0.0000000 0.2745754 0.83467374 0.0000000  0.0000000 #> [4,] 0.0000000 0.0000000 0.01164569 0.4305712  0.0000000 #> [5,] 0.0000000 0.0000000 0.00000000 0.4928974  0.9476323 #>  #> $A_list[[10]] #>           [,1]       [,2]      [,3]       [,4]       [,5] #> [1,] 0.1053867 0.00000000 4.0000000 8.00000000 10.0000000 #> [2,] 0.4436386 0.53789037 0.0000000 0.00000000  0.0000000 #> [3,] 0.0000000 0.02305909 0.1275618 0.00000000  0.0000000 #> [4,] 0.0000000 0.00000000 0.7625399 0.08617495  0.0000000 #> [5,] 0.0000000 0.00000000 0.0000000 0.81587337  0.9278515 #>  #>  #> $U_list #> $U_list[[1]] #>           [,1]      [,2]      [,3]      [,4]      [,5] #> [1,] 0.2215161 0.0000000 0.0000000 0.0000000 0.0000000 #> [2,] 0.1628780 0.2398348 0.0000000 0.0000000 0.0000000 #> [3,] 0.0000000 0.4176027 0.5451896 0.0000000 0.0000000 #> [4,] 0.0000000 0.0000000 0.2235974 0.2776922 0.0000000 #> [5,] 0.0000000 0.0000000 0.0000000 0.5255625 0.9682391 #>  #> $U_list[[2]] #>           [,1]        [,2]      [,3]      [,4]      [,5] #> [1,] 0.2633244 0.000000000 0.0000000 0.0000000 0.0000000 #> [2,] 0.2108113 0.532344404 0.0000000 0.0000000 0.0000000 #> [3,] 0.0000000 0.004494054 0.1274034 0.0000000 0.0000000 #> [4,] 0.0000000 0.000000000 0.5361963 0.1105499 0.0000000 #> [5,] 0.0000000 0.000000000 0.0000000 0.5715804 0.8004599 #>  #> $U_list[[3]] #>             [,1]      [,2]      [,3]      [,4]      [,5] #> [1,] 0.036019608 0.0000000 0.0000000 0.0000000 0.0000000 #> [2,] 0.007165058 0.1339785 0.0000000 0.0000000 0.0000000 #> [3,] 0.000000000 0.4912836 0.7179049 0.0000000 0.0000000 #> [4,] 0.000000000 0.0000000 0.1357687 0.4106779 0.0000000 #> [5,] 0.000000000 0.0000000 0.0000000 0.5146034 0.9286131 #>  #> $U_list[[4]] #>           [,1]      [,2]      [,3]      [,4]      [,5] #> [1,] 0.2242099 0.0000000 0.0000000 0.0000000 0.0000000 #> [2,] 0.4212880 0.2347628 0.0000000 0.0000000 0.0000000 #> [3,] 0.0000000 0.4932071 0.5667867 0.0000000 0.0000000 #> [4,] 0.0000000 0.0000000 0.3834741 0.4861952 0.0000000 #> [5,] 0.0000000 0.0000000 0.0000000 0.4657886 0.9670306 #>  #> $U_list[[5]] #>            [,1]       [,2]      [,3]      [,4]      [,5] #> [1,] 0.01632312 0.00000000 0.0000000 0.0000000 0.0000000 #> [2,] 0.16488654 0.21741849 0.0000000 0.0000000 0.0000000 #> [3,] 0.00000000 0.04855655 0.3199929 0.0000000 0.0000000 #> [4,] 0.00000000 0.00000000 0.1293828 0.3595308 0.0000000 #> [5,] 0.00000000 0.00000000 0.0000000 0.4448042 0.8932768 #>  #> $U_list[[6]] #>           [,1]      [,2]       [,3]      [,4]      [,5] #> [1,] 0.4144249 0.0000000 0.00000000 0.0000000 0.0000000 #> [2,] 0.1257273 0.3536676 0.00000000 0.0000000 0.0000000 #> [3,] 0.0000000 0.2470648 0.73727607 0.0000000 0.0000000 #> [4,] 0.0000000 0.0000000 0.06073812 0.1518907 0.0000000 #> [5,] 0.0000000 0.0000000 0.00000000 0.6807092 0.8370672 #>  #> $U_list[[7]] #>           [,1]       [,2]      [,3]       [,4]      [,5] #> [1,] 0.1172182 0.00000000 0.0000000 0.00000000 0.0000000 #> [2,] 0.2959306 0.58901722 0.0000000 0.00000000 0.0000000 #> [3,] 0.0000000 0.04150199 0.1807843 0.00000000 0.0000000 #> [4,] 0.0000000 0.00000000 0.6355638 0.07568457 0.0000000 #> [5,] 0.0000000 0.00000000 0.0000000 0.90359482 0.9831803 #>  #> $U_list[[8]] #>           [,1]      [,2]      [,3]      [,4]      [,5] #> [1,] 0.2851186 0.0000000 0.0000000 0.0000000 0.0000000 #> [2,] 0.4914640 0.5399783 0.0000000 0.0000000 0.0000000 #> [3,] 0.0000000 0.3387130 0.2868371 0.0000000 0.0000000 #> [4,] 0.0000000 0.0000000 0.6329236 0.6625216 0.0000000 #> [5,] 0.0000000 0.0000000 0.0000000 0.3037399 0.9721035 #>  #> $U_list[[9]] #>           [,1]      [,2]       [,3]      [,4]      [,5] #> [1,] 0.2791730 0.0000000 0.00000000 0.0000000 0.0000000 #> [2,] 0.2425753 0.3766383 0.00000000 0.0000000 0.0000000 #> [3,] 0.0000000 0.2745754 0.83467374 0.0000000 0.0000000 #> [4,] 0.0000000 0.0000000 0.01164569 0.4305712 0.0000000 #> [5,] 0.0000000 0.0000000 0.00000000 0.4928974 0.9476323 #>  #> $U_list[[10]] #>           [,1]       [,2]      [,3]       [,4]      [,5] #> [1,] 0.1053867 0.00000000 0.0000000 0.00000000 0.0000000 #> [2,] 0.4436386 0.53789037 0.0000000 0.00000000 0.0000000 #> [3,] 0.0000000 0.02305909 0.1275618 0.00000000 0.0000000 #> [4,] 0.0000000 0.00000000 0.7625399 0.08617495 0.0000000 #> [5,] 0.0000000 0.00000000 0.0000000 0.81587337 0.9278515 #>  #>  #> $F_list #> $F_list[[1]] #>      [,1] [,2] [,3] [,4] [,5] #> [1,]    0    0    4    8   10 #> [2,]    0    0    0    0    0 #> [3,]    0    0    0    0    0 #> [4,]    0    0    0    0    0 #> [5,]    0    0    0    0    0 #>  #> $F_list[[2]] #>      [,1] [,2] [,3] [,4] [,5] #> [1,]    0    0    4    8   10 #> [2,]    0    0    0    0    0 #> [3,]    0    0    0    0    0 #> [4,]    0    0    0    0    0 #> [5,]    0    0    0    0    0 #>  #> $F_list[[3]] #>      [,1] [,2] [,3] [,4] [,5] #> [1,]    0    0    4    8   10 #> [2,]    0    0    0    0    0 #> [3,]    0    0    0    0    0 #> [4,]    0    0    0    0    0 #> [5,]    0    0    0    0    0 #>  #> $F_list[[4]] #>      [,1] [,2] [,3] [,4] [,5] #> [1,]    0    0    4    8   10 #> [2,]    0    0    0    0    0 #> [3,]    0    0    0    0    0 #> [4,]    0    0    0    0    0 #> [5,]    0    0    0    0    0 #>  #> $F_list[[5]] #>      [,1] [,2] [,3] [,4] [,5] #> [1,]    0    0    4    8   10 #> [2,]    0    0    0    0    0 #> [3,]    0    0    0    0    0 #> [4,]    0    0    0    0    0 #> [5,]    0    0    0    0    0 #>  #> $F_list[[6]] #>      [,1] [,2] [,3] [,4] [,5] #> [1,]    0    0    4    8   10 #> [2,]    0    0    0    0    0 #> [3,]    0    0    0    0    0 #> [4,]    0    0    0    0    0 #> [5,]    0    0    0    0    0 #>  #> $F_list[[7]] #>      [,1] [,2] [,3] [,4] [,5] #> [1,]    0    0    4    8   10 #> [2,]    0    0    0    0    0 #> [3,]    0    0    0    0    0 #> [4,]    0    0    0    0    0 #> [5,]    0    0    0    0    0 #>  #> $F_list[[8]] #>      [,1] [,2] [,3] [,4] [,5] #> [1,]    0    0    4    8   10 #> [2,]    0    0    0    0    0 #> [3,]    0    0    0    0    0 #> [4,]    0    0    0    0    0 #> [5,]    0    0    0    0    0 #>  #> $F_list[[9]] #>      [,1] [,2] [,3] [,4] [,5] #> [1,]    0    0    4    8   10 #> [2,]    0    0    0    0    0 #> [3,]    0    0    0    0    0 #> [4,]    0    0    0    0    0 #> [5,]    0    0    0    0    0 #>  #> $F_list[[10]] #>      [,1] [,2] [,3] [,4] [,5] #> [1,]    0    0    4    8   10 #> [2,]    0    0    0    0    0 #> [3,]    0    0    0    0    0 #> [4,]    0    0    0    0    0 #> [5,]    0    0    0    0    0 #>  #>"},{"path":"https://jonesor.github.io/mpmsim/reference/make_leslie_mpm.html","id":null,"dir":"Reference","previous_headings":"","what":"Create a Leslie matrix population model — make_leslie_mpm","title":"Create a Leslie matrix population model — make_leslie_mpm","text":"function creates Leslie matrix inputs number stages, fertility (top row matrix), survival probability (value sub-diagonal).","code":""},{"path":"https://jonesor.github.io/mpmsim/reference/make_leslie_mpm.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create a Leslie matrix population model — make_leslie_mpm","text":"","code":"make_leslie_mpm(survival, fertility, n_stages, split = FALSE)"},{"path":"https://jonesor.github.io/mpmsim/reference/make_leslie_mpm.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Create a Leslie matrix population model — make_leslie_mpm","text":"survival numeric value representing survival probability stage along lower -diagonal matrix, final value lower-right corner matrix. one value provided, applied survival elements. fertility numeric vector length n_stages representing fertility rate stage. one value provided, applied fertility elements. n_stages numeric value representing number stages matrix split logical argument indicating whether output matrix split separate , U F matrices (= U + F).","code":""},{"path":"https://jonesor.github.io/mpmsim/reference/make_leslie_mpm.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Create a Leslie matrix population model — make_leslie_mpm","text":"matrix size n_stages x n_stages representing Leslie matrix","code":""},{"path":"https://jonesor.github.io/mpmsim/reference/make_leslie_mpm.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Create a Leslie matrix population model — make_leslie_mpm","text":"Caswell, H. (2001). Matrix Population Models: Construction, Analysis, Interpretation. Sinauer. Leslie, P. H. (1945). use matrices certain population mathematics. Biometrika, 33 (3), 183–212. Leslie, P. H. (1948). Notes Use Matrices Population Mathematics. Biometrika, 35(3-4), 213–245.","code":""},{"path":[]},{"path":"https://jonesor.github.io/mpmsim/reference/make_leslie_mpm.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Create a Leslie matrix population model — make_leslie_mpm","text":"Owen Jones jones@biology.sdu.dk","code":""},{"path":"https://jonesor.github.io/mpmsim/reference/make_leslie_mpm.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Create a Leslie matrix population model — make_leslie_mpm","text":"","code":"make_leslie_mpm(   survival = 0.5, fertility = c(0.1, 0.2, 0.3),   n_stages = 3, split = FALSE ) #>      [,1] [,2] [,3] #> [1,]  0.1  0.2  0.3 #> [2,]  0.5  0.0  0.0 #> [3,]  0.0  0.5  0.5 make_leslie_mpm(   survival = c(0.5, 0.6, 0.7), fertility = c(0.1, 0.2, 0.3),   n_stages = 3 ) #>      [,1] [,2] [,3] #> [1,]  0.1  0.2  0.3 #> [2,]  0.5  0.0  0.0 #> [3,]  0.0  0.6  0.7 make_leslie_mpm(   survival = seq(0.1, 0.7, length.out = 4), fertility = 0.1,   n_stages = 4 ) #>      [,1] [,2] [,3] [,4] #> [1,]  0.1  0.1  0.1  0.1 #> [2,]  0.1  0.0  0.0  0.0 #> [3,]  0.0  0.3  0.0  0.0 #> [4,]  0.0  0.0  0.5  0.7 make_leslie_mpm(   survival = c(0.8, 0.3, 0.2, 0.1, 0.05), fertility = 0.2,   n_stages = 5 ) #>      [,1] [,2] [,3] [,4] [,5] #> [1,]  0.2  0.2  0.2  0.2 0.20 #> [2,]  0.8  0.0  0.0  0.0 0.00 #> [3,]  0.0  0.3  0.0  0.0 0.00 #> [4,]  0.0  0.0  0.2  0.0 0.00 #> [5,]  0.0  0.0  0.0  0.1 0.05"},{"path":"https://jonesor.github.io/mpmsim/reference/model_fertility.html","id":null,"dir":"Reference","previous_headings":"","what":"Model fertility with age using set functional forms — model_fertility","title":"Model fertility with age using set functional forms — model_fertility","text":"function computes fertility based logistic, step, von Bertalanffy, Hadwiger, normal models. logistic model assumes fertility increases sigmoidally age maturity maximum fertility reached. step model assumes fertility zero age maturity remains constant. von Bertalanffy model assumes , maturity, fertility increases asymptotically age maximum fertility reached. formulation, model set fertility 0 'age maturity - 1', increases point. Hadwiger model rather complex intended model human fertility characteristic hump-shaped fertility. models, output ensures fertility zero age maturity.","code":""},{"path":"https://jonesor.github.io/mpmsim/reference/model_fertility.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Model fertility with age using set functional forms — model_fertility","text":"","code":"model_fertility(params, age = NULL, maturity = 0, model = \"logistic\")"},{"path":"https://jonesor.github.io/mpmsim/reference/model_fertility.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Model fertility with age using set functional forms — model_fertility","text":"params numeric vector parameters selected model. number meaning parameters depend selected model. age numeric vector representing age. maturity non-negative numeric value indicating age maturity. Whatever model used, fertility forced 0 age maturity. model character string specifying model use. Must one \"logistic\", \"step\", \"vonbertalanffy\",\"normal\" \"hadwiger\".","code":""},{"path":"https://jonesor.github.io/mpmsim/reference/model_fertility.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Model fertility with age using set functional forms — model_fertility","text":"numeric vector representing computed fertility values.","code":""},{"path":"https://jonesor.github.io/mpmsim/reference/model_fertility.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Model fertility with age using set functional forms — model_fertility","text":"required parameters varies depending fertility model. parameters provided vector parameters must provided order mentioned . Logistic: \\(f(x) = / (1 + exp(-k  (x - x_m)))\\) Step: \\(f(x)=   \\begin{cases}   , x \\geq m \\\\   , x <  m   \\end{cases}\\) von Bertalanffy: \\(f(x) =  (1 - exp(-k  (x - x_0)))\\) Normal: \\(f(x) = \\times \\exp\\left(   -\\frac{1}{2}\\left(\\frac{x-\\mu}{\\sigma}\\right)^{\\!2}\\,\\right)\\) Hadwiger: \\(f(x) = \\frac{ab}{c} \\left (\\frac{c}{x}  \\right )    ^\\frac{3}{2} \\exp \\left \\{ -b^2  \\left ( \\frac{c}{x}+\\frac{x}{c}-2    \\right ) \\right \\}\\)","code":""},{"path":"https://jonesor.github.io/mpmsim/reference/model_fertility.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Model fertility with age using set functional forms — model_fertility","text":"Bertalanffy, L. von (1938) quantitative theory organic growth (inquiries growth laws. II). Human Biology 10:181–213. Peristera, P. & Kostaki, . (2007) Modeling fertility modern populations. Demographic Research. 16. Article 6, 141-194 doi:10.4054/DemRes.2007.16.6","code":""},{"path":[]},{"path":"https://jonesor.github.io/mpmsim/reference/model_fertility.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Model fertility with age using set functional forms — model_fertility","text":"Owen Jones jones@biology.sdu.dk","code":""},{"path":"https://jonesor.github.io/mpmsim/reference/model_fertility.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Model fertility with age using set functional forms — model_fertility","text":"","code":"# Compute fertility using the step model model_fertility(age = 0:20, params = c(A = 10), maturity = 2, model = \"step\") #>  [1]  0  0 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10  # Compute fertility using the logistic model model_fertility(   age = 0:20, params = c(A = 10, k = 0.5, x_m = 8), maturity =     0, model = \"logistic\" ) #>  [1] 0.1798621 0.2931223 0.4742587 0.7585818 1.1920292 1.8242552 2.6894142 #>  [8] 3.7754067 5.0000000 6.2245933 7.3105858 8.1757448 8.8079708 9.2414182 #> [15] 9.5257413 9.7068777 9.8201379 9.8901306 9.9330715 9.9592986 9.9752738  # Compute fertility using the von Bertalanffy model model_fertility(   age = 0:20, params = c(A = 10, k = .3), maturity = 2, model =     \"vonbertalanffy\" ) #>  [1] 0.000000 0.000000 2.591818 4.511884 5.934303 6.988058 7.768698 8.347011 #>  [9] 8.775436 9.092820 9.327945 9.502129 9.631168 9.726763 9.797581 9.850044 #> [17] 9.888910 9.917703 9.939033 9.954834 9.966540  # Compute fertility using the normal model model_fertility(   age = 0:20, params = c(A = 10, mu = 4, sd = 2), maturity = 0,   model = \"normal\" ) #>  [1] 1.353353e+00 3.246525e+00 6.065307e+00 8.824969e+00 1.000000e+01 #>  [6] 8.824969e+00 6.065307e+00 3.246525e+00 1.353353e+00 4.393693e-01 #> [11] 1.110900e-01 2.187491e-02 3.354626e-03 4.006530e-04 3.726653e-05 #> [16] 2.699579e-06 1.522998e-07 6.691586e-09 2.289735e-10 6.101937e-12 #> [21] 1.266417e-13  # Compute fertility using the Hadwiger model model_fertility(   age = 0:50, params = c(a = 0.91, b = 3.85, c = 29.78),   maturity = 0, model = \"hadwiger\" ) #>  [1]           NaN 1.722961e-178  2.632756e-83  7.775444e-52  2.900424e-36 #>  [6]  4.854202e-27  5.511959e-21  9.752061e-17  1.285955e-13  3.012210e-11 #> [11]  2.109246e-09  6.146616e-08  9.291611e-07  8.485057e-06  5.218334e-05 #> [16]  2.340447e-04  8.125653e-04  2.285572e-03  5.396092e-03  1.099593e-02 #> [21]  1.977597e-02  3.196159e-02  4.710896e-02  6.409793e-02  8.132898e-02 #> [26]  9.704998e-02  1.097012e-01  1.181803e-01  1.219739e-01  1.211525e-01 #> [31]  1.162609e-01  1.081542e-01  9.782452e-02  8.625345e-02  7.430620e-02 #> [36]  6.267207e-02  5.184481e-02  4.213231e-02  3.368422e-02  2.652753e-02 #> [41]  2.060288e-02  1.579689e-02  1.196842e-02  8.967956e-03  6.650857e-03 #> [46]  4.885343e-03  3.556515e-03  2.567565e-03  1.839156e-03  1.307766e-03 #> [51]  9.235335e-04"},{"path":"https://jonesor.github.io/mpmsim/reference/model_survival.html","id":null,"dir":"Reference","previous_headings":"","what":"Model mortality hazard, survivorship and age-specific survival probability using a mortality model — model_survival","title":"Model mortality hazard, survivorship and age-specific survival probability using a mortality model — model_survival","text":"Model mortality hazard, survivorship age-specific survival probability using mortality model","code":""},{"path":"https://jonesor.github.io/mpmsim/reference/model_survival.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Model mortality hazard, survivorship and age-specific survival probability using a mortality model — model_survival","text":"","code":"model_survival(params, age = NULL, model, truncate = 0.01)  model_mortality(params, age = NULL, model, truncate = 0.01)"},{"path":"https://jonesor.github.io/mpmsim/reference/model_survival.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Model mortality hazard, survivorship and age-specific survival probability using a mortality model — model_survival","text":"params Numeric vector representing parameters mortality model. age Numeric vector representing age. default NULL, whereby survival trajectory modelled age 0 age survivorship synthetic cohort declines threshold defined truncate argument, default 0.01 (.e. 1% cohort remaining alive). model Mortality model: Gompertz, GompertzMakeham, Exponential, Siler. truncate value defining life table output truncated. default 0.01, indicating life table truncated survivorship, lx, > 0.01 (.e. age 1% cohort remains alive).","code":""},{"path":"https://jonesor.github.io/mpmsim/reference/model_survival.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Model mortality hazard, survivorship and age-specific survival probability using a mortality model — model_survival","text":"data frame columns age (x), hazard (hx), survivorship (lx) mortality (qx) survival probability within interval (px).","code":""},{"path":"https://jonesor.github.io/mpmsim/reference/model_survival.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Model mortality hazard, survivorship and age-specific survival probability using a mortality model — model_survival","text":"required parameters varies depending mortality model. parameters provided vector. Gompertz Weibull, parameters b0, b1. GompertzMakeham parameters b0, b1 C. Exponential, parameter C. Siler, parameters a0, a1, C, b0 b1. Note parameters must provided order mentioned . x represents age. Gompertz: \\(h_x = b_0 \\mathrm{e}^{b_1  x}\\) Gompertz-Makeham: \\(h_x = b_0 \\mathrm{e}^{b_1  x} + c\\) Exponential: \\(h_x = c\\) Siler: \\(h_x = a_0 \\mathrm{e}^{-a_1  x} + c + b_0 \\mathrm{e}^{b_1 x}\\) Weibull: \\(h_x = b_0  b_1  (b_1  x)^(b_0 - 1)\\) output, probability survival (px) (death (qx)) represent probability individuals enter age interval \\([x,x+1]\\) survive end interval (die end interval). possible estimate value final row life table (\\(x+1\\) value) therefore input values age (x) may need extended capture final interval.","code":""},{"path":"https://jonesor.github.io/mpmsim/reference/model_survival.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Model mortality hazard, survivorship and age-specific survival probability using a mortality model — model_survival","text":"Cox, D.R. & Oakes, D. (1984) Analysis Survival Data. Chapman Hall, London, UK. Pinder III, J.E., Wiener, J.G. & Smith, M.H. (1978) Weibull distribution: method summarizing survivorship data. Ecology, 59, 175–179. Pletcher, S. (1999) Model fitting hypothesis testing age-specific mortality data. Journal Evolutionary Biology, 12, 430–439. Siler, W. (1979) competing-risk model animal mortality. Ecology, 60, 750–757. Vaupel, J., Manton, K. & Stallard, E. (1979) impact heterogeneity individual frailty dynamics mortality. Demography, 16, 439–454.","code":""},{"path":[]},{"path":"https://jonesor.github.io/mpmsim/reference/model_survival.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Model mortality hazard, survivorship and age-specific survival probability using a mortality model — model_survival","text":"Owen Jones jones@biology.sdu.dk","code":""},{"path":"https://jonesor.github.io/mpmsim/reference/model_survival.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Model mortality hazard, survivorship and age-specific survival probability using a mortality model — model_survival","text":"","code":"model_survival(params = c(b_0 = 0.1, b_1 = 0.2), model = \"Gompertz\") #>     x        hx         lx        qx        px #> 1   0 0.1000000 1.00000000 0.1051240 0.8948760 #> 2   1 0.1221403 0.89487598 0.1268617 0.8731383 #> 3   2 0.1491825 0.78135045 0.1526972 0.8473028 #> 4   3 0.1822119 0.66204041 0.1832179 0.8167821 #> 5   4 0.2225541 0.54074272 0.2190086 0.7809914 #> 6   5 0.2718282 0.42231542 0.2606027 0.7393973 #> 7   6 0.3320117 0.31225886 0.3084127 0.6915873 #> 8   7 0.4055200 0.21595427 0.3626343 0.6373657 #> 9   8 0.4953032 0.13764186 0.4231275 0.5768725 #> 10  9 0.6049647 0.07940180 0.4892807 0.5107193 #> 11 10 0.7389056 0.04055203 0.5598781 0.4401219 #> 12 11 0.9025013 0.01784784 0.6330059 0.3669941  model_survival(   params = c(b_0 = 0.1, b_1 = 0.2, C = 0.1),   model = \"GompertzMakeham\",   truncate = 0.1 ) #>   x        hx        lx        qx        px #> 1 0 0.2000000 1.0000000 0.1902827 0.8097173 #> 2 1 0.2221403 0.8097173 0.2099518 0.7900482 #> 3 2 0.2491825 0.6397156 0.2333287 0.7666713 #> 4 3 0.2822119 0.4904516 0.2609450 0.7390550 #> 5 4 0.3225541 0.3624707 0.2933298 0.7066702 #> 6 5 0.3718282 0.2561472 0.3309657 0.6690343 #> 7 6 0.4320117 0.1713713 0.3742259 0.6257741 #> 8 7 0.5055200 0.1072397 0.4232876 0.5767124  model_survival(params = c(c = 0.2), model = \"Exponential\", age = 0:10) #>     x  hx        lx        qx        px #> 1   0 0.2 1.0000000 0.1812692 0.8187308 #> 2   1 0.2 0.8187308 0.1812692 0.8187308 #> 3   2 0.2 0.6703200 0.1812692 0.8187308 #> 4   3 0.2 0.5488116 0.1812692 0.8187308 #> 5   4 0.2 0.4493290 0.1812692 0.8187308 #> 6   5 0.2 0.3678794 0.1812692 0.8187308 #> 7   6 0.2 0.3011942 0.1812692 0.8187308 #> 8   7 0.2 0.2465970 0.1812692 0.8187308 #> 9   8 0.2 0.2018965 0.1812692 0.8187308 #> 10  9 0.2 0.1652989 0.1812692 0.8187308 #> 11 10 0.2 0.1353353        NA        NA  model_survival(   params = c(a_0 = 0.1, a_1 = 0.2, C = 0.1, b_0 = 0.1, b_1 = 0.2),   model = \"Siler\",   age = 0:10 ) #>    x        hx         lx        qx        px #> 1  0 0.3000000 1.00000000 0.2606669 0.7393331 #> 2  1 0.3040134 0.73933313 0.2666366 0.7333634 #> 3  2 0.3162145 0.54219987 0.2786665 0.7213335 #> 4  3 0.3370930 0.39110690 0.2969238 0.7030762 #> 5  4 0.3674870 0.27497795 0.3216226 0.6783774 #> 6  5 0.4086161 0.18653882 0.3529771 0.6470229 #> 7  6 0.4621311 0.12069488 0.3911330 0.6088670 #> 8  7 0.5301797 0.07348713 0.4360763 0.5639237 #> 9  8 0.6154929 0.04144114 0.4875201 0.5124799 #> 10 9 0.7214946 0.02123775 0.5447766 0.4552234 model_mortality(params = c(b_0 = 0.1, b_1 = 0.2), model = \"Gompertz\") #>     x        hx         lx        qx        px #> 1   0 0.1000000 1.00000000 0.1051240 0.8948760 #> 2   1 0.1221403 0.89487598 0.1268617 0.8731383 #> 3   2 0.1491825 0.78135045 0.1526972 0.8473028 #> 4   3 0.1822119 0.66204041 0.1832179 0.8167821 #> 5   4 0.2225541 0.54074272 0.2190086 0.7809914 #> 6   5 0.2718282 0.42231542 0.2606027 0.7393973 #> 7   6 0.3320117 0.31225886 0.3084127 0.6915873 #> 8   7 0.4055200 0.21595427 0.3626343 0.6373657 #> 9   8 0.4953032 0.13764186 0.4231275 0.5768725 #> 10  9 0.6049647 0.07940180 0.4892807 0.5107193 #> 11 10 0.7389056 0.04055203 0.5598781 0.4401219 #> 12 11 0.9025013 0.01784784 0.6330059 0.3669941"},{"path":"https://jonesor.github.io/mpmsim/reference/mpmsim-package.html","id":null,"dir":"Reference","previous_headings":"","what":"mpmsim: Simulation of Matrix Population Models with Defined Life History Characteristics — mpmsim-package","title":"mpmsim: Simulation of Matrix Population Models with Defined Life History Characteristics — mpmsim-package","text":"Allows users simulate matrix population models particular characteristics based aspects life history mortality trajectories fertility trajectories. Also allows exploration sampling error due small sample size.","code":""},{"path":[]},{"path":"https://jonesor.github.io/mpmsim/reference/mpmsim-package.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"mpmsim: Simulation of Matrix Population Models with Defined Life History Characteristics — mpmsim-package","text":"Maintainer: Owen Jones jones@biology.sdu.dk (ORCID)","code":""},{"path":"https://jonesor.github.io/mpmsim/reference/plot_matrix.html","id":null,"dir":"Reference","previous_headings":"","what":"Plot a matrix as a heatmap — plot_matrix","title":"Plot a matrix as a heatmap — plot_matrix","text":"Visualise matrix, matrix population model (MPM), heatmap.","code":""},{"path":"https://jonesor.github.io/mpmsim/reference/plot_matrix.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Plot a matrix as a heatmap — plot_matrix","text":"","code":"plot_matrix(mat, zero_na = FALSE, legend = FALSE, na_colour = NA, ...)"},{"path":"https://jonesor.github.io/mpmsim/reference/plot_matrix.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Plot a matrix as a heatmap — plot_matrix","text":"mat matrix, matrix matrix population model zero_na Logical indicating whether zero values treated NA legend Logical indicating whether include legend na_colour Colour NA values ... Additional arguments passed ggplot","code":""},{"path":"https://jonesor.github.io/mpmsim/reference/plot_matrix.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Plot a matrix as a heatmap — plot_matrix","text":"ggplot object","code":""},{"path":"https://jonesor.github.io/mpmsim/reference/plot_matrix.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Plot a matrix as a heatmap — plot_matrix","text":"Owen Jones jones@biology.sdu.dk","code":""},{"path":"https://jonesor.github.io/mpmsim/reference/plot_matrix.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Plot a matrix as a heatmap — plot_matrix","text":"","code":"matDim <- 10 A1 <- make_leslie_mpm(   survival = seq(0.1, 0.7, length.out = matDim),   fertility = seq(0.1, 0.7, length.out = matDim),   n_stages = matDim ) plot_matrix(A1, zero_na = TRUE, na_colour = \"black\")  plot_matrix(A1, zero_na = TRUE, na_colour = NA)"},{"path":"https://jonesor.github.io/mpmsim/reference/random_mpm.html","id":null,"dir":"Reference","previous_headings":"","what":"Generate random Lefkovitch matrix population models (MPMs) based on life history archetypes — random_mpm","title":"Generate random Lefkovitch matrix population models (MPMs) based on life history archetypes — random_mpm","text":"Generates random matrix population model (MPM) element values based defined life history archetypes. Survival transition/growth probabilities particular stage restricted less equal 1 drawing Dirichlet distribution. user can specify archetypes (Takada et al. 2018) restrict MPMs ways: Archetype 1: elements positive, although may small. Therefore, transition /stage possible. model describes life history individuals can progress retrogress rapidly. Archetype 2: form archetype 1 (transition /stage possible), survival probability (column sums survival matrix) increases monotonously individuals advance later stages. model, one first archetype, also allows rapid progression retrogression, realistic stage-specific survival probability increases stage advancement. Archetype 3: positive non-zero elements survival allowed diagonal lower sub-diagonal matrix model represents life cycle species retrogression allowed, progression can happen immediately larger/developed stage (slow progression, e.g., trees). Archetype 4: archetype general form archetype 3, assumption stage-specific survival increases individuals increase size/developmental stage. respect similar archetype 2.","code":""},{"path":"https://jonesor.github.io/mpmsim/reference/random_mpm.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Generate random Lefkovitch matrix population models (MPMs) based on life history archetypes — random_mpm","text":"","code":"random_mpm(n_stages, fecundity, archetype = 1, split = FALSE)"},{"path":"https://jonesor.github.io/mpmsim/reference/random_mpm.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Generate random Lefkovitch matrix population models (MPMs) based on life history archetypes — random_mpm","text":"n_stages integer defining number stages MPM. fecundity Fecundity average number offspring produced. Values can provided 4 ways: numeric vector length 1 provide fecundity measure top right corner matrix model . numeric vector integers length equal n_stages provide fecundity estimates whole top row matrix model. Use 0 cases reproduction. matrix numeric values dimension n_stages provide fecundity estimates entire matrix model. Use 0 cases reproduction. list two matrices numeric values, dimension n_stages, provide lower upper estimates mean fecundity entire matrix model. latter case, fecundity value drawn uniform distribution defined range. reproduction particular age class, use value 0 lower upper limit. archetype Indication life history archetype used, based Takada et al. 2018. integer 1 4. split TRUE/FALSE, indicating whether matrix produced split survival matrix fertility matrix. Yeah true, output becomes list matrix element. Otherwise, output single matrix.","code":""},{"path":"https://jonesor.github.io/mpmsim/reference/random_mpm.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Generate random Lefkovitch matrix population models (MPMs) based on life history archetypes — random_mpm","text":"Returns random matrix population model characteristics determined archetype selected fecundity vector. split = TRUE, matrix split separate fertility growth/survival matrices, returned list.","code":""},{"path":"https://jonesor.github.io/mpmsim/reference/random_mpm.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Generate random Lefkovitch matrix population models (MPMs) based on life history archetypes — random_mpm","text":"4 Archetypes, fecundity placed single element top right matrix, single value. vector length n_stages fertility vector spans entire top row matrix. function constrained output ergodic matrices.","code":""},{"path":"https://jonesor.github.io/mpmsim/reference/random_mpm.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Generate random Lefkovitch matrix population models (MPMs) based on life history archetypes — random_mpm","text":"Caswell, H. (2001). Matrix Population Models: Construction, Analysis, Interpretation. Sinauer. Lefkovitch, L. P. (1965). study population growth organisms grouped stages. Biometrics, 21(1), 1. Takada, T., Kawai, Y., & Salguero-Gómez, R. (2018). cautionary note elasticity analyses ternary plot using randomly generated population matrices. Population Ecology, 60(1), 37–47.","code":""},{"path":[]},{"path":"https://jonesor.github.io/mpmsim/reference/random_mpm.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Generate random Lefkovitch matrix population models (MPMs) based on life history archetypes — random_mpm","text":"Owen Jones jones@biology.sdu.dk","code":""},{"path":"https://jonesor.github.io/mpmsim/reference/random_mpm.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Generate random Lefkovitch matrix population models (MPMs) based on life history archetypes — random_mpm","text":"","code":"set.seed(42) # set seed for repeatability  random_mpm(n_stages = 2, fecundity = 20, archetype = 1, split = FALSE) #>            [,1]       [,2] #> [1,] 0.73066610 20.0402850 #> [2,] 0.06797628  0.7190785 random_mpm(n_stages = 2, fecundity = 20, archetype = 2, split = TRUE) #> $mat_A #>           [,1]        [,2] #> [1,] 0.5129277 20.78121699 #> [2,] 0.2895418  0.04959239 #>  #> $mat_U #>           [,1]       [,2] #> [1,] 0.5129277 0.78121699 #> [2,] 0.2895418 0.04959239 #>  #> $mat_F #>      [,1] [,2] #> [1,]    0   20 #> [2,]    0    0 #>  random_mpm(n_stages = 3, fecundity = 20, archetype = 3, split = FALSE) #>            [,1]      [,2]       [,3] #> [1,] 0.26019259 0.0000000 20.0000000 #> [2,] 0.09187956 0.8172080  0.0000000 #> [3,] 0.00000000 0.1640643  0.1762325 random_mpm(n_stages = 4, fecundity = 20, archetype = 4, split = TRUE) #> $mat_A #>            [,1]       [,2]      [,3]       [,4] #> [1,] 0.24002446 0.00000000 0.0000000 20.0000000 #> [2,] 0.03254107 0.05480185 0.0000000  0.0000000 #> [3,] 0.00000000 0.62726117 0.7851646  0.0000000 #> [4,] 0.00000000 0.00000000 0.0786406  0.9661587 #>  #> $mat_U #>            [,1]       [,2]      [,3]      [,4] #> [1,] 0.24002446 0.00000000 0.0000000 0.0000000 #> [2,] 0.03254107 0.05480185 0.0000000 0.0000000 #> [3,] 0.00000000 0.62726117 0.7851646 0.0000000 #> [4,] 0.00000000 0.00000000 0.0786406 0.9661587 #>  #> $mat_F #>      [,1] [,2] [,3] [,4] #> [1,]    0    0    0   20 #> [2,]    0    0    0    0 #> [3,]    0    0    0    0 #> [4,]    0    0    0    0 #>  random_mpm(   n_stages = 5, fecundity = c(0, 0, 4, 8, 10), archetype = 4,   split = TRUE ) #> $mat_A #>             [,1]      [,2]      [,3]      [,4]       [,5] #> [1,] 0.008672344 0.0000000 4.0000000 8.0000000 10.0000000 #> [2,] 0.027810843 0.2560970 0.0000000 0.0000000  0.0000000 #> [3,] 0.000000000 0.5284182 0.1992335 0.0000000  0.0000000 #> [4,] 0.000000000 0.0000000 0.6157474 0.3219698  0.0000000 #> [5,] 0.000000000 0.0000000 0.0000000 0.6398980  0.9915655 #>  #> $mat_U #>             [,1]      [,2]      [,3]      [,4]      [,5] #> [1,] 0.008672344 0.0000000 0.0000000 0.0000000 0.0000000 #> [2,] 0.027810843 0.2560970 0.0000000 0.0000000 0.0000000 #> [3,] 0.000000000 0.5284182 0.1992335 0.0000000 0.0000000 #> [4,] 0.000000000 0.0000000 0.6157474 0.3219698 0.0000000 #> [5,] 0.000000000 0.0000000 0.0000000 0.6398980 0.9915655 #>  #> $mat_F #>      [,1] [,2] [,3] [,4] [,5] #> [1,]    0    0    4    8   10 #> [2,]    0    0    0    0    0 #> [3,]    0    0    0    0    0 #> [4,]    0    0    0    0    0 #> [5,]    0    0    0    0    0 #>  # Using a range of values for fecundity random_mpm(n_stages = 2, fecundity = 20, archetype = 1, split = TRUE) #> $mat_A #>           [,1]        [,2] #> [1,] 0.2558635 20.54431954 #> [2,] 0.0543606  0.07233605 #>  #> $mat_U #>           [,1]       [,2] #> [1,] 0.2558635 0.54431954 #> [2,] 0.0543606 0.07233605 #>  #> $mat_F #>      [,1] [,2] #> [1,]    0   20 #> [2,]    0    0 #>"},{"path":"https://jonesor.github.io/mpmsim/reference/reorganise_matrices.html","id":null,"dir":"Reference","previous_headings":"","what":"Reorganise Matrix Population Models — reorganise_matrices","title":"Reorganise Matrix Population Models — reorganise_matrices","text":"function reorganises list matrix population models, split mat_A, mat_U, mat_F, optionally mat_C sub-matrices. prepares matrices easy conversion compadreDB object.","code":""},{"path":"https://jonesor.github.io/mpmsim/reference/reorganise_matrices.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Reorganise Matrix Population Models — reorganise_matrices","text":"","code":"reorganise_matrices(matrix_list)"},{"path":"https://jonesor.github.io/mpmsim/reference/reorganise_matrices.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Reorganise Matrix Population Models — reorganise_matrices","text":"matrix_list list lists, sub-list contains matrices mat_A, mat_U, mat_F, optionally mat_C.","code":""},{"path":"https://jonesor.github.io/mpmsim/reference/reorganise_matrices.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Reorganise Matrix Population Models — reorganise_matrices","text":"list containing four elements: mat_A, mat_U, mat_F, mat_C. element list matrices corresponding respective matrix type input. mat_C exist sub-list, replaced NA matrix dimensions mat_U.","code":""},{"path":"https://jonesor.github.io/mpmsim/reference/reorganise_matrices.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Reorganise Matrix Population Models — reorganise_matrices","text":"function processes list matrix population models, extracting grouping sub-matrices (mat_A, mat_U, mat_F, optionally mat_C) separate lists. mat_C matrix present model, NA matrix size mat_U used placeholder.","code":""},{"path":[]},{"path":"https://jonesor.github.io/mpmsim/reference/reorganise_matrices.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Reorganise Matrix Population Models — reorganise_matrices","text":"Owen Jones jones@biology.sdu.dk","code":""},{"path":"https://jonesor.github.io/mpmsim/reference/reorganise_matrices.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Reorganise Matrix Population Models — reorganise_matrices","text":"","code":"# Example usage matrix_list <- list(   list(mat_A = matrix(1, 2, 2), mat_U = matrix(2, 2, 2), mat_F = matrix(3, 2, 2), mat_C = matrix(4, 2, 2)),   list(mat_A = matrix(5, 2, 2), mat_U = matrix(6, 2, 2), mat_F = matrix(7, 2, 2)) ) reorganised_matrices <- reorganise_matrices(matrix_list) reorganised_matrices$mat_A #> [[1]] #>      [,1] [,2] #> [1,]    1    1 #> [2,]    1    1 #>  #> [[2]] #>      [,1] [,2] #> [1,]    5    5 #> [2,]    5    5 #>"},{"path":"https://jonesor.github.io/mpmsim/news/index.html","id":"mpmsim-development-version","dir":"Changelog","previous_headings":"","what":"mpmsim (development version)","title":"mpmsim (development version)","text":"added new function compute_ci_U() calculates confidence intervals traits derived matrix models U submatrix used. example, life expectancy (using function Rage::life_expect_mean()).","code":""},{"path":"https://jonesor.github.io/mpmsim/news/index.html","id":"mpmsim-200","dir":"Changelog","previous_headings":"","what":"mpmsim 2.0.0","title":"mpmsim 2.0.0","text":"CRAN release: 2024-01-15 removed dependency MCMCpack, reportedly archived CRAN. change means previous versions mpmsim may function correctly advisable update new version.","code":""},{"path":"https://jonesor.github.io/mpmsim/news/index.html","id":"mpmsim-110","dir":"Changelog","previous_headings":"","what":"mpmsim 1.1.0","title":"mpmsim 1.1.0","text":"CRAN release: 2023-09-29 modified simulation fecundity random_mpm(). Now values provided mean fecundity can provided range values, whereby value drawn random uniform distribution. best way create set models different fecundity properties. added function simulate action drivers weather vital rates: drive_vital_rate(). added model_mortality() alias model_survival(). function generate_mpm_set() now returns CompadreDB object default. added full suite unit tests using testthat. Test coverage 97.17%.","code":""},{"path":"https://jonesor.github.io/mpmsim/news/index.html","id":"mpmsim-100","dir":"Changelog","previous_headings":"","what":"mpmsim 1.0.0","title":"mpmsim 1.0.0","text":"CRAN release: 2023-04-18","code":""},{"path":"https://jonesor.github.io/mpmsim/news/index.html","id":"first-release-with-the-following-functionality-1-0-0","dir":"Changelog","previous_headings":"","what":"First release, with the following functionality.","title":"mpmsim 1.0.0","text":"Functions simulating Lefkovitch matrix models: generate_mpm_set() andrandom_mpm(). function constructing Leslie matrix models: make_leslie_mpm(), can make use outputs functions describing demographic trajectories (model_fertility() model_survival()). Functions calculating propagating error: add_mpm_error(), calculate_errors() compute_ci(). utility function: plot_matrix()","code":""}]
